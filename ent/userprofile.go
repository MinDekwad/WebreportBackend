// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"go-api-report2/ent/userprofile"
	"strings"

	"entgo.io/ent/dialect/sql"
)

// Userprofile is the model entity for the Userprofile schema.
type Userprofile struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// UserId holds the value of the "UserId" field.
	UserId string `json:"UserId,omitempty"`
	// Firstname holds the value of the "Firstname" field.
	Firstname string `json:"Firstname,omitempty"`
	// Lastname holds the value of the "Lastname" field.
	Lastname string `json:"Lastname,omitempty"`
	// PhoneNo holds the value of the "PhoneNo" field.
	PhoneNo string `json:"PhoneNo,omitempty"`
	// Email holds the value of the "Email" field.
	Email string `json:"Email,omitempty"`
	// CitizenId holds the value of the "CitizenId" field.
	CitizenId string `json:"CitizenId,omitempty"`
	// BirthDate holds the value of the "BirthDate" field.
	BirthDate string `json:"BirthDate,omitempty"`
	// Gender holds the value of the "Gender" field.
	Gender string `json:"Gender,omitempty"`
	// BusinessAddress holds the value of the "BusinessAddress" field.
	BusinessAddress string `json:"BusinessAddress,omitempty"`
	// OccupationId holds the value of the "OccupationId" field.
	OccupationId int `json:"OccupationId,omitempty"`
	// FileimportID holds the value of the "FileimportID" field.
	FileimportID *int `json:"FileimportID,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Userprofile) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case userprofile.FieldID, userprofile.FieldOccupationId, userprofile.FieldFileimportID:
			values[i] = &sql.NullInt64{}
		case userprofile.FieldUserId, userprofile.FieldFirstname, userprofile.FieldLastname, userprofile.FieldPhoneNo, userprofile.FieldEmail, userprofile.FieldCitizenId, userprofile.FieldBirthDate, userprofile.FieldGender, userprofile.FieldBusinessAddress:
			values[i] = &sql.NullString{}
		default:
			return nil, fmt.Errorf("unexpected column %q for type Userprofile", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Userprofile fields.
func (u *Userprofile) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case userprofile.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			u.ID = int(value.Int64)
		case userprofile.FieldUserId:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field UserId", values[i])
			} else if value.Valid {
				u.UserId = value.String
			}
		case userprofile.FieldFirstname:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field Firstname", values[i])
			} else if value.Valid {
				u.Firstname = value.String
			}
		case userprofile.FieldLastname:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field Lastname", values[i])
			} else if value.Valid {
				u.Lastname = value.String
			}
		case userprofile.FieldPhoneNo:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field PhoneNo", values[i])
			} else if value.Valid {
				u.PhoneNo = value.String
			}
		case userprofile.FieldEmail:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field Email", values[i])
			} else if value.Valid {
				u.Email = value.String
			}
		case userprofile.FieldCitizenId:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field CitizenId", values[i])
			} else if value.Valid {
				u.CitizenId = value.String
			}
		case userprofile.FieldBirthDate:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field BirthDate", values[i])
			} else if value.Valid {
				u.BirthDate = value.String
			}
		case userprofile.FieldGender:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field Gender", values[i])
			} else if value.Valid {
				u.Gender = value.String
			}
		case userprofile.FieldBusinessAddress:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field BusinessAddress", values[i])
			} else if value.Valid {
				u.BusinessAddress = value.String
			}
		case userprofile.FieldOccupationId:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field OccupationId", values[i])
			} else if value.Valid {
				u.OccupationId = int(value.Int64)
			}
		case userprofile.FieldFileimportID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field FileimportID", values[i])
			} else if value.Valid {
				u.FileimportID = new(int)
				*u.FileimportID = int(value.Int64)
			}
		}
	}
	return nil
}

// Update returns a builder for updating this Userprofile.
// Note that you need to call Userprofile.Unwrap() before calling this method if this Userprofile
// was returned from a transaction, and the transaction was committed or rolled back.
func (u *Userprofile) Update() *UserprofileUpdateOne {
	return (&UserprofileClient{config: u.config}).UpdateOne(u)
}

// Unwrap unwraps the Userprofile entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (u *Userprofile) Unwrap() *Userprofile {
	tx, ok := u.config.driver.(*txDriver)
	if !ok {
		panic("ent: Userprofile is not a transactional entity")
	}
	u.config.driver = tx.drv
	return u
}

// String implements the fmt.Stringer.
func (u *Userprofile) String() string {
	var builder strings.Builder
	builder.WriteString("Userprofile(")
	builder.WriteString(fmt.Sprintf("id=%v", u.ID))
	builder.WriteString(", UserId=")
	builder.WriteString(u.UserId)
	builder.WriteString(", Firstname=")
	builder.WriteString(u.Firstname)
	builder.WriteString(", Lastname=")
	builder.WriteString(u.Lastname)
	builder.WriteString(", PhoneNo=")
	builder.WriteString(u.PhoneNo)
	builder.WriteString(", Email=")
	builder.WriteString(u.Email)
	builder.WriteString(", CitizenId=")
	builder.WriteString(u.CitizenId)
	builder.WriteString(", BirthDate=")
	builder.WriteString(u.BirthDate)
	builder.WriteString(", Gender=")
	builder.WriteString(u.Gender)
	builder.WriteString(", BusinessAddress=")
	builder.WriteString(u.BusinessAddress)
	builder.WriteString(", OccupationId=")
	builder.WriteString(fmt.Sprintf("%v", u.OccupationId))
	if v := u.FileimportID; v != nil {
		builder.WriteString(", FileimportID=")
		builder.WriteString(fmt.Sprintf("%v", *v))
	}
	builder.WriteByte(')')
	return builder.String()
}

// Userprofiles is a parsable slice of Userprofile.
type Userprofiles []*Userprofile

func (u Userprofiles) config(cfg config) {
	for _i := range u {
		u[_i].config = cfg
	}
}
