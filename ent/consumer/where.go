// Code generated by entc, DO NOT EDIT.

package consumer

import (
	"go-api-report2/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// TransactionID applies equality check predicate on the "transaction_id" field. It's identical to TransactionIDEQ.
func TransactionID(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionID), v))
	})
}

// TransactionStatus applies equality check predicate on the "TransactionStatus" field. It's identical to TransactionStatusEQ.
func TransactionStatus(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionStatus), v))
	})
}

// TransactionType applies equality check predicate on the "TransactionType" field. It's identical to TransactionTypeEQ.
func TransactionType(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionType), v))
	})
}

// PaymentChannel applies equality check predicate on the "PaymentChannel" field. It's identical to PaymentChannelEQ.
func PaymentChannel(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentType applies equality check predicate on the "PaymentType" field. It's identical to PaymentTypeEQ.
func PaymentType(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentType), v))
	})
}

// TypeCode applies equality check predicate on the "TypeCode" field. It's identical to TypeCodeEQ.
func TypeCode(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTypeCode), v))
	})
}

// ApprovalCode applies equality check predicate on the "ApprovalCode" field. It's identical to ApprovalCodeEQ.
func ApprovalCode(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApprovalCode), v))
	})
}

// BillerID applies equality check predicate on the "BillerID" field. It's identical to BillerIDEQ.
func BillerID(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBillerID), v))
	})
}

// Ref1 applies equality check predicate on the "ref1" field. It's identical to Ref1EQ.
func Ref1(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef1), v))
	})
}

// Ref2 applies equality check predicate on the "ref2" field. It's identical to Ref2EQ.
func Ref2(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef2), v))
	})
}

// Ref3 applies equality check predicate on the "ref3" field. It's identical to Ref3EQ.
func Ref3(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef3), v))
	})
}

// Amount applies equality check predicate on the "amount" field. It's identical to AmountEQ.
func Amount(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// Fee applies equality check predicate on the "fee" field. It's identical to FeeEQ.
func Fee(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFee), v))
	})
}

// Total applies equality check predicate on the "total" field. It's identical to TotalEQ.
func Total(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotal), v))
	})
}

// FromReference applies equality check predicate on the "FromReference" field. It's identical to FromReferenceEQ.
func FromReference(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromReference), v))
	})
}

// FromPhoneNo applies equality check predicate on the "FromPhoneNo" field. It's identical to FromPhoneNoEQ.
func FromPhoneNo(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromPhoneNo), v))
	})
}

// FromName applies equality check predicate on the "FromName" field. It's identical to FromNameEQ.
func FromName(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromName), v))
	})
}

// ToAccount applies equality check predicate on the "ToAccount" field. It's identical to ToAccountEQ.
func ToAccount(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccount), v))
	})
}

// ToAccountPhoneNo applies equality check predicate on the "ToAccountPhoneNo" field. It's identical to ToAccountPhoneNoEQ.
func ToAccountPhoneNo(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountName applies equality check predicate on the "ToAccountName" field. It's identical to ToAccountNameEQ.
func ToAccountName(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccountName), v))
	})
}

// BankCode applies equality check predicate on the "BankCode" field. It's identical to BankCodeEQ.
func BankCode(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBankCode), v))
	})
}

// TerminalId applies equality check predicate on the "TerminalId" field. It's identical to TerminalIdEQ.
func TerminalId(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTerminalId), v))
	})
}

// TerminalType applies equality check predicate on the "TerminalType" field. It's identical to TerminalTypeEQ.
func TerminalType(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTerminalType), v))
	})
}

// ToAccount105 applies equality check predicate on the "ToAccount105" field. It's identical to ToAccount105EQ.
func ToAccount105(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccount105), v))
	})
}

// FromReference105 applies equality check predicate on the "FromReference105" field. It's identical to FromReference105EQ.
func FromReference105(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromReference105), v))
	})
}

// DateTime applies equality check predicate on the "dateTime" field. It's identical to DateTimeEQ.
func DateTime(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// PartnerRef applies equality check predicate on the "PartnerRef" field. It's identical to PartnerRefEQ.
func PartnerRef(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartnerRef), v))
	})
}

// ResponseCode applies equality check predicate on the "ResponseCode" field. It's identical to ResponseCodeEQ.
func ResponseCode(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponseCode), v))
	})
}

// ResponseDescription applies equality check predicate on the "ResponseDescription" field. It's identical to ResponseDescriptionEQ.
func ResponseDescription(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponseDescription), v))
	})
}

// FileimportID applies equality check predicate on the "FileimportID" field. It's identical to FileimportIDEQ.
func FileimportID(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// TransactionIDEQ applies the EQ predicate on the "transaction_id" field.
func TransactionIDEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionID), v))
	})
}

// TransactionIDNEQ applies the NEQ predicate on the "transaction_id" field.
func TransactionIDNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionID), v))
	})
}

// TransactionIDIn applies the In predicate on the "transaction_id" field.
func TransactionIDIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionID), v...))
	})
}

// TransactionIDNotIn applies the NotIn predicate on the "transaction_id" field.
func TransactionIDNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionID), v...))
	})
}

// TransactionIDGT applies the GT predicate on the "transaction_id" field.
func TransactionIDGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionID), v))
	})
}

// TransactionIDGTE applies the GTE predicate on the "transaction_id" field.
func TransactionIDGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionID), v))
	})
}

// TransactionIDLT applies the LT predicate on the "transaction_id" field.
func TransactionIDLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionID), v))
	})
}

// TransactionIDLTE applies the LTE predicate on the "transaction_id" field.
func TransactionIDLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionID), v))
	})
}

// TransactionIDContains applies the Contains predicate on the "transaction_id" field.
func TransactionIDContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionID), v))
	})
}

// TransactionIDHasPrefix applies the HasPrefix predicate on the "transaction_id" field.
func TransactionIDHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionID), v))
	})
}

// TransactionIDHasSuffix applies the HasSuffix predicate on the "transaction_id" field.
func TransactionIDHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionID), v))
	})
}

// TransactionIDIsNil applies the IsNil predicate on the "transaction_id" field.
func TransactionIDIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTransactionID)))
	})
}

// TransactionIDNotNil applies the NotNil predicate on the "transaction_id" field.
func TransactionIDNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTransactionID)))
	})
}

// TransactionIDEqualFold applies the EqualFold predicate on the "transaction_id" field.
func TransactionIDEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionID), v))
	})
}

// TransactionIDContainsFold applies the ContainsFold predicate on the "transaction_id" field.
func TransactionIDContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionID), v))
	})
}

// TransactionStatusEQ applies the EQ predicate on the "TransactionStatus" field.
func TransactionStatusEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusNEQ applies the NEQ predicate on the "TransactionStatus" field.
func TransactionStatusNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusIn applies the In predicate on the "TransactionStatus" field.
func TransactionStatusIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionStatus), v...))
	})
}

// TransactionStatusNotIn applies the NotIn predicate on the "TransactionStatus" field.
func TransactionStatusNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionStatus), v...))
	})
}

// TransactionStatusGT applies the GT predicate on the "TransactionStatus" field.
func TransactionStatusGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusGTE applies the GTE predicate on the "TransactionStatus" field.
func TransactionStatusGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusLT applies the LT predicate on the "TransactionStatus" field.
func TransactionStatusLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusLTE applies the LTE predicate on the "TransactionStatus" field.
func TransactionStatusLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusContains applies the Contains predicate on the "TransactionStatus" field.
func TransactionStatusContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusHasPrefix applies the HasPrefix predicate on the "TransactionStatus" field.
func TransactionStatusHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusHasSuffix applies the HasSuffix predicate on the "TransactionStatus" field.
func TransactionStatusHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusIsNil applies the IsNil predicate on the "TransactionStatus" field.
func TransactionStatusIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTransactionStatus)))
	})
}

// TransactionStatusNotNil applies the NotNil predicate on the "TransactionStatus" field.
func TransactionStatusNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTransactionStatus)))
	})
}

// TransactionStatusEqualFold applies the EqualFold predicate on the "TransactionStatus" field.
func TransactionStatusEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionStatus), v))
	})
}

// TransactionStatusContainsFold applies the ContainsFold predicate on the "TransactionStatus" field.
func TransactionStatusContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionStatus), v))
	})
}

// TransactionTypeEQ applies the EQ predicate on the "TransactionType" field.
func TransactionTypeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeNEQ applies the NEQ predicate on the "TransactionType" field.
func TransactionTypeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeIn applies the In predicate on the "TransactionType" field.
func TransactionTypeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionType), v...))
	})
}

// TransactionTypeNotIn applies the NotIn predicate on the "TransactionType" field.
func TransactionTypeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionType), v...))
	})
}

// TransactionTypeGT applies the GT predicate on the "TransactionType" field.
func TransactionTypeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeGTE applies the GTE predicate on the "TransactionType" field.
func TransactionTypeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeLT applies the LT predicate on the "TransactionType" field.
func TransactionTypeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeLTE applies the LTE predicate on the "TransactionType" field.
func TransactionTypeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeContains applies the Contains predicate on the "TransactionType" field.
func TransactionTypeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeHasPrefix applies the HasPrefix predicate on the "TransactionType" field.
func TransactionTypeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeHasSuffix applies the HasSuffix predicate on the "TransactionType" field.
func TransactionTypeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeIsNil applies the IsNil predicate on the "TransactionType" field.
func TransactionTypeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTransactionType)))
	})
}

// TransactionTypeNotNil applies the NotNil predicate on the "TransactionType" field.
func TransactionTypeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTransactionType)))
	})
}

// TransactionTypeEqualFold applies the EqualFold predicate on the "TransactionType" field.
func TransactionTypeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeContainsFold applies the ContainsFold predicate on the "TransactionType" field.
func TransactionTypeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionType), v))
	})
}

// PaymentChannelEQ applies the EQ predicate on the "PaymentChannel" field.
func PaymentChannelEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelNEQ applies the NEQ predicate on the "PaymentChannel" field.
func PaymentChannelNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelIn applies the In predicate on the "PaymentChannel" field.
func PaymentChannelIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentChannel), v...))
	})
}

// PaymentChannelNotIn applies the NotIn predicate on the "PaymentChannel" field.
func PaymentChannelNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentChannel), v...))
	})
}

// PaymentChannelGT applies the GT predicate on the "PaymentChannel" field.
func PaymentChannelGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelGTE applies the GTE predicate on the "PaymentChannel" field.
func PaymentChannelGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelLT applies the LT predicate on the "PaymentChannel" field.
func PaymentChannelLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelLTE applies the LTE predicate on the "PaymentChannel" field.
func PaymentChannelLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelContains applies the Contains predicate on the "PaymentChannel" field.
func PaymentChannelContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelHasPrefix applies the HasPrefix predicate on the "PaymentChannel" field.
func PaymentChannelHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelHasSuffix applies the HasSuffix predicate on the "PaymentChannel" field.
func PaymentChannelHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelIsNil applies the IsNil predicate on the "PaymentChannel" field.
func PaymentChannelIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentChannel)))
	})
}

// PaymentChannelNotNil applies the NotNil predicate on the "PaymentChannel" field.
func PaymentChannelNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentChannel)))
	})
}

// PaymentChannelEqualFold applies the EqualFold predicate on the "PaymentChannel" field.
func PaymentChannelEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelContainsFold applies the ContainsFold predicate on the "PaymentChannel" field.
func PaymentChannelContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPaymentChannel), v))
	})
}

// PaymentTypeEQ applies the EQ predicate on the "PaymentType" field.
func PaymentTypeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeNEQ applies the NEQ predicate on the "PaymentType" field.
func PaymentTypeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeIn applies the In predicate on the "PaymentType" field.
func PaymentTypeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentType), v...))
	})
}

// PaymentTypeNotIn applies the NotIn predicate on the "PaymentType" field.
func PaymentTypeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentType), v...))
	})
}

// PaymentTypeGT applies the GT predicate on the "PaymentType" field.
func PaymentTypeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeGTE applies the GTE predicate on the "PaymentType" field.
func PaymentTypeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeLT applies the LT predicate on the "PaymentType" field.
func PaymentTypeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeLTE applies the LTE predicate on the "PaymentType" field.
func PaymentTypeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeContains applies the Contains predicate on the "PaymentType" field.
func PaymentTypeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeHasPrefix applies the HasPrefix predicate on the "PaymentType" field.
func PaymentTypeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeHasSuffix applies the HasSuffix predicate on the "PaymentType" field.
func PaymentTypeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeIsNil applies the IsNil predicate on the "PaymentType" field.
func PaymentTypeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentType)))
	})
}

// PaymentTypeNotNil applies the NotNil predicate on the "PaymentType" field.
func PaymentTypeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentType)))
	})
}

// PaymentTypeEqualFold applies the EqualFold predicate on the "PaymentType" field.
func PaymentTypeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeContainsFold applies the ContainsFold predicate on the "PaymentType" field.
func PaymentTypeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPaymentType), v))
	})
}

// TypeCodeEQ applies the EQ predicate on the "TypeCode" field.
func TypeCodeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTypeCode), v))
	})
}

// TypeCodeNEQ applies the NEQ predicate on the "TypeCode" field.
func TypeCodeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTypeCode), v))
	})
}

// TypeCodeIn applies the In predicate on the "TypeCode" field.
func TypeCodeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTypeCode), v...))
	})
}

// TypeCodeNotIn applies the NotIn predicate on the "TypeCode" field.
func TypeCodeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTypeCode), v...))
	})
}

// TypeCodeGT applies the GT predicate on the "TypeCode" field.
func TypeCodeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTypeCode), v))
	})
}

// TypeCodeGTE applies the GTE predicate on the "TypeCode" field.
func TypeCodeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTypeCode), v))
	})
}

// TypeCodeLT applies the LT predicate on the "TypeCode" field.
func TypeCodeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTypeCode), v))
	})
}

// TypeCodeLTE applies the LTE predicate on the "TypeCode" field.
func TypeCodeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTypeCode), v))
	})
}

// TypeCodeContains applies the Contains predicate on the "TypeCode" field.
func TypeCodeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTypeCode), v))
	})
}

// TypeCodeHasPrefix applies the HasPrefix predicate on the "TypeCode" field.
func TypeCodeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTypeCode), v))
	})
}

// TypeCodeHasSuffix applies the HasSuffix predicate on the "TypeCode" field.
func TypeCodeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTypeCode), v))
	})
}

// TypeCodeIsNil applies the IsNil predicate on the "TypeCode" field.
func TypeCodeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTypeCode)))
	})
}

// TypeCodeNotNil applies the NotNil predicate on the "TypeCode" field.
func TypeCodeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTypeCode)))
	})
}

// TypeCodeEqualFold applies the EqualFold predicate on the "TypeCode" field.
func TypeCodeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTypeCode), v))
	})
}

// TypeCodeContainsFold applies the ContainsFold predicate on the "TypeCode" field.
func TypeCodeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTypeCode), v))
	})
}

// ApprovalCodeEQ applies the EQ predicate on the "ApprovalCode" field.
func ApprovalCodeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeNEQ applies the NEQ predicate on the "ApprovalCode" field.
func ApprovalCodeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeIn applies the In predicate on the "ApprovalCode" field.
func ApprovalCodeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldApprovalCode), v...))
	})
}

// ApprovalCodeNotIn applies the NotIn predicate on the "ApprovalCode" field.
func ApprovalCodeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldApprovalCode), v...))
	})
}

// ApprovalCodeGT applies the GT predicate on the "ApprovalCode" field.
func ApprovalCodeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeGTE applies the GTE predicate on the "ApprovalCode" field.
func ApprovalCodeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeLT applies the LT predicate on the "ApprovalCode" field.
func ApprovalCodeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeLTE applies the LTE predicate on the "ApprovalCode" field.
func ApprovalCodeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeContains applies the Contains predicate on the "ApprovalCode" field.
func ApprovalCodeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeHasPrefix applies the HasPrefix predicate on the "ApprovalCode" field.
func ApprovalCodeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeHasSuffix applies the HasSuffix predicate on the "ApprovalCode" field.
func ApprovalCodeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeIsNil applies the IsNil predicate on the "ApprovalCode" field.
func ApprovalCodeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldApprovalCode)))
	})
}

// ApprovalCodeNotNil applies the NotNil predicate on the "ApprovalCode" field.
func ApprovalCodeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldApprovalCode)))
	})
}

// ApprovalCodeEqualFold applies the EqualFold predicate on the "ApprovalCode" field.
func ApprovalCodeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldApprovalCode), v))
	})
}

// ApprovalCodeContainsFold applies the ContainsFold predicate on the "ApprovalCode" field.
func ApprovalCodeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldApprovalCode), v))
	})
}

// BillerIDEQ applies the EQ predicate on the "BillerID" field.
func BillerIDEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBillerID), v))
	})
}

// BillerIDNEQ applies the NEQ predicate on the "BillerID" field.
func BillerIDNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBillerID), v))
	})
}

// BillerIDIn applies the In predicate on the "BillerID" field.
func BillerIDIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBillerID), v...))
	})
}

// BillerIDNotIn applies the NotIn predicate on the "BillerID" field.
func BillerIDNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBillerID), v...))
	})
}

// BillerIDGT applies the GT predicate on the "BillerID" field.
func BillerIDGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBillerID), v))
	})
}

// BillerIDGTE applies the GTE predicate on the "BillerID" field.
func BillerIDGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBillerID), v))
	})
}

// BillerIDLT applies the LT predicate on the "BillerID" field.
func BillerIDLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBillerID), v))
	})
}

// BillerIDLTE applies the LTE predicate on the "BillerID" field.
func BillerIDLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBillerID), v))
	})
}

// BillerIDContains applies the Contains predicate on the "BillerID" field.
func BillerIDContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBillerID), v))
	})
}

// BillerIDHasPrefix applies the HasPrefix predicate on the "BillerID" field.
func BillerIDHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBillerID), v))
	})
}

// BillerIDHasSuffix applies the HasSuffix predicate on the "BillerID" field.
func BillerIDHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBillerID), v))
	})
}

// BillerIDIsNil applies the IsNil predicate on the "BillerID" field.
func BillerIDIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBillerID)))
	})
}

// BillerIDNotNil applies the NotNil predicate on the "BillerID" field.
func BillerIDNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBillerID)))
	})
}

// BillerIDEqualFold applies the EqualFold predicate on the "BillerID" field.
func BillerIDEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBillerID), v))
	})
}

// BillerIDContainsFold applies the ContainsFold predicate on the "BillerID" field.
func BillerIDContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBillerID), v))
	})
}

// Ref1EQ applies the EQ predicate on the "ref1" field.
func Ref1EQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef1), v))
	})
}

// Ref1NEQ applies the NEQ predicate on the "ref1" field.
func Ref1NEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRef1), v))
	})
}

// Ref1In applies the In predicate on the "ref1" field.
func Ref1In(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRef1), v...))
	})
}

// Ref1NotIn applies the NotIn predicate on the "ref1" field.
func Ref1NotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRef1), v...))
	})
}

// Ref1GT applies the GT predicate on the "ref1" field.
func Ref1GT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRef1), v))
	})
}

// Ref1GTE applies the GTE predicate on the "ref1" field.
func Ref1GTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRef1), v))
	})
}

// Ref1LT applies the LT predicate on the "ref1" field.
func Ref1LT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRef1), v))
	})
}

// Ref1LTE applies the LTE predicate on the "ref1" field.
func Ref1LTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRef1), v))
	})
}

// Ref1Contains applies the Contains predicate on the "ref1" field.
func Ref1Contains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRef1), v))
	})
}

// Ref1HasPrefix applies the HasPrefix predicate on the "ref1" field.
func Ref1HasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRef1), v))
	})
}

// Ref1HasSuffix applies the HasSuffix predicate on the "ref1" field.
func Ref1HasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRef1), v))
	})
}

// Ref1IsNil applies the IsNil predicate on the "ref1" field.
func Ref1IsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRef1)))
	})
}

// Ref1NotNil applies the NotNil predicate on the "ref1" field.
func Ref1NotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRef1)))
	})
}

// Ref1EqualFold applies the EqualFold predicate on the "ref1" field.
func Ref1EqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRef1), v))
	})
}

// Ref1ContainsFold applies the ContainsFold predicate on the "ref1" field.
func Ref1ContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRef1), v))
	})
}

// Ref2EQ applies the EQ predicate on the "ref2" field.
func Ref2EQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef2), v))
	})
}

// Ref2NEQ applies the NEQ predicate on the "ref2" field.
func Ref2NEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRef2), v))
	})
}

// Ref2In applies the In predicate on the "ref2" field.
func Ref2In(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRef2), v...))
	})
}

// Ref2NotIn applies the NotIn predicate on the "ref2" field.
func Ref2NotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRef2), v...))
	})
}

// Ref2GT applies the GT predicate on the "ref2" field.
func Ref2GT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRef2), v))
	})
}

// Ref2GTE applies the GTE predicate on the "ref2" field.
func Ref2GTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRef2), v))
	})
}

// Ref2LT applies the LT predicate on the "ref2" field.
func Ref2LT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRef2), v))
	})
}

// Ref2LTE applies the LTE predicate on the "ref2" field.
func Ref2LTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRef2), v))
	})
}

// Ref2Contains applies the Contains predicate on the "ref2" field.
func Ref2Contains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRef2), v))
	})
}

// Ref2HasPrefix applies the HasPrefix predicate on the "ref2" field.
func Ref2HasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRef2), v))
	})
}

// Ref2HasSuffix applies the HasSuffix predicate on the "ref2" field.
func Ref2HasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRef2), v))
	})
}

// Ref2IsNil applies the IsNil predicate on the "ref2" field.
func Ref2IsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRef2)))
	})
}

// Ref2NotNil applies the NotNil predicate on the "ref2" field.
func Ref2NotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRef2)))
	})
}

// Ref2EqualFold applies the EqualFold predicate on the "ref2" field.
func Ref2EqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRef2), v))
	})
}

// Ref2ContainsFold applies the ContainsFold predicate on the "ref2" field.
func Ref2ContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRef2), v))
	})
}

// Ref3EQ applies the EQ predicate on the "ref3" field.
func Ref3EQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRef3), v))
	})
}

// Ref3NEQ applies the NEQ predicate on the "ref3" field.
func Ref3NEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRef3), v))
	})
}

// Ref3In applies the In predicate on the "ref3" field.
func Ref3In(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRef3), v...))
	})
}

// Ref3NotIn applies the NotIn predicate on the "ref3" field.
func Ref3NotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRef3), v...))
	})
}

// Ref3GT applies the GT predicate on the "ref3" field.
func Ref3GT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRef3), v))
	})
}

// Ref3GTE applies the GTE predicate on the "ref3" field.
func Ref3GTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRef3), v))
	})
}

// Ref3LT applies the LT predicate on the "ref3" field.
func Ref3LT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRef3), v))
	})
}

// Ref3LTE applies the LTE predicate on the "ref3" field.
func Ref3LTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRef3), v))
	})
}

// Ref3Contains applies the Contains predicate on the "ref3" field.
func Ref3Contains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRef3), v))
	})
}

// Ref3HasPrefix applies the HasPrefix predicate on the "ref3" field.
func Ref3HasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRef3), v))
	})
}

// Ref3HasSuffix applies the HasSuffix predicate on the "ref3" field.
func Ref3HasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRef3), v))
	})
}

// Ref3IsNil applies the IsNil predicate on the "ref3" field.
func Ref3IsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRef3)))
	})
}

// Ref3NotNil applies the NotNil predicate on the "ref3" field.
func Ref3NotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRef3)))
	})
}

// Ref3EqualFold applies the EqualFold predicate on the "ref3" field.
func Ref3EqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRef3), v))
	})
}

// Ref3ContainsFold applies the ContainsFold predicate on the "ref3" field.
func Ref3ContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRef3), v))
	})
}

// AmountEQ applies the EQ predicate on the "amount" field.
func AmountEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// AmountNEQ applies the NEQ predicate on the "amount" field.
func AmountNEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmount), v))
	})
}

// AmountIn applies the In predicate on the "amount" field.
func AmountIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmount), v...))
	})
}

// AmountNotIn applies the NotIn predicate on the "amount" field.
func AmountNotIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmount), v...))
	})
}

// AmountGT applies the GT predicate on the "amount" field.
func AmountGT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmount), v))
	})
}

// AmountGTE applies the GTE predicate on the "amount" field.
func AmountGTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmount), v))
	})
}

// AmountLT applies the LT predicate on the "amount" field.
func AmountLT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmount), v))
	})
}

// AmountLTE applies the LTE predicate on the "amount" field.
func AmountLTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmount), v))
	})
}

// AmountIsNil applies the IsNil predicate on the "amount" field.
func AmountIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAmount)))
	})
}

// AmountNotNil applies the NotNil predicate on the "amount" field.
func AmountNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAmount)))
	})
}

// FeeEQ applies the EQ predicate on the "fee" field.
func FeeEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFee), v))
	})
}

// FeeNEQ applies the NEQ predicate on the "fee" field.
func FeeNEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFee), v))
	})
}

// FeeIn applies the In predicate on the "fee" field.
func FeeIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFee), v...))
	})
}

// FeeNotIn applies the NotIn predicate on the "fee" field.
func FeeNotIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFee), v...))
	})
}

// FeeGT applies the GT predicate on the "fee" field.
func FeeGT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFee), v))
	})
}

// FeeGTE applies the GTE predicate on the "fee" field.
func FeeGTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFee), v))
	})
}

// FeeLT applies the LT predicate on the "fee" field.
func FeeLT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFee), v))
	})
}

// FeeLTE applies the LTE predicate on the "fee" field.
func FeeLTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFee), v))
	})
}

// FeeIsNil applies the IsNil predicate on the "fee" field.
func FeeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFee)))
	})
}

// FeeNotNil applies the NotNil predicate on the "fee" field.
func FeeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFee)))
	})
}

// TotalEQ applies the EQ predicate on the "total" field.
func TotalEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTotal), v))
	})
}

// TotalNEQ applies the NEQ predicate on the "total" field.
func TotalNEQ(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTotal), v))
	})
}

// TotalIn applies the In predicate on the "total" field.
func TotalIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTotal), v...))
	})
}

// TotalNotIn applies the NotIn predicate on the "total" field.
func TotalNotIn(vs ...float64) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTotal), v...))
	})
}

// TotalGT applies the GT predicate on the "total" field.
func TotalGT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTotal), v))
	})
}

// TotalGTE applies the GTE predicate on the "total" field.
func TotalGTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTotal), v))
	})
}

// TotalLT applies the LT predicate on the "total" field.
func TotalLT(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTotal), v))
	})
}

// TotalLTE applies the LTE predicate on the "total" field.
func TotalLTE(v float64) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTotal), v))
	})
}

// TotalIsNil applies the IsNil predicate on the "total" field.
func TotalIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTotal)))
	})
}

// TotalNotNil applies the NotNil predicate on the "total" field.
func TotalNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTotal)))
	})
}

// FromReferenceEQ applies the EQ predicate on the "FromReference" field.
func FromReferenceEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromReference), v))
	})
}

// FromReferenceNEQ applies the NEQ predicate on the "FromReference" field.
func FromReferenceNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFromReference), v))
	})
}

// FromReferenceIn applies the In predicate on the "FromReference" field.
func FromReferenceIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFromReference), v...))
	})
}

// FromReferenceNotIn applies the NotIn predicate on the "FromReference" field.
func FromReferenceNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFromReference), v...))
	})
}

// FromReferenceGT applies the GT predicate on the "FromReference" field.
func FromReferenceGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFromReference), v))
	})
}

// FromReferenceGTE applies the GTE predicate on the "FromReference" field.
func FromReferenceGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFromReference), v))
	})
}

// FromReferenceLT applies the LT predicate on the "FromReference" field.
func FromReferenceLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFromReference), v))
	})
}

// FromReferenceLTE applies the LTE predicate on the "FromReference" field.
func FromReferenceLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFromReference), v))
	})
}

// FromReferenceContains applies the Contains predicate on the "FromReference" field.
func FromReferenceContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFromReference), v))
	})
}

// FromReferenceHasPrefix applies the HasPrefix predicate on the "FromReference" field.
func FromReferenceHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFromReference), v))
	})
}

// FromReferenceHasSuffix applies the HasSuffix predicate on the "FromReference" field.
func FromReferenceHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFromReference), v))
	})
}

// FromReferenceIsNil applies the IsNil predicate on the "FromReference" field.
func FromReferenceIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFromReference)))
	})
}

// FromReferenceNotNil applies the NotNil predicate on the "FromReference" field.
func FromReferenceNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFromReference)))
	})
}

// FromReferenceEqualFold applies the EqualFold predicate on the "FromReference" field.
func FromReferenceEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFromReference), v))
	})
}

// FromReferenceContainsFold applies the ContainsFold predicate on the "FromReference" field.
func FromReferenceContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFromReference), v))
	})
}

// FromPhoneNoEQ applies the EQ predicate on the "FromPhoneNo" field.
func FromPhoneNoEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoNEQ applies the NEQ predicate on the "FromPhoneNo" field.
func FromPhoneNoNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoIn applies the In predicate on the "FromPhoneNo" field.
func FromPhoneNoIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFromPhoneNo), v...))
	})
}

// FromPhoneNoNotIn applies the NotIn predicate on the "FromPhoneNo" field.
func FromPhoneNoNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFromPhoneNo), v...))
	})
}

// FromPhoneNoGT applies the GT predicate on the "FromPhoneNo" field.
func FromPhoneNoGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoGTE applies the GTE predicate on the "FromPhoneNo" field.
func FromPhoneNoGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoLT applies the LT predicate on the "FromPhoneNo" field.
func FromPhoneNoLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoLTE applies the LTE predicate on the "FromPhoneNo" field.
func FromPhoneNoLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoContains applies the Contains predicate on the "FromPhoneNo" field.
func FromPhoneNoContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoHasPrefix applies the HasPrefix predicate on the "FromPhoneNo" field.
func FromPhoneNoHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoHasSuffix applies the HasSuffix predicate on the "FromPhoneNo" field.
func FromPhoneNoHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoIsNil applies the IsNil predicate on the "FromPhoneNo" field.
func FromPhoneNoIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFromPhoneNo)))
	})
}

// FromPhoneNoNotNil applies the NotNil predicate on the "FromPhoneNo" field.
func FromPhoneNoNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFromPhoneNo)))
	})
}

// FromPhoneNoEqualFold applies the EqualFold predicate on the "FromPhoneNo" field.
func FromPhoneNoEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFromPhoneNo), v))
	})
}

// FromPhoneNoContainsFold applies the ContainsFold predicate on the "FromPhoneNo" field.
func FromPhoneNoContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFromPhoneNo), v))
	})
}

// FromNameEQ applies the EQ predicate on the "FromName" field.
func FromNameEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromName), v))
	})
}

// FromNameNEQ applies the NEQ predicate on the "FromName" field.
func FromNameNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFromName), v))
	})
}

// FromNameIn applies the In predicate on the "FromName" field.
func FromNameIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFromName), v...))
	})
}

// FromNameNotIn applies the NotIn predicate on the "FromName" field.
func FromNameNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFromName), v...))
	})
}

// FromNameGT applies the GT predicate on the "FromName" field.
func FromNameGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFromName), v))
	})
}

// FromNameGTE applies the GTE predicate on the "FromName" field.
func FromNameGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFromName), v))
	})
}

// FromNameLT applies the LT predicate on the "FromName" field.
func FromNameLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFromName), v))
	})
}

// FromNameLTE applies the LTE predicate on the "FromName" field.
func FromNameLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFromName), v))
	})
}

// FromNameContains applies the Contains predicate on the "FromName" field.
func FromNameContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFromName), v))
	})
}

// FromNameHasPrefix applies the HasPrefix predicate on the "FromName" field.
func FromNameHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFromName), v))
	})
}

// FromNameHasSuffix applies the HasSuffix predicate on the "FromName" field.
func FromNameHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFromName), v))
	})
}

// FromNameIsNil applies the IsNil predicate on the "FromName" field.
func FromNameIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFromName)))
	})
}

// FromNameNotNil applies the NotNil predicate on the "FromName" field.
func FromNameNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFromName)))
	})
}

// FromNameEqualFold applies the EqualFold predicate on the "FromName" field.
func FromNameEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFromName), v))
	})
}

// FromNameContainsFold applies the ContainsFold predicate on the "FromName" field.
func FromNameContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFromName), v))
	})
}

// ToAccountEQ applies the EQ predicate on the "ToAccount" field.
func ToAccountEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccount), v))
	})
}

// ToAccountNEQ applies the NEQ predicate on the "ToAccount" field.
func ToAccountNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToAccount), v))
	})
}

// ToAccountIn applies the In predicate on the "ToAccount" field.
func ToAccountIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToAccount), v...))
	})
}

// ToAccountNotIn applies the NotIn predicate on the "ToAccount" field.
func ToAccountNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToAccount), v...))
	})
}

// ToAccountGT applies the GT predicate on the "ToAccount" field.
func ToAccountGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToAccount), v))
	})
}

// ToAccountGTE applies the GTE predicate on the "ToAccount" field.
func ToAccountGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToAccount), v))
	})
}

// ToAccountLT applies the LT predicate on the "ToAccount" field.
func ToAccountLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToAccount), v))
	})
}

// ToAccountLTE applies the LTE predicate on the "ToAccount" field.
func ToAccountLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToAccount), v))
	})
}

// ToAccountContains applies the Contains predicate on the "ToAccount" field.
func ToAccountContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToAccount), v))
	})
}

// ToAccountHasPrefix applies the HasPrefix predicate on the "ToAccount" field.
func ToAccountHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToAccount), v))
	})
}

// ToAccountHasSuffix applies the HasSuffix predicate on the "ToAccount" field.
func ToAccountHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToAccount), v))
	})
}

// ToAccountIsNil applies the IsNil predicate on the "ToAccount" field.
func ToAccountIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldToAccount)))
	})
}

// ToAccountNotNil applies the NotNil predicate on the "ToAccount" field.
func ToAccountNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldToAccount)))
	})
}

// ToAccountEqualFold applies the EqualFold predicate on the "ToAccount" field.
func ToAccountEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToAccount), v))
	})
}

// ToAccountContainsFold applies the ContainsFold predicate on the "ToAccount" field.
func ToAccountContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToAccount), v))
	})
}

// ToAccountPhoneNoEQ applies the EQ predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoNEQ applies the NEQ predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoIn applies the In predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToAccountPhoneNo), v...))
	})
}

// ToAccountPhoneNoNotIn applies the NotIn predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToAccountPhoneNo), v...))
	})
}

// ToAccountPhoneNoGT applies the GT predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoGTE applies the GTE predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoLT applies the LT predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoLTE applies the LTE predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoContains applies the Contains predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoHasPrefix applies the HasPrefix predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoHasSuffix applies the HasSuffix predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoIsNil applies the IsNil predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldToAccountPhoneNo)))
	})
}

// ToAccountPhoneNoNotNil applies the NotNil predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldToAccountPhoneNo)))
	})
}

// ToAccountPhoneNoEqualFold applies the EqualFold predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountPhoneNoContainsFold applies the ContainsFold predicate on the "ToAccountPhoneNo" field.
func ToAccountPhoneNoContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToAccountPhoneNo), v))
	})
}

// ToAccountNameEQ applies the EQ predicate on the "ToAccountName" field.
func ToAccountNameEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameNEQ applies the NEQ predicate on the "ToAccountName" field.
func ToAccountNameNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameIn applies the In predicate on the "ToAccountName" field.
func ToAccountNameIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToAccountName), v...))
	})
}

// ToAccountNameNotIn applies the NotIn predicate on the "ToAccountName" field.
func ToAccountNameNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToAccountName), v...))
	})
}

// ToAccountNameGT applies the GT predicate on the "ToAccountName" field.
func ToAccountNameGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameGTE applies the GTE predicate on the "ToAccountName" field.
func ToAccountNameGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameLT applies the LT predicate on the "ToAccountName" field.
func ToAccountNameLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameLTE applies the LTE predicate on the "ToAccountName" field.
func ToAccountNameLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameContains applies the Contains predicate on the "ToAccountName" field.
func ToAccountNameContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameHasPrefix applies the HasPrefix predicate on the "ToAccountName" field.
func ToAccountNameHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameHasSuffix applies the HasSuffix predicate on the "ToAccountName" field.
func ToAccountNameHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameIsNil applies the IsNil predicate on the "ToAccountName" field.
func ToAccountNameIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldToAccountName)))
	})
}

// ToAccountNameNotNil applies the NotNil predicate on the "ToAccountName" field.
func ToAccountNameNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldToAccountName)))
	})
}

// ToAccountNameEqualFold applies the EqualFold predicate on the "ToAccountName" field.
func ToAccountNameEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToAccountName), v))
	})
}

// ToAccountNameContainsFold applies the ContainsFold predicate on the "ToAccountName" field.
func ToAccountNameContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToAccountName), v))
	})
}

// BankCodeEQ applies the EQ predicate on the "BankCode" field.
func BankCodeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBankCode), v))
	})
}

// BankCodeNEQ applies the NEQ predicate on the "BankCode" field.
func BankCodeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBankCode), v))
	})
}

// BankCodeIn applies the In predicate on the "BankCode" field.
func BankCodeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBankCode), v...))
	})
}

// BankCodeNotIn applies the NotIn predicate on the "BankCode" field.
func BankCodeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBankCode), v...))
	})
}

// BankCodeGT applies the GT predicate on the "BankCode" field.
func BankCodeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBankCode), v))
	})
}

// BankCodeGTE applies the GTE predicate on the "BankCode" field.
func BankCodeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBankCode), v))
	})
}

// BankCodeLT applies the LT predicate on the "BankCode" field.
func BankCodeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBankCode), v))
	})
}

// BankCodeLTE applies the LTE predicate on the "BankCode" field.
func BankCodeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBankCode), v))
	})
}

// BankCodeContains applies the Contains predicate on the "BankCode" field.
func BankCodeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBankCode), v))
	})
}

// BankCodeHasPrefix applies the HasPrefix predicate on the "BankCode" field.
func BankCodeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBankCode), v))
	})
}

// BankCodeHasSuffix applies the HasSuffix predicate on the "BankCode" field.
func BankCodeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBankCode), v))
	})
}

// BankCodeIsNil applies the IsNil predicate on the "BankCode" field.
func BankCodeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldBankCode)))
	})
}

// BankCodeNotNil applies the NotNil predicate on the "BankCode" field.
func BankCodeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldBankCode)))
	})
}

// BankCodeEqualFold applies the EqualFold predicate on the "BankCode" field.
func BankCodeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBankCode), v))
	})
}

// BankCodeContainsFold applies the ContainsFold predicate on the "BankCode" field.
func BankCodeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBankCode), v))
	})
}

// TerminalIdEQ applies the EQ predicate on the "TerminalId" field.
func TerminalIdEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTerminalId), v))
	})
}

// TerminalIdNEQ applies the NEQ predicate on the "TerminalId" field.
func TerminalIdNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTerminalId), v))
	})
}

// TerminalIdIn applies the In predicate on the "TerminalId" field.
func TerminalIdIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTerminalId), v...))
	})
}

// TerminalIdNotIn applies the NotIn predicate on the "TerminalId" field.
func TerminalIdNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTerminalId), v...))
	})
}

// TerminalIdGT applies the GT predicate on the "TerminalId" field.
func TerminalIdGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTerminalId), v))
	})
}

// TerminalIdGTE applies the GTE predicate on the "TerminalId" field.
func TerminalIdGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTerminalId), v))
	})
}

// TerminalIdLT applies the LT predicate on the "TerminalId" field.
func TerminalIdLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTerminalId), v))
	})
}

// TerminalIdLTE applies the LTE predicate on the "TerminalId" field.
func TerminalIdLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTerminalId), v))
	})
}

// TerminalIdContains applies the Contains predicate on the "TerminalId" field.
func TerminalIdContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTerminalId), v))
	})
}

// TerminalIdHasPrefix applies the HasPrefix predicate on the "TerminalId" field.
func TerminalIdHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTerminalId), v))
	})
}

// TerminalIdHasSuffix applies the HasSuffix predicate on the "TerminalId" field.
func TerminalIdHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTerminalId), v))
	})
}

// TerminalIdIsNil applies the IsNil predicate on the "TerminalId" field.
func TerminalIdIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTerminalId)))
	})
}

// TerminalIdNotNil applies the NotNil predicate on the "TerminalId" field.
func TerminalIdNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTerminalId)))
	})
}

// TerminalIdEqualFold applies the EqualFold predicate on the "TerminalId" field.
func TerminalIdEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTerminalId), v))
	})
}

// TerminalIdContainsFold applies the ContainsFold predicate on the "TerminalId" field.
func TerminalIdContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTerminalId), v))
	})
}

// TerminalTypeEQ applies the EQ predicate on the "TerminalType" field.
func TerminalTypeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeNEQ applies the NEQ predicate on the "TerminalType" field.
func TerminalTypeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeIn applies the In predicate on the "TerminalType" field.
func TerminalTypeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTerminalType), v...))
	})
}

// TerminalTypeNotIn applies the NotIn predicate on the "TerminalType" field.
func TerminalTypeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTerminalType), v...))
	})
}

// TerminalTypeGT applies the GT predicate on the "TerminalType" field.
func TerminalTypeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeGTE applies the GTE predicate on the "TerminalType" field.
func TerminalTypeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeLT applies the LT predicate on the "TerminalType" field.
func TerminalTypeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeLTE applies the LTE predicate on the "TerminalType" field.
func TerminalTypeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeContains applies the Contains predicate on the "TerminalType" field.
func TerminalTypeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeHasPrefix applies the HasPrefix predicate on the "TerminalType" field.
func TerminalTypeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeHasSuffix applies the HasSuffix predicate on the "TerminalType" field.
func TerminalTypeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeIsNil applies the IsNil predicate on the "TerminalType" field.
func TerminalTypeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTerminalType)))
	})
}

// TerminalTypeNotNil applies the NotNil predicate on the "TerminalType" field.
func TerminalTypeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTerminalType)))
	})
}

// TerminalTypeEqualFold applies the EqualFold predicate on the "TerminalType" field.
func TerminalTypeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTerminalType), v))
	})
}

// TerminalTypeContainsFold applies the ContainsFold predicate on the "TerminalType" field.
func TerminalTypeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTerminalType), v))
	})
}

// ToAccount105EQ applies the EQ predicate on the "ToAccount105" field.
func ToAccount105EQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldToAccount105), v))
	})
}

// ToAccount105NEQ applies the NEQ predicate on the "ToAccount105" field.
func ToAccount105NEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldToAccount105), v))
	})
}

// ToAccount105In applies the In predicate on the "ToAccount105" field.
func ToAccount105In(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldToAccount105), v...))
	})
}

// ToAccount105NotIn applies the NotIn predicate on the "ToAccount105" field.
func ToAccount105NotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldToAccount105), v...))
	})
}

// ToAccount105GT applies the GT predicate on the "ToAccount105" field.
func ToAccount105GT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldToAccount105), v))
	})
}

// ToAccount105GTE applies the GTE predicate on the "ToAccount105" field.
func ToAccount105GTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldToAccount105), v))
	})
}

// ToAccount105LT applies the LT predicate on the "ToAccount105" field.
func ToAccount105LT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldToAccount105), v))
	})
}

// ToAccount105LTE applies the LTE predicate on the "ToAccount105" field.
func ToAccount105LTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldToAccount105), v))
	})
}

// ToAccount105Contains applies the Contains predicate on the "ToAccount105" field.
func ToAccount105Contains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldToAccount105), v))
	})
}

// ToAccount105HasPrefix applies the HasPrefix predicate on the "ToAccount105" field.
func ToAccount105HasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldToAccount105), v))
	})
}

// ToAccount105HasSuffix applies the HasSuffix predicate on the "ToAccount105" field.
func ToAccount105HasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldToAccount105), v))
	})
}

// ToAccount105IsNil applies the IsNil predicate on the "ToAccount105" field.
func ToAccount105IsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldToAccount105)))
	})
}

// ToAccount105NotNil applies the NotNil predicate on the "ToAccount105" field.
func ToAccount105NotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldToAccount105)))
	})
}

// ToAccount105EqualFold applies the EqualFold predicate on the "ToAccount105" field.
func ToAccount105EqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldToAccount105), v))
	})
}

// ToAccount105ContainsFold applies the ContainsFold predicate on the "ToAccount105" field.
func ToAccount105ContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldToAccount105), v))
	})
}

// FromReference105EQ applies the EQ predicate on the "FromReference105" field.
func FromReference105EQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFromReference105), v))
	})
}

// FromReference105NEQ applies the NEQ predicate on the "FromReference105" field.
func FromReference105NEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFromReference105), v))
	})
}

// FromReference105In applies the In predicate on the "FromReference105" field.
func FromReference105In(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFromReference105), v...))
	})
}

// FromReference105NotIn applies the NotIn predicate on the "FromReference105" field.
func FromReference105NotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFromReference105), v...))
	})
}

// FromReference105GT applies the GT predicate on the "FromReference105" field.
func FromReference105GT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFromReference105), v))
	})
}

// FromReference105GTE applies the GTE predicate on the "FromReference105" field.
func FromReference105GTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFromReference105), v))
	})
}

// FromReference105LT applies the LT predicate on the "FromReference105" field.
func FromReference105LT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFromReference105), v))
	})
}

// FromReference105LTE applies the LTE predicate on the "FromReference105" field.
func FromReference105LTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFromReference105), v))
	})
}

// FromReference105Contains applies the Contains predicate on the "FromReference105" field.
func FromReference105Contains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFromReference105), v))
	})
}

// FromReference105HasPrefix applies the HasPrefix predicate on the "FromReference105" field.
func FromReference105HasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFromReference105), v))
	})
}

// FromReference105HasSuffix applies the HasSuffix predicate on the "FromReference105" field.
func FromReference105HasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFromReference105), v))
	})
}

// FromReference105IsNil applies the IsNil predicate on the "FromReference105" field.
func FromReference105IsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFromReference105)))
	})
}

// FromReference105NotNil applies the NotNil predicate on the "FromReference105" field.
func FromReference105NotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFromReference105)))
	})
}

// FromReference105EqualFold applies the EqualFold predicate on the "FromReference105" field.
func FromReference105EqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFromReference105), v))
	})
}

// FromReference105ContainsFold applies the ContainsFold predicate on the "FromReference105" field.
func FromReference105ContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFromReference105), v))
	})
}

// DateTimeEQ applies the EQ predicate on the "dateTime" field.
func DateTimeEQ(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// DateTimeNEQ applies the NEQ predicate on the "dateTime" field.
func DateTimeNEQ(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateTime), v))
	})
}

// DateTimeIn applies the In predicate on the "dateTime" field.
func DateTimeIn(vs ...time.Time) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateTime), v...))
	})
}

// DateTimeNotIn applies the NotIn predicate on the "dateTime" field.
func DateTimeNotIn(vs ...time.Time) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateTime), v...))
	})
}

// DateTimeGT applies the GT predicate on the "dateTime" field.
func DateTimeGT(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateTime), v))
	})
}

// DateTimeGTE applies the GTE predicate on the "dateTime" field.
func DateTimeGTE(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateTime), v))
	})
}

// DateTimeLT applies the LT predicate on the "dateTime" field.
func DateTimeLT(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateTime), v))
	})
}

// DateTimeLTE applies the LTE predicate on the "dateTime" field.
func DateTimeLTE(v time.Time) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateTime), v))
	})
}

// DateTimeIsNil applies the IsNil predicate on the "dateTime" field.
func DateTimeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateTime)))
	})
}

// DateTimeNotNil applies the NotNil predicate on the "dateTime" field.
func DateTimeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateTime)))
	})
}

// PartnerRefEQ applies the EQ predicate on the "PartnerRef" field.
func PartnerRefEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefNEQ applies the NEQ predicate on the "PartnerRef" field.
func PartnerRefNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefIn applies the In predicate on the "PartnerRef" field.
func PartnerRefIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPartnerRef), v...))
	})
}

// PartnerRefNotIn applies the NotIn predicate on the "PartnerRef" field.
func PartnerRefNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPartnerRef), v...))
	})
}

// PartnerRefGT applies the GT predicate on the "PartnerRef" field.
func PartnerRefGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefGTE applies the GTE predicate on the "PartnerRef" field.
func PartnerRefGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefLT applies the LT predicate on the "PartnerRef" field.
func PartnerRefLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefLTE applies the LTE predicate on the "PartnerRef" field.
func PartnerRefLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefContains applies the Contains predicate on the "PartnerRef" field.
func PartnerRefContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefHasPrefix applies the HasPrefix predicate on the "PartnerRef" field.
func PartnerRefHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefHasSuffix applies the HasSuffix predicate on the "PartnerRef" field.
func PartnerRefHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefIsNil applies the IsNil predicate on the "PartnerRef" field.
func PartnerRefIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPartnerRef)))
	})
}

// PartnerRefNotNil applies the NotNil predicate on the "PartnerRef" field.
func PartnerRefNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPartnerRef)))
	})
}

// PartnerRefEqualFold applies the EqualFold predicate on the "PartnerRef" field.
func PartnerRefEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPartnerRef), v))
	})
}

// PartnerRefContainsFold applies the ContainsFold predicate on the "PartnerRef" field.
func PartnerRefContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPartnerRef), v))
	})
}

// ResponseCodeEQ applies the EQ predicate on the "ResponseCode" field.
func ResponseCodeEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeNEQ applies the NEQ predicate on the "ResponseCode" field.
func ResponseCodeNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeIn applies the In predicate on the "ResponseCode" field.
func ResponseCodeIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldResponseCode), v...))
	})
}

// ResponseCodeNotIn applies the NotIn predicate on the "ResponseCode" field.
func ResponseCodeNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldResponseCode), v...))
	})
}

// ResponseCodeGT applies the GT predicate on the "ResponseCode" field.
func ResponseCodeGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeGTE applies the GTE predicate on the "ResponseCode" field.
func ResponseCodeGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeLT applies the LT predicate on the "ResponseCode" field.
func ResponseCodeLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeLTE applies the LTE predicate on the "ResponseCode" field.
func ResponseCodeLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeContains applies the Contains predicate on the "ResponseCode" field.
func ResponseCodeContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeHasPrefix applies the HasPrefix predicate on the "ResponseCode" field.
func ResponseCodeHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeHasSuffix applies the HasSuffix predicate on the "ResponseCode" field.
func ResponseCodeHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeIsNil applies the IsNil predicate on the "ResponseCode" field.
func ResponseCodeIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldResponseCode)))
	})
}

// ResponseCodeNotNil applies the NotNil predicate on the "ResponseCode" field.
func ResponseCodeNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldResponseCode)))
	})
}

// ResponseCodeEqualFold applies the EqualFold predicate on the "ResponseCode" field.
func ResponseCodeEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldResponseCode), v))
	})
}

// ResponseCodeContainsFold applies the ContainsFold predicate on the "ResponseCode" field.
func ResponseCodeContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldResponseCode), v))
	})
}

// ResponseDescriptionEQ applies the EQ predicate on the "ResponseDescription" field.
func ResponseDescriptionEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionNEQ applies the NEQ predicate on the "ResponseDescription" field.
func ResponseDescriptionNEQ(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionIn applies the In predicate on the "ResponseDescription" field.
func ResponseDescriptionIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldResponseDescription), v...))
	})
}

// ResponseDescriptionNotIn applies the NotIn predicate on the "ResponseDescription" field.
func ResponseDescriptionNotIn(vs ...string) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldResponseDescription), v...))
	})
}

// ResponseDescriptionGT applies the GT predicate on the "ResponseDescription" field.
func ResponseDescriptionGT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionGTE applies the GTE predicate on the "ResponseDescription" field.
func ResponseDescriptionGTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionLT applies the LT predicate on the "ResponseDescription" field.
func ResponseDescriptionLT(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionLTE applies the LTE predicate on the "ResponseDescription" field.
func ResponseDescriptionLTE(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionContains applies the Contains predicate on the "ResponseDescription" field.
func ResponseDescriptionContains(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionHasPrefix applies the HasPrefix predicate on the "ResponseDescription" field.
func ResponseDescriptionHasPrefix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionHasSuffix applies the HasSuffix predicate on the "ResponseDescription" field.
func ResponseDescriptionHasSuffix(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionIsNil applies the IsNil predicate on the "ResponseDescription" field.
func ResponseDescriptionIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldResponseDescription)))
	})
}

// ResponseDescriptionNotNil applies the NotNil predicate on the "ResponseDescription" field.
func ResponseDescriptionNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldResponseDescription)))
	})
}

// ResponseDescriptionEqualFold applies the EqualFold predicate on the "ResponseDescription" field.
func ResponseDescriptionEqualFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldResponseDescription), v))
	})
}

// ResponseDescriptionContainsFold applies the ContainsFold predicate on the "ResponseDescription" field.
func ResponseDescriptionContainsFold(v string) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldResponseDescription), v))
	})
}

// FileimportIDEQ applies the EQ predicate on the "FileimportID" field.
func FileimportIDEQ(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDNEQ applies the NEQ predicate on the "FileimportID" field.
func FileimportIDNEQ(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIn applies the In predicate on the "FileimportID" field.
func FileimportIDIn(vs ...int) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDNotIn applies the NotIn predicate on the "FileimportID" field.
func FileimportIDNotIn(vs ...int) predicate.Consumer {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Consumer(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDGT applies the GT predicate on the "FileimportID" field.
func FileimportIDGT(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDGTE applies the GTE predicate on the "FileimportID" field.
func FileimportIDGTE(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLT applies the LT predicate on the "FileimportID" field.
func FileimportIDLT(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLTE applies the LTE predicate on the "FileimportID" field.
func FileimportIDLTE(v int) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIsNil applies the IsNil predicate on the "FileimportID" field.
func FileimportIDIsNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFileimportID)))
	})
}

// FileimportIDNotNil applies the NotNil predicate on the "FileimportID" field.
func FileimportIDNotNil() predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFileimportID)))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Consumer) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Consumer) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Consumer) predicate.Consumer {
	return predicate.Consumer(func(s *sql.Selector) {
		p(s.Not())
	})
}
