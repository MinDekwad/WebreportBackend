// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"go-api-report2/ent/agentkyc"
	"go-api-report2/ent/agenttype"
	"go-api-report2/ent/areahistory"
	"go-api-report2/ent/bankdetail"
	"go-api-report2/ent/bulk"
	"go-api-report2/ent/configarea"
	"go-api-report2/ent/configdatecalculaterank"
	"go-api-report2/ent/configoccupation"
	"go-api-report2/ent/configpoint"
	"go-api-report2/ent/consumer"
	"go-api-report2/ent/fileimport"
	"go-api-report2/ent/fileinsert"
	"go-api-report2/ent/limitpoint"
	"go-api-report2/ent/loanbinding"
	"go-api-report2/ent/logexport"
	"go-api-report2/ent/merchanttransaction"
	"go-api-report2/ent/occupationhistory"
	"go-api-report2/ent/pendingkyc"
	"go-api-report2/ent/pendingloanbinding"
	"go-api-report2/ent/pointcsv"
	"go-api-report2/ent/pointkycrv"
	"go-api-report2/ent/pointpendingkyctransaction"
	"go-api-report2/ent/pointpendinglbtransaction"
	"go-api-report2/ent/pointtransaction"
	"go-api-report2/ent/predicate"
	"go-api-report2/ent/ranking"
	"go-api-report2/ent/reportwallet"
	"go-api-report2/ent/reportwallettb"
	"go-api-report2/ent/statementendingbalanc"
	"go-api-report2/ent/transactionfactor"
	"go-api-report2/ent/transactionfactorhistory"
	"go-api-report2/ent/transactionfactoritem"
	"go-api-report2/ent/transactionfactoritemtmp"
	"go-api-report2/ent/userprofile"
	"go-api-report2/ent/userwallet"
	"go-api-report2/ent/watchlist"
	"go-api-report2/ent/watchlisthistory"
	"go-api-report2/ent/watchlisttype"
	"go-api-report2/ent/writelog"
	"sync"
	"time"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAgentkyc                   = "Agentkyc"
	TypeAgenttype                  = "Agenttype"
	TypeAreahistory                = "Areahistory"
	TypeBankdetail                 = "Bankdetail"
	TypeBulk                       = "Bulk"
	TypeConfigarea                 = "Configarea"
	TypeConfigdatecalculaterank    = "Configdatecalculaterank"
	TypeConfigoccupation           = "Configoccupation"
	TypeConfigpoint                = "Configpoint"
	TypeConsumer                   = "Consumer"
	TypeFileimport                 = "Fileimport"
	TypeFileinsert                 = "Fileinsert"
	TypeLimitpoint                 = "Limitpoint"
	TypeLoanbinding                = "Loanbinding"
	TypeLogexport                  = "Logexport"
	TypeMerchantTransaction        = "MerchantTransaction"
	TypeOccupationhistory          = "Occupationhistory"
	TypePendingkyc                 = "Pendingkyc"
	TypePendingloanbinding         = "Pendingloanbinding"
	TypePointcsv                   = "Pointcsv"
	TypePointkycrv                 = "Pointkycrv"
	TypePointpendingkyctransaction = "Pointpendingkyctransaction"
	TypePointpendinglbtransaction  = "Pointpendinglbtransaction"
	TypePointtransaction           = "Pointtransaction"
	TypeRanking                    = "Ranking"
	TypeReportWallet               = "ReportWallet"
	TypeReportwallettb             = "Reportwallettb"
	TypeStatementEndingBalanc      = "StatementEndingBalanc"
	TypeTransactionfactor          = "Transactionfactor"
	TypeTransactionfactorhistory   = "Transactionfactorhistory"
	TypeTransactionfactoritem      = "Transactionfactoritem"
	TypeTransactionfactoritemtmp   = "Transactionfactoritemtmp"
	TypeUserprofile                = "Userprofile"
	TypeUserwallet                 = "Userwallet"
	TypeWatchlist                  = "Watchlist"
	TypeWatchlisthistory           = "Watchlisthistory"
	TypeWatchlisttype              = "Watchlisttype"
	TypeWritelog                   = "Writelog"
)

// AgentkycMutation represents an operation that mutates the Agentkyc nodes in the graph.
type AgentkycMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_KYCDate           *string
	_KYCTime           *string
	_AgentID           *string
	_Agentemail        *string
	_AgentNameLastname *string
	_KYCStatus         *string
	_Consumerwalletid  *string
	_KYCRespond        *string
	_DOPARespond       *string
	_AgentType         *string
	_FileimportID      *int
	add_FileimportID   *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Agentkyc, error)
	predicates         []predicate.Agentkyc
}

var _ ent.Mutation = (*AgentkycMutation)(nil)

// agentkycOption allows management of the mutation configuration using functional options.
type agentkycOption func(*AgentkycMutation)

// newAgentkycMutation creates new mutation for the Agentkyc entity.
func newAgentkycMutation(c config, op Op, opts ...agentkycOption) *AgentkycMutation {
	m := &AgentkycMutation{
		config:        c,
		op:            op,
		typ:           TypeAgentkyc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgentkycID sets the ID field of the mutation.
func withAgentkycID(id int) agentkycOption {
	return func(m *AgentkycMutation) {
		var (
			err   error
			once  sync.Once
			value *Agentkyc
		)
		m.oldValue = func(ctx context.Context) (*Agentkyc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agentkyc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgentkyc sets the old Agentkyc of the mutation.
func withAgentkyc(node *Agentkyc) agentkycOption {
	return func(m *AgentkycMutation) {
		m.oldValue = func(context.Context) (*Agentkyc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgentkycMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgentkycMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agentkyc entities.
func (m *AgentkycMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AgentkycMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetKYCDate sets the "KYCDate" field.
func (m *AgentkycMutation) SetKYCDate(s string) {
	m._KYCDate = &s
}

// KYCDate returns the value of the "KYCDate" field in the mutation.
func (m *AgentkycMutation) KYCDate() (r string, exists bool) {
	v := m._KYCDate
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYCDate" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldKYCDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYCDate" field.
func (m *AgentkycMutation) ClearKYCDate() {
	m._KYCDate = nil
	m.clearedFields[agentkyc.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYCDate" field was cleared in this mutation.
func (m *AgentkycMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYCDate" field.
func (m *AgentkycMutation) ResetKYCDate() {
	m._KYCDate = nil
	delete(m.clearedFields, agentkyc.FieldKYCDate)
}

// SetKYCTime sets the "KYCTime" field.
func (m *AgentkycMutation) SetKYCTime(s string) {
	m._KYCTime = &s
}

// KYCTime returns the value of the "KYCTime" field in the mutation.
func (m *AgentkycMutation) KYCTime() (r string, exists bool) {
	v := m._KYCTime
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCTime returns the old "KYCTime" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldKYCTime(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCTime: %w", err)
	}
	return oldValue.KYCTime, nil
}

// ClearKYCTime clears the value of the "KYCTime" field.
func (m *AgentkycMutation) ClearKYCTime() {
	m._KYCTime = nil
	m.clearedFields[agentkyc.FieldKYCTime] = struct{}{}
}

// KYCTimeCleared returns if the "KYCTime" field was cleared in this mutation.
func (m *AgentkycMutation) KYCTimeCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldKYCTime]
	return ok
}

// ResetKYCTime resets all changes to the "KYCTime" field.
func (m *AgentkycMutation) ResetKYCTime() {
	m._KYCTime = nil
	delete(m.clearedFields, agentkyc.FieldKYCTime)
}

// SetAgentID sets the "AgentID" field.
func (m *AgentkycMutation) SetAgentID(s string) {
	m._AgentID = &s
}

// AgentID returns the value of the "AgentID" field in the mutation.
func (m *AgentkycMutation) AgentID() (r string, exists bool) {
	v := m._AgentID
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "AgentID" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldAgentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "AgentID" field.
func (m *AgentkycMutation) ClearAgentID() {
	m._AgentID = nil
	m.clearedFields[agentkyc.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "AgentID" field was cleared in this mutation.
func (m *AgentkycMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "AgentID" field.
func (m *AgentkycMutation) ResetAgentID() {
	m._AgentID = nil
	delete(m.clearedFields, agentkyc.FieldAgentID)
}

// SetAgentemail sets the "Agentemail" field.
func (m *AgentkycMutation) SetAgentemail(s string) {
	m._Agentemail = &s
}

// Agentemail returns the value of the "Agentemail" field in the mutation.
func (m *AgentkycMutation) Agentemail() (r string, exists bool) {
	v := m._Agentemail
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentemail returns the old "Agentemail" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldAgentemail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentemail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentemail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentemail: %w", err)
	}
	return oldValue.Agentemail, nil
}

// ClearAgentemail clears the value of the "Agentemail" field.
func (m *AgentkycMutation) ClearAgentemail() {
	m._Agentemail = nil
	m.clearedFields[agentkyc.FieldAgentemail] = struct{}{}
}

// AgentemailCleared returns if the "Agentemail" field was cleared in this mutation.
func (m *AgentkycMutation) AgentemailCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldAgentemail]
	return ok
}

// ResetAgentemail resets all changes to the "Agentemail" field.
func (m *AgentkycMutation) ResetAgentemail() {
	m._Agentemail = nil
	delete(m.clearedFields, agentkyc.FieldAgentemail)
}

// SetAgentNameLastname sets the "AgentNameLastname" field.
func (m *AgentkycMutation) SetAgentNameLastname(s string) {
	m._AgentNameLastname = &s
}

// AgentNameLastname returns the value of the "AgentNameLastname" field in the mutation.
func (m *AgentkycMutation) AgentNameLastname() (r string, exists bool) {
	v := m._AgentNameLastname
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentNameLastname returns the old "AgentNameLastname" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldAgentNameLastname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentNameLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentNameLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentNameLastname: %w", err)
	}
	return oldValue.AgentNameLastname, nil
}

// ClearAgentNameLastname clears the value of the "AgentNameLastname" field.
func (m *AgentkycMutation) ClearAgentNameLastname() {
	m._AgentNameLastname = nil
	m.clearedFields[agentkyc.FieldAgentNameLastname] = struct{}{}
}

// AgentNameLastnameCleared returns if the "AgentNameLastname" field was cleared in this mutation.
func (m *AgentkycMutation) AgentNameLastnameCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldAgentNameLastname]
	return ok
}

// ResetAgentNameLastname resets all changes to the "AgentNameLastname" field.
func (m *AgentkycMutation) ResetAgentNameLastname() {
	m._AgentNameLastname = nil
	delete(m.clearedFields, agentkyc.FieldAgentNameLastname)
}

// SetKYCStatus sets the "KYCStatus" field.
func (m *AgentkycMutation) SetKYCStatus(s string) {
	m._KYCStatus = &s
}

// KYCStatus returns the value of the "KYCStatus" field in the mutation.
func (m *AgentkycMutation) KYCStatus() (r string, exists bool) {
	v := m._KYCStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCStatus returns the old "KYCStatus" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldKYCStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCStatus: %w", err)
	}
	return oldValue.KYCStatus, nil
}

// ClearKYCStatus clears the value of the "KYCStatus" field.
func (m *AgentkycMutation) ClearKYCStatus() {
	m._KYCStatus = nil
	m.clearedFields[agentkyc.FieldKYCStatus] = struct{}{}
}

// KYCStatusCleared returns if the "KYCStatus" field was cleared in this mutation.
func (m *AgentkycMutation) KYCStatusCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldKYCStatus]
	return ok
}

// ResetKYCStatus resets all changes to the "KYCStatus" field.
func (m *AgentkycMutation) ResetKYCStatus() {
	m._KYCStatus = nil
	delete(m.clearedFields, agentkyc.FieldKYCStatus)
}

// SetConsumerwalletid sets the "Consumerwalletid" field.
func (m *AgentkycMutation) SetConsumerwalletid(s string) {
	m._Consumerwalletid = &s
}

// Consumerwalletid returns the value of the "Consumerwalletid" field in the mutation.
func (m *AgentkycMutation) Consumerwalletid() (r string, exists bool) {
	v := m._Consumerwalletid
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumerwalletid returns the old "Consumerwalletid" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldConsumerwalletid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldConsumerwalletid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldConsumerwalletid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumerwalletid: %w", err)
	}
	return oldValue.Consumerwalletid, nil
}

// ClearConsumerwalletid clears the value of the "Consumerwalletid" field.
func (m *AgentkycMutation) ClearConsumerwalletid() {
	m._Consumerwalletid = nil
	m.clearedFields[agentkyc.FieldConsumerwalletid] = struct{}{}
}

// ConsumerwalletidCleared returns if the "Consumerwalletid" field was cleared in this mutation.
func (m *AgentkycMutation) ConsumerwalletidCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldConsumerwalletid]
	return ok
}

// ResetConsumerwalletid resets all changes to the "Consumerwalletid" field.
func (m *AgentkycMutation) ResetConsumerwalletid() {
	m._Consumerwalletid = nil
	delete(m.clearedFields, agentkyc.FieldConsumerwalletid)
}

// SetKYCRespond sets the "KYCRespond" field.
func (m *AgentkycMutation) SetKYCRespond(s string) {
	m._KYCRespond = &s
}

// KYCRespond returns the value of the "KYCRespond" field in the mutation.
func (m *AgentkycMutation) KYCRespond() (r string, exists bool) {
	v := m._KYCRespond
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCRespond returns the old "KYCRespond" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldKYCRespond(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCRespond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCRespond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCRespond: %w", err)
	}
	return oldValue.KYCRespond, nil
}

// ClearKYCRespond clears the value of the "KYCRespond" field.
func (m *AgentkycMutation) ClearKYCRespond() {
	m._KYCRespond = nil
	m.clearedFields[agentkyc.FieldKYCRespond] = struct{}{}
}

// KYCRespondCleared returns if the "KYCRespond" field was cleared in this mutation.
func (m *AgentkycMutation) KYCRespondCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldKYCRespond]
	return ok
}

// ResetKYCRespond resets all changes to the "KYCRespond" field.
func (m *AgentkycMutation) ResetKYCRespond() {
	m._KYCRespond = nil
	delete(m.clearedFields, agentkyc.FieldKYCRespond)
}

// SetDOPARespond sets the "DOPARespond" field.
func (m *AgentkycMutation) SetDOPARespond(s string) {
	m._DOPARespond = &s
}

// DOPARespond returns the value of the "DOPARespond" field in the mutation.
func (m *AgentkycMutation) DOPARespond() (r string, exists bool) {
	v := m._DOPARespond
	if v == nil {
		return
	}
	return *v, true
}

// OldDOPARespond returns the old "DOPARespond" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldDOPARespond(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDOPARespond is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDOPARespond requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDOPARespond: %w", err)
	}
	return oldValue.DOPARespond, nil
}

// ClearDOPARespond clears the value of the "DOPARespond" field.
func (m *AgentkycMutation) ClearDOPARespond() {
	m._DOPARespond = nil
	m.clearedFields[agentkyc.FieldDOPARespond] = struct{}{}
}

// DOPARespondCleared returns if the "DOPARespond" field was cleared in this mutation.
func (m *AgentkycMutation) DOPARespondCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldDOPARespond]
	return ok
}

// ResetDOPARespond resets all changes to the "DOPARespond" field.
func (m *AgentkycMutation) ResetDOPARespond() {
	m._DOPARespond = nil
	delete(m.clearedFields, agentkyc.FieldDOPARespond)
}

// SetAgentType sets the "AgentType" field.
func (m *AgentkycMutation) SetAgentType(s string) {
	m._AgentType = &s
}

// AgentType returns the value of the "AgentType" field in the mutation.
func (m *AgentkycMutation) AgentType() (r string, exists bool) {
	v := m._AgentType
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentType returns the old "AgentType" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldAgentType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentType: %w", err)
	}
	return oldValue.AgentType, nil
}

// ClearAgentType clears the value of the "AgentType" field.
func (m *AgentkycMutation) ClearAgentType() {
	m._AgentType = nil
	m.clearedFields[agentkyc.FieldAgentType] = struct{}{}
}

// AgentTypeCleared returns if the "AgentType" field was cleared in this mutation.
func (m *AgentkycMutation) AgentTypeCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldAgentType]
	return ok
}

// ResetAgentType resets all changes to the "AgentType" field.
func (m *AgentkycMutation) ResetAgentType() {
	m._AgentType = nil
	delete(m.clearedFields, agentkyc.FieldAgentType)
}

// SetFileimportID sets the "FileimportID" field.
func (m *AgentkycMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *AgentkycMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Agentkyc entity.
// If the Agentkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgentkycMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *AgentkycMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *AgentkycMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *AgentkycMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[agentkyc.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *AgentkycMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[agentkyc.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *AgentkycMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, agentkyc.FieldFileimportID)
}

// Op returns the operation name.
func (m *AgentkycMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agentkyc).
func (m *AgentkycMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgentkycMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._KYCDate != nil {
		fields = append(fields, agentkyc.FieldKYCDate)
	}
	if m._KYCTime != nil {
		fields = append(fields, agentkyc.FieldKYCTime)
	}
	if m._AgentID != nil {
		fields = append(fields, agentkyc.FieldAgentID)
	}
	if m._Agentemail != nil {
		fields = append(fields, agentkyc.FieldAgentemail)
	}
	if m._AgentNameLastname != nil {
		fields = append(fields, agentkyc.FieldAgentNameLastname)
	}
	if m._KYCStatus != nil {
		fields = append(fields, agentkyc.FieldKYCStatus)
	}
	if m._Consumerwalletid != nil {
		fields = append(fields, agentkyc.FieldConsumerwalletid)
	}
	if m._KYCRespond != nil {
		fields = append(fields, agentkyc.FieldKYCRespond)
	}
	if m._DOPARespond != nil {
		fields = append(fields, agentkyc.FieldDOPARespond)
	}
	if m._AgentType != nil {
		fields = append(fields, agentkyc.FieldAgentType)
	}
	if m._FileimportID != nil {
		fields = append(fields, agentkyc.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgentkycMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agentkyc.FieldKYCDate:
		return m.KYCDate()
	case agentkyc.FieldKYCTime:
		return m.KYCTime()
	case agentkyc.FieldAgentID:
		return m.AgentID()
	case agentkyc.FieldAgentemail:
		return m.Agentemail()
	case agentkyc.FieldAgentNameLastname:
		return m.AgentNameLastname()
	case agentkyc.FieldKYCStatus:
		return m.KYCStatus()
	case agentkyc.FieldConsumerwalletid:
		return m.Consumerwalletid()
	case agentkyc.FieldKYCRespond:
		return m.KYCRespond()
	case agentkyc.FieldDOPARespond:
		return m.DOPARespond()
	case agentkyc.FieldAgentType:
		return m.AgentType()
	case agentkyc.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgentkycMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agentkyc.FieldKYCDate:
		return m.OldKYCDate(ctx)
	case agentkyc.FieldKYCTime:
		return m.OldKYCTime(ctx)
	case agentkyc.FieldAgentID:
		return m.OldAgentID(ctx)
	case agentkyc.FieldAgentemail:
		return m.OldAgentemail(ctx)
	case agentkyc.FieldAgentNameLastname:
		return m.OldAgentNameLastname(ctx)
	case agentkyc.FieldKYCStatus:
		return m.OldKYCStatus(ctx)
	case agentkyc.FieldConsumerwalletid:
		return m.OldConsumerwalletid(ctx)
	case agentkyc.FieldKYCRespond:
		return m.OldKYCRespond(ctx)
	case agentkyc.FieldDOPARespond:
		return m.OldDOPARespond(ctx)
	case agentkyc.FieldAgentType:
		return m.OldAgentType(ctx)
	case agentkyc.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Agentkyc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentkycMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agentkyc.FieldKYCDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	case agentkyc.FieldKYCTime:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCTime(v)
		return nil
	case agentkyc.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case agentkyc.FieldAgentemail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentemail(v)
		return nil
	case agentkyc.FieldAgentNameLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentNameLastname(v)
		return nil
	case agentkyc.FieldKYCStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCStatus(v)
		return nil
	case agentkyc.FieldConsumerwalletid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumerwalletid(v)
		return nil
	case agentkyc.FieldKYCRespond:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCRespond(v)
		return nil
	case agentkyc.FieldDOPARespond:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDOPARespond(v)
		return nil
	case agentkyc.FieldAgentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentType(v)
		return nil
	case agentkyc.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Agentkyc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgentkycMutation) AddedFields() []string {
	var fields []string
	if m.add_FileimportID != nil {
		fields = append(fields, agentkyc.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgentkycMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case agentkyc.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgentkycMutation) AddField(name string, value ent.Value) error {
	switch name {
	case agentkyc.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Agentkyc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgentkycMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agentkyc.FieldKYCDate) {
		fields = append(fields, agentkyc.FieldKYCDate)
	}
	if m.FieldCleared(agentkyc.FieldKYCTime) {
		fields = append(fields, agentkyc.FieldKYCTime)
	}
	if m.FieldCleared(agentkyc.FieldAgentID) {
		fields = append(fields, agentkyc.FieldAgentID)
	}
	if m.FieldCleared(agentkyc.FieldAgentemail) {
		fields = append(fields, agentkyc.FieldAgentemail)
	}
	if m.FieldCleared(agentkyc.FieldAgentNameLastname) {
		fields = append(fields, agentkyc.FieldAgentNameLastname)
	}
	if m.FieldCleared(agentkyc.FieldKYCStatus) {
		fields = append(fields, agentkyc.FieldKYCStatus)
	}
	if m.FieldCleared(agentkyc.FieldConsumerwalletid) {
		fields = append(fields, agentkyc.FieldConsumerwalletid)
	}
	if m.FieldCleared(agentkyc.FieldKYCRespond) {
		fields = append(fields, agentkyc.FieldKYCRespond)
	}
	if m.FieldCleared(agentkyc.FieldDOPARespond) {
		fields = append(fields, agentkyc.FieldDOPARespond)
	}
	if m.FieldCleared(agentkyc.FieldAgentType) {
		fields = append(fields, agentkyc.FieldAgentType)
	}
	if m.FieldCleared(agentkyc.FieldFileimportID) {
		fields = append(fields, agentkyc.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgentkycMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgentkycMutation) ClearField(name string) error {
	switch name {
	case agentkyc.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	case agentkyc.FieldKYCTime:
		m.ClearKYCTime()
		return nil
	case agentkyc.FieldAgentID:
		m.ClearAgentID()
		return nil
	case agentkyc.FieldAgentemail:
		m.ClearAgentemail()
		return nil
	case agentkyc.FieldAgentNameLastname:
		m.ClearAgentNameLastname()
		return nil
	case agentkyc.FieldKYCStatus:
		m.ClearKYCStatus()
		return nil
	case agentkyc.FieldConsumerwalletid:
		m.ClearConsumerwalletid()
		return nil
	case agentkyc.FieldKYCRespond:
		m.ClearKYCRespond()
		return nil
	case agentkyc.FieldDOPARespond:
		m.ClearDOPARespond()
		return nil
	case agentkyc.FieldAgentType:
		m.ClearAgentType()
		return nil
	case agentkyc.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Agentkyc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgentkycMutation) ResetField(name string) error {
	switch name {
	case agentkyc.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	case agentkyc.FieldKYCTime:
		m.ResetKYCTime()
		return nil
	case agentkyc.FieldAgentID:
		m.ResetAgentID()
		return nil
	case agentkyc.FieldAgentemail:
		m.ResetAgentemail()
		return nil
	case agentkyc.FieldAgentNameLastname:
		m.ResetAgentNameLastname()
		return nil
	case agentkyc.FieldKYCStatus:
		m.ResetKYCStatus()
		return nil
	case agentkyc.FieldConsumerwalletid:
		m.ResetConsumerwalletid()
		return nil
	case agentkyc.FieldKYCRespond:
		m.ResetKYCRespond()
		return nil
	case agentkyc.FieldDOPARespond:
		m.ResetDOPARespond()
		return nil
	case agentkyc.FieldAgentType:
		m.ResetAgentType()
		return nil
	case agentkyc.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Agentkyc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgentkycMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgentkycMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgentkycMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgentkycMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgentkycMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgentkycMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgentkycMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Agentkyc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgentkycMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Agentkyc edge %s", name)
}

// AgenttypeMutation represents an operation that mutates the Agenttype nodes in the graph.
type AgenttypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	agentid       *string
	agentname     *string
	agenttype     *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Agenttype, error)
	predicates    []predicate.Agenttype
}

var _ ent.Mutation = (*AgenttypeMutation)(nil)

// agenttypeOption allows management of the mutation configuration using functional options.
type agenttypeOption func(*AgenttypeMutation)

// newAgenttypeMutation creates new mutation for the Agenttype entity.
func newAgenttypeMutation(c config, op Op, opts ...agenttypeOption) *AgenttypeMutation {
	m := &AgenttypeMutation{
		config:        c,
		op:            op,
		typ:           TypeAgenttype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAgenttypeID sets the ID field of the mutation.
func withAgenttypeID(id int) agenttypeOption {
	return func(m *AgenttypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Agenttype
		)
		m.oldValue = func(ctx context.Context) (*Agenttype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Agenttype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAgenttype sets the old Agenttype of the mutation.
func withAgenttype(node *Agenttype) agenttypeOption {
	return func(m *AgenttypeMutation) {
		m.oldValue = func(context.Context) (*Agenttype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AgenttypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AgenttypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Agenttype entities.
func (m *AgenttypeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AgenttypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAgentid sets the "agentid" field.
func (m *AgenttypeMutation) SetAgentid(s string) {
	m.agentid = &s
}

// Agentid returns the value of the "agentid" field in the mutation.
func (m *AgenttypeMutation) Agentid() (r string, exists bool) {
	v := m.agentid
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentid returns the old "agentid" field's value of the Agenttype entity.
// If the Agenttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgenttypeMutation) OldAgentid(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentid: %w", err)
	}
	return oldValue.Agentid, nil
}

// ClearAgentid clears the value of the "agentid" field.
func (m *AgenttypeMutation) ClearAgentid() {
	m.agentid = nil
	m.clearedFields[agenttype.FieldAgentid] = struct{}{}
}

// AgentidCleared returns if the "agentid" field was cleared in this mutation.
func (m *AgenttypeMutation) AgentidCleared() bool {
	_, ok := m.clearedFields[agenttype.FieldAgentid]
	return ok
}

// ResetAgentid resets all changes to the "agentid" field.
func (m *AgenttypeMutation) ResetAgentid() {
	m.agentid = nil
	delete(m.clearedFields, agenttype.FieldAgentid)
}

// SetAgentname sets the "agentname" field.
func (m *AgenttypeMutation) SetAgentname(s string) {
	m.agentname = &s
}

// Agentname returns the value of the "agentname" field in the mutation.
func (m *AgenttypeMutation) Agentname() (r string, exists bool) {
	v := m.agentname
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentname returns the old "agentname" field's value of the Agenttype entity.
// If the Agenttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgenttypeMutation) OldAgentname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentname: %w", err)
	}
	return oldValue.Agentname, nil
}

// ClearAgentname clears the value of the "agentname" field.
func (m *AgenttypeMutation) ClearAgentname() {
	m.agentname = nil
	m.clearedFields[agenttype.FieldAgentname] = struct{}{}
}

// AgentnameCleared returns if the "agentname" field was cleared in this mutation.
func (m *AgenttypeMutation) AgentnameCleared() bool {
	_, ok := m.clearedFields[agenttype.FieldAgentname]
	return ok
}

// ResetAgentname resets all changes to the "agentname" field.
func (m *AgenttypeMutation) ResetAgentname() {
	m.agentname = nil
	delete(m.clearedFields, agenttype.FieldAgentname)
}

// SetAgenttype sets the "agenttype" field.
func (m *AgenttypeMutation) SetAgenttype(s string) {
	m.agenttype = &s
}

// Agenttype returns the value of the "agenttype" field in the mutation.
func (m *AgenttypeMutation) Agenttype() (r string, exists bool) {
	v := m.agenttype
	if v == nil {
		return
	}
	return *v, true
}

// OldAgenttype returns the old "agenttype" field's value of the Agenttype entity.
// If the Agenttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AgenttypeMutation) OldAgenttype(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgenttype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgenttype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgenttype: %w", err)
	}
	return oldValue.Agenttype, nil
}

// ClearAgenttype clears the value of the "agenttype" field.
func (m *AgenttypeMutation) ClearAgenttype() {
	m.agenttype = nil
	m.clearedFields[agenttype.FieldAgenttype] = struct{}{}
}

// AgenttypeCleared returns if the "agenttype" field was cleared in this mutation.
func (m *AgenttypeMutation) AgenttypeCleared() bool {
	_, ok := m.clearedFields[agenttype.FieldAgenttype]
	return ok
}

// ResetAgenttype resets all changes to the "agenttype" field.
func (m *AgenttypeMutation) ResetAgenttype() {
	m.agenttype = nil
	delete(m.clearedFields, agenttype.FieldAgenttype)
}

// Op returns the operation name.
func (m *AgenttypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Agenttype).
func (m *AgenttypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AgenttypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.agentid != nil {
		fields = append(fields, agenttype.FieldAgentid)
	}
	if m.agentname != nil {
		fields = append(fields, agenttype.FieldAgentname)
	}
	if m.agenttype != nil {
		fields = append(fields, agenttype.FieldAgenttype)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AgenttypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case agenttype.FieldAgentid:
		return m.Agentid()
	case agenttype.FieldAgentname:
		return m.Agentname()
	case agenttype.FieldAgenttype:
		return m.Agenttype()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AgenttypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case agenttype.FieldAgentid:
		return m.OldAgentid(ctx)
	case agenttype.FieldAgentname:
		return m.OldAgentname(ctx)
	case agenttype.FieldAgenttype:
		return m.OldAgenttype(ctx)
	}
	return nil, fmt.Errorf("unknown Agenttype field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgenttypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case agenttype.FieldAgentid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentid(v)
		return nil
	case agenttype.FieldAgentname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentname(v)
		return nil
	case agenttype.FieldAgenttype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgenttype(v)
		return nil
	}
	return fmt.Errorf("unknown Agenttype field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AgenttypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AgenttypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AgenttypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Agenttype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AgenttypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(agenttype.FieldAgentid) {
		fields = append(fields, agenttype.FieldAgentid)
	}
	if m.FieldCleared(agenttype.FieldAgentname) {
		fields = append(fields, agenttype.FieldAgentname)
	}
	if m.FieldCleared(agenttype.FieldAgenttype) {
		fields = append(fields, agenttype.FieldAgenttype)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AgenttypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AgenttypeMutation) ClearField(name string) error {
	switch name {
	case agenttype.FieldAgentid:
		m.ClearAgentid()
		return nil
	case agenttype.FieldAgentname:
		m.ClearAgentname()
		return nil
	case agenttype.FieldAgenttype:
		m.ClearAgenttype()
		return nil
	}
	return fmt.Errorf("unknown Agenttype nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AgenttypeMutation) ResetField(name string) error {
	switch name {
	case agenttype.FieldAgentid:
		m.ResetAgentid()
		return nil
	case agenttype.FieldAgentname:
		m.ResetAgentname()
		return nil
	case agenttype.FieldAgenttype:
		m.ResetAgenttype()
		return nil
	}
	return fmt.Errorf("unknown Agenttype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AgenttypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AgenttypeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AgenttypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AgenttypeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AgenttypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AgenttypeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AgenttypeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Agenttype unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AgenttypeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Agenttype edge %s", name)
}

// AreahistoryMutation represents an operation that mutates the Areahistory nodes in the graph.
type AreahistoryMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_WalletID       *string
	_ProvinceNameTH *string
	_DistrictNameTH *string
	_SubDistrict    *string
	_RankArea       *int
	add_RankArea    *int
	_DateCalRank    *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Areahistory, error)
	predicates      []predicate.Areahistory
}

var _ ent.Mutation = (*AreahistoryMutation)(nil)

// areahistoryOption allows management of the mutation configuration using functional options.
type areahistoryOption func(*AreahistoryMutation)

// newAreahistoryMutation creates new mutation for the Areahistory entity.
func newAreahistoryMutation(c config, op Op, opts ...areahistoryOption) *AreahistoryMutation {
	m := &AreahistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeAreahistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAreahistoryID sets the ID field of the mutation.
func withAreahistoryID(id int) areahistoryOption {
	return func(m *AreahistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Areahistory
		)
		m.oldValue = func(ctx context.Context) (*Areahistory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Areahistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAreahistory sets the old Areahistory of the mutation.
func withAreahistory(node *Areahistory) areahistoryOption {
	return func(m *AreahistoryMutation) {
		m.oldValue = func(context.Context) (*Areahistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AreahistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AreahistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Areahistory entities.
func (m *AreahistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AreahistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *AreahistoryMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *AreahistoryMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *AreahistoryMutation) ResetWalletID() {
	m._WalletID = nil
}

// SetProvinceNameTH sets the "ProvinceNameTH" field.
func (m *AreahistoryMutation) SetProvinceNameTH(s string) {
	m._ProvinceNameTH = &s
}

// ProvinceNameTH returns the value of the "ProvinceNameTH" field in the mutation.
func (m *AreahistoryMutation) ProvinceNameTH() (r string, exists bool) {
	v := m._ProvinceNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceNameTH returns the old "ProvinceNameTH" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldProvinceNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvinceNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvinceNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceNameTH: %w", err)
	}
	return oldValue.ProvinceNameTH, nil
}

// ClearProvinceNameTH clears the value of the "ProvinceNameTH" field.
func (m *AreahistoryMutation) ClearProvinceNameTH() {
	m._ProvinceNameTH = nil
	m.clearedFields[areahistory.FieldProvinceNameTH] = struct{}{}
}

// ProvinceNameTHCleared returns if the "ProvinceNameTH" field was cleared in this mutation.
func (m *AreahistoryMutation) ProvinceNameTHCleared() bool {
	_, ok := m.clearedFields[areahistory.FieldProvinceNameTH]
	return ok
}

// ResetProvinceNameTH resets all changes to the "ProvinceNameTH" field.
func (m *AreahistoryMutation) ResetProvinceNameTH() {
	m._ProvinceNameTH = nil
	delete(m.clearedFields, areahistory.FieldProvinceNameTH)
}

// SetDistrictNameTH sets the "DistrictNameTH" field.
func (m *AreahistoryMutation) SetDistrictNameTH(s string) {
	m._DistrictNameTH = &s
}

// DistrictNameTH returns the value of the "DistrictNameTH" field in the mutation.
func (m *AreahistoryMutation) DistrictNameTH() (r string, exists bool) {
	v := m._DistrictNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictNameTH returns the old "DistrictNameTH" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldDistrictNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictNameTH: %w", err)
	}
	return oldValue.DistrictNameTH, nil
}

// ClearDistrictNameTH clears the value of the "DistrictNameTH" field.
func (m *AreahistoryMutation) ClearDistrictNameTH() {
	m._DistrictNameTH = nil
	m.clearedFields[areahistory.FieldDistrictNameTH] = struct{}{}
}

// DistrictNameTHCleared returns if the "DistrictNameTH" field was cleared in this mutation.
func (m *AreahistoryMutation) DistrictNameTHCleared() bool {
	_, ok := m.clearedFields[areahistory.FieldDistrictNameTH]
	return ok
}

// ResetDistrictNameTH resets all changes to the "DistrictNameTH" field.
func (m *AreahistoryMutation) ResetDistrictNameTH() {
	m._DistrictNameTH = nil
	delete(m.clearedFields, areahistory.FieldDistrictNameTH)
}

// SetSubDistrict sets the "SubDistrict" field.
func (m *AreahistoryMutation) SetSubDistrict(s string) {
	m._SubDistrict = &s
}

// SubDistrict returns the value of the "SubDistrict" field in the mutation.
func (m *AreahistoryMutation) SubDistrict() (r string, exists bool) {
	v := m._SubDistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrict returns the old "SubDistrict" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldSubDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrict: %w", err)
	}
	return oldValue.SubDistrict, nil
}

// ClearSubDistrict clears the value of the "SubDistrict" field.
func (m *AreahistoryMutation) ClearSubDistrict() {
	m._SubDistrict = nil
	m.clearedFields[areahistory.FieldSubDistrict] = struct{}{}
}

// SubDistrictCleared returns if the "SubDistrict" field was cleared in this mutation.
func (m *AreahistoryMutation) SubDistrictCleared() bool {
	_, ok := m.clearedFields[areahistory.FieldSubDistrict]
	return ok
}

// ResetSubDistrict resets all changes to the "SubDistrict" field.
func (m *AreahistoryMutation) ResetSubDistrict() {
	m._SubDistrict = nil
	delete(m.clearedFields, areahistory.FieldSubDistrict)
}

// SetRankArea sets the "RankArea" field.
func (m *AreahistoryMutation) SetRankArea(i int) {
	m._RankArea = &i
	m.add_RankArea = nil
}

// RankArea returns the value of the "RankArea" field in the mutation.
func (m *AreahistoryMutation) RankArea() (r int, exists bool) {
	v := m._RankArea
	if v == nil {
		return
	}
	return *v, true
}

// OldRankArea returns the old "RankArea" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldRankArea(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankArea is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankArea requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankArea: %w", err)
	}
	return oldValue.RankArea, nil
}

// AddRankArea adds i to the "RankArea" field.
func (m *AreahistoryMutation) AddRankArea(i int) {
	if m.add_RankArea != nil {
		*m.add_RankArea += i
	} else {
		m.add_RankArea = &i
	}
}

// AddedRankArea returns the value that was added to the "RankArea" field in this mutation.
func (m *AreahistoryMutation) AddedRankArea() (r int, exists bool) {
	v := m.add_RankArea
	if v == nil {
		return
	}
	return *v, true
}

// ClearRankArea clears the value of the "RankArea" field.
func (m *AreahistoryMutation) ClearRankArea() {
	m._RankArea = nil
	m.add_RankArea = nil
	m.clearedFields[areahistory.FieldRankArea] = struct{}{}
}

// RankAreaCleared returns if the "RankArea" field was cleared in this mutation.
func (m *AreahistoryMutation) RankAreaCleared() bool {
	_, ok := m.clearedFields[areahistory.FieldRankArea]
	return ok
}

// ResetRankArea resets all changes to the "RankArea" field.
func (m *AreahistoryMutation) ResetRankArea() {
	m._RankArea = nil
	m.add_RankArea = nil
	delete(m.clearedFields, areahistory.FieldRankArea)
}

// SetDateCalRank sets the "DateCalRank" field.
func (m *AreahistoryMutation) SetDateCalRank(t time.Time) {
	m._DateCalRank = &t
}

// DateCalRank returns the value of the "DateCalRank" field in the mutation.
func (m *AreahistoryMutation) DateCalRank() (r time.Time, exists bool) {
	v := m._DateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldDateCalRank returns the old "DateCalRank" field's value of the Areahistory entity.
// If the Areahistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AreahistoryMutation) OldDateCalRank(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateCalRank: %w", err)
	}
	return oldValue.DateCalRank, nil
}

// ClearDateCalRank clears the value of the "DateCalRank" field.
func (m *AreahistoryMutation) ClearDateCalRank() {
	m._DateCalRank = nil
	m.clearedFields[areahistory.FieldDateCalRank] = struct{}{}
}

// DateCalRankCleared returns if the "DateCalRank" field was cleared in this mutation.
func (m *AreahistoryMutation) DateCalRankCleared() bool {
	_, ok := m.clearedFields[areahistory.FieldDateCalRank]
	return ok
}

// ResetDateCalRank resets all changes to the "DateCalRank" field.
func (m *AreahistoryMutation) ResetDateCalRank() {
	m._DateCalRank = nil
	delete(m.clearedFields, areahistory.FieldDateCalRank)
}

// Op returns the operation name.
func (m *AreahistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Areahistory).
func (m *AreahistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AreahistoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._WalletID != nil {
		fields = append(fields, areahistory.FieldWalletID)
	}
	if m._ProvinceNameTH != nil {
		fields = append(fields, areahistory.FieldProvinceNameTH)
	}
	if m._DistrictNameTH != nil {
		fields = append(fields, areahistory.FieldDistrictNameTH)
	}
	if m._SubDistrict != nil {
		fields = append(fields, areahistory.FieldSubDistrict)
	}
	if m._RankArea != nil {
		fields = append(fields, areahistory.FieldRankArea)
	}
	if m._DateCalRank != nil {
		fields = append(fields, areahistory.FieldDateCalRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AreahistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case areahistory.FieldWalletID:
		return m.WalletID()
	case areahistory.FieldProvinceNameTH:
		return m.ProvinceNameTH()
	case areahistory.FieldDistrictNameTH:
		return m.DistrictNameTH()
	case areahistory.FieldSubDistrict:
		return m.SubDistrict()
	case areahistory.FieldRankArea:
		return m.RankArea()
	case areahistory.FieldDateCalRank:
		return m.DateCalRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AreahistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case areahistory.FieldWalletID:
		return m.OldWalletID(ctx)
	case areahistory.FieldProvinceNameTH:
		return m.OldProvinceNameTH(ctx)
	case areahistory.FieldDistrictNameTH:
		return m.OldDistrictNameTH(ctx)
	case areahistory.FieldSubDistrict:
		return m.OldSubDistrict(ctx)
	case areahistory.FieldRankArea:
		return m.OldRankArea(ctx)
	case areahistory.FieldDateCalRank:
		return m.OldDateCalRank(ctx)
	}
	return nil, fmt.Errorf("unknown Areahistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreahistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case areahistory.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case areahistory.FieldProvinceNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceNameTH(v)
		return nil
	case areahistory.FieldDistrictNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictNameTH(v)
		return nil
	case areahistory.FieldSubDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrict(v)
		return nil
	case areahistory.FieldRankArea:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankArea(v)
		return nil
	case areahistory.FieldDateCalRank:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateCalRank(v)
		return nil
	}
	return fmt.Errorf("unknown Areahistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AreahistoryMutation) AddedFields() []string {
	var fields []string
	if m.add_RankArea != nil {
		fields = append(fields, areahistory.FieldRankArea)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AreahistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case areahistory.FieldRankArea:
		return m.AddedRankArea()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AreahistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case areahistory.FieldRankArea:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRankArea(v)
		return nil
	}
	return fmt.Errorf("unknown Areahistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AreahistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(areahistory.FieldProvinceNameTH) {
		fields = append(fields, areahistory.FieldProvinceNameTH)
	}
	if m.FieldCleared(areahistory.FieldDistrictNameTH) {
		fields = append(fields, areahistory.FieldDistrictNameTH)
	}
	if m.FieldCleared(areahistory.FieldSubDistrict) {
		fields = append(fields, areahistory.FieldSubDistrict)
	}
	if m.FieldCleared(areahistory.FieldRankArea) {
		fields = append(fields, areahistory.FieldRankArea)
	}
	if m.FieldCleared(areahistory.FieldDateCalRank) {
		fields = append(fields, areahistory.FieldDateCalRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AreahistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AreahistoryMutation) ClearField(name string) error {
	switch name {
	case areahistory.FieldProvinceNameTH:
		m.ClearProvinceNameTH()
		return nil
	case areahistory.FieldDistrictNameTH:
		m.ClearDistrictNameTH()
		return nil
	case areahistory.FieldSubDistrict:
		m.ClearSubDistrict()
		return nil
	case areahistory.FieldRankArea:
		m.ClearRankArea()
		return nil
	case areahistory.FieldDateCalRank:
		m.ClearDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Areahistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AreahistoryMutation) ResetField(name string) error {
	switch name {
	case areahistory.FieldWalletID:
		m.ResetWalletID()
		return nil
	case areahistory.FieldProvinceNameTH:
		m.ResetProvinceNameTH()
		return nil
	case areahistory.FieldDistrictNameTH:
		m.ResetDistrictNameTH()
		return nil
	case areahistory.FieldSubDistrict:
		m.ResetSubDistrict()
		return nil
	case areahistory.FieldRankArea:
		m.ResetRankArea()
		return nil
	case areahistory.FieldDateCalRank:
		m.ResetDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Areahistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AreahistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AreahistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AreahistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AreahistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AreahistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AreahistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AreahistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Areahistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AreahistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Areahistory edge %s", name)
}

// BankdetailMutation represents an operation that mutates the Bankdetail nodes in the graph.
type BankdetailMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Bank_AccountNo   *string
	_Bank_Name        *string
	_Bank_AccountName *string
	clearedFields     map[string]struct{}
	statements        map[int]struct{}
	removedstatements map[int]struct{}
	clearedstatements bool
	done              bool
	oldValue          func(context.Context) (*Bankdetail, error)
	predicates        []predicate.Bankdetail
}

var _ ent.Mutation = (*BankdetailMutation)(nil)

// bankdetailOption allows management of the mutation configuration using functional options.
type bankdetailOption func(*BankdetailMutation)

// newBankdetailMutation creates new mutation for the Bankdetail entity.
func newBankdetailMutation(c config, op Op, opts ...bankdetailOption) *BankdetailMutation {
	m := &BankdetailMutation{
		config:        c,
		op:            op,
		typ:           TypeBankdetail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBankdetailID sets the ID field of the mutation.
func withBankdetailID(id int) bankdetailOption {
	return func(m *BankdetailMutation) {
		var (
			err   error
			once  sync.Once
			value *Bankdetail
		)
		m.oldValue = func(ctx context.Context) (*Bankdetail, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bankdetail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBankdetail sets the old Bankdetail of the mutation.
func withBankdetail(node *Bankdetail) bankdetailOption {
	return func(m *BankdetailMutation) {
		m.oldValue = func(context.Context) (*Bankdetail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BankdetailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BankdetailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bankdetail entities.
func (m *BankdetailMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BankdetailMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBankAccountNo sets the "Bank_AccountNo" field.
func (m *BankdetailMutation) SetBankAccountNo(s string) {
	m._Bank_AccountNo = &s
}

// BankAccountNo returns the value of the "Bank_AccountNo" field in the mutation.
func (m *BankdetailMutation) BankAccountNo() (r string, exists bool) {
	v := m._Bank_AccountNo
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountNo returns the old "Bank_AccountNo" field's value of the Bankdetail entity.
// If the Bankdetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankdetailMutation) OldBankAccountNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountNo: %w", err)
	}
	return oldValue.BankAccountNo, nil
}

// ClearBankAccountNo clears the value of the "Bank_AccountNo" field.
func (m *BankdetailMutation) ClearBankAccountNo() {
	m._Bank_AccountNo = nil
	m.clearedFields[bankdetail.FieldBankAccountNo] = struct{}{}
}

// BankAccountNoCleared returns if the "Bank_AccountNo" field was cleared in this mutation.
func (m *BankdetailMutation) BankAccountNoCleared() bool {
	_, ok := m.clearedFields[bankdetail.FieldBankAccountNo]
	return ok
}

// ResetBankAccountNo resets all changes to the "Bank_AccountNo" field.
func (m *BankdetailMutation) ResetBankAccountNo() {
	m._Bank_AccountNo = nil
	delete(m.clearedFields, bankdetail.FieldBankAccountNo)
}

// SetBankName sets the "Bank_Name" field.
func (m *BankdetailMutation) SetBankName(s string) {
	m._Bank_Name = &s
}

// BankName returns the value of the "Bank_Name" field in the mutation.
func (m *BankdetailMutation) BankName() (r string, exists bool) {
	v := m._Bank_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldBankName returns the old "Bank_Name" field's value of the Bankdetail entity.
// If the Bankdetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankdetailMutation) OldBankName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankName: %w", err)
	}
	return oldValue.BankName, nil
}

// ClearBankName clears the value of the "Bank_Name" field.
func (m *BankdetailMutation) ClearBankName() {
	m._Bank_Name = nil
	m.clearedFields[bankdetail.FieldBankName] = struct{}{}
}

// BankNameCleared returns if the "Bank_Name" field was cleared in this mutation.
func (m *BankdetailMutation) BankNameCleared() bool {
	_, ok := m.clearedFields[bankdetail.FieldBankName]
	return ok
}

// ResetBankName resets all changes to the "Bank_Name" field.
func (m *BankdetailMutation) ResetBankName() {
	m._Bank_Name = nil
	delete(m.clearedFields, bankdetail.FieldBankName)
}

// SetBankAccountName sets the "Bank_AccountName" field.
func (m *BankdetailMutation) SetBankAccountName(s string) {
	m._Bank_AccountName = &s
}

// BankAccountName returns the value of the "Bank_AccountName" field in the mutation.
func (m *BankdetailMutation) BankAccountName() (r string, exists bool) {
	v := m._Bank_AccountName
	if v == nil {
		return
	}
	return *v, true
}

// OldBankAccountName returns the old "Bank_AccountName" field's value of the Bankdetail entity.
// If the Bankdetail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BankdetailMutation) OldBankAccountName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankAccountName: %w", err)
	}
	return oldValue.BankAccountName, nil
}

// ClearBankAccountName clears the value of the "Bank_AccountName" field.
func (m *BankdetailMutation) ClearBankAccountName() {
	m._Bank_AccountName = nil
	m.clearedFields[bankdetail.FieldBankAccountName] = struct{}{}
}

// BankAccountNameCleared returns if the "Bank_AccountName" field was cleared in this mutation.
func (m *BankdetailMutation) BankAccountNameCleared() bool {
	_, ok := m.clearedFields[bankdetail.FieldBankAccountName]
	return ok
}

// ResetBankAccountName resets all changes to the "Bank_AccountName" field.
func (m *BankdetailMutation) ResetBankAccountName() {
	m._Bank_AccountName = nil
	delete(m.clearedFields, bankdetail.FieldBankAccountName)
}

// AddStatementIDs adds the "statements" edge to the StatementEndingBalanc entity by ids.
func (m *BankdetailMutation) AddStatementIDs(ids ...int) {
	if m.statements == nil {
		m.statements = make(map[int]struct{})
	}
	for i := range ids {
		m.statements[ids[i]] = struct{}{}
	}
}

// ClearStatements clears the "statements" edge to the StatementEndingBalanc entity.
func (m *BankdetailMutation) ClearStatements() {
	m.clearedstatements = true
}

// StatementsCleared returns if the "statements" edge to the StatementEndingBalanc entity was cleared.
func (m *BankdetailMutation) StatementsCleared() bool {
	return m.clearedstatements
}

// RemoveStatementIDs removes the "statements" edge to the StatementEndingBalanc entity by IDs.
func (m *BankdetailMutation) RemoveStatementIDs(ids ...int) {
	if m.removedstatements == nil {
		m.removedstatements = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatements[ids[i]] = struct{}{}
	}
}

// RemovedStatements returns the removed IDs of the "statements" edge to the StatementEndingBalanc entity.
func (m *BankdetailMutation) RemovedStatementsIDs() (ids []int) {
	for id := range m.removedstatements {
		ids = append(ids, id)
	}
	return
}

// StatementsIDs returns the "statements" edge IDs in the mutation.
func (m *BankdetailMutation) StatementsIDs() (ids []int) {
	for id := range m.statements {
		ids = append(ids, id)
	}
	return
}

// ResetStatements resets all changes to the "statements" edge.
func (m *BankdetailMutation) ResetStatements() {
	m.statements = nil
	m.clearedstatements = false
	m.removedstatements = nil
}

// Op returns the operation name.
func (m *BankdetailMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bankdetail).
func (m *BankdetailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BankdetailMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Bank_AccountNo != nil {
		fields = append(fields, bankdetail.FieldBankAccountNo)
	}
	if m._Bank_Name != nil {
		fields = append(fields, bankdetail.FieldBankName)
	}
	if m._Bank_AccountName != nil {
		fields = append(fields, bankdetail.FieldBankAccountName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BankdetailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bankdetail.FieldBankAccountNo:
		return m.BankAccountNo()
	case bankdetail.FieldBankName:
		return m.BankName()
	case bankdetail.FieldBankAccountName:
		return m.BankAccountName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BankdetailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bankdetail.FieldBankAccountNo:
		return m.OldBankAccountNo(ctx)
	case bankdetail.FieldBankName:
		return m.OldBankName(ctx)
	case bankdetail.FieldBankAccountName:
		return m.OldBankAccountName(ctx)
	}
	return nil, fmt.Errorf("unknown Bankdetail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankdetailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bankdetail.FieldBankAccountNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountNo(v)
		return nil
	case bankdetail.FieldBankName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankName(v)
		return nil
	case bankdetail.FieldBankAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankAccountName(v)
		return nil
	}
	return fmt.Errorf("unknown Bankdetail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BankdetailMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BankdetailMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BankdetailMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bankdetail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BankdetailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bankdetail.FieldBankAccountNo) {
		fields = append(fields, bankdetail.FieldBankAccountNo)
	}
	if m.FieldCleared(bankdetail.FieldBankName) {
		fields = append(fields, bankdetail.FieldBankName)
	}
	if m.FieldCleared(bankdetail.FieldBankAccountName) {
		fields = append(fields, bankdetail.FieldBankAccountName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BankdetailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BankdetailMutation) ClearField(name string) error {
	switch name {
	case bankdetail.FieldBankAccountNo:
		m.ClearBankAccountNo()
		return nil
	case bankdetail.FieldBankName:
		m.ClearBankName()
		return nil
	case bankdetail.FieldBankAccountName:
		m.ClearBankAccountName()
		return nil
	}
	return fmt.Errorf("unknown Bankdetail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BankdetailMutation) ResetField(name string) error {
	switch name {
	case bankdetail.FieldBankAccountNo:
		m.ResetBankAccountNo()
		return nil
	case bankdetail.FieldBankName:
		m.ResetBankName()
		return nil
	case bankdetail.FieldBankAccountName:
		m.ResetBankAccountName()
		return nil
	}
	return fmt.Errorf("unknown Bankdetail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BankdetailMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statements != nil {
		edges = append(edges, bankdetail.EdgeStatements)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BankdetailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bankdetail.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.statements))
		for id := range m.statements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BankdetailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatements != nil {
		edges = append(edges, bankdetail.EdgeStatements)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BankdetailMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bankdetail.EdgeStatements:
		ids := make([]ent.Value, 0, len(m.removedstatements))
		for id := range m.removedstatements {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BankdetailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedstatements {
		edges = append(edges, bankdetail.EdgeStatements)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BankdetailMutation) EdgeCleared(name string) bool {
	switch name {
	case bankdetail.EdgeStatements:
		return m.clearedstatements
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BankdetailMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bankdetail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BankdetailMutation) ResetEdge(name string) error {
	switch name {
	case bankdetail.EdgeStatements:
		m.ResetStatements()
		return nil
	}
	return fmt.Errorf("unknown Bankdetail edge %s", name)
}

// BulkMutation represents an operation that mutates the Bulk nodes in the graph.
type BulkMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	bulkCreditSameday        *float64
	addbulkCreditSameday     *float64
	bulkCreditSamedayFee     *float64
	addbulkCreditSamedayFee  *float64
	transfertobankaccount    *float64
	addtransfertobankaccount *float64
	dateTime                 *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Bulk, error)
	predicates               []predicate.Bulk
}

var _ ent.Mutation = (*BulkMutation)(nil)

// bulkOption allows management of the mutation configuration using functional options.
type bulkOption func(*BulkMutation)

// newBulkMutation creates new mutation for the Bulk entity.
func newBulkMutation(c config, op Op, opts ...bulkOption) *BulkMutation {
	m := &BulkMutation{
		config:        c,
		op:            op,
		typ:           TypeBulk,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBulkID sets the ID field of the mutation.
func withBulkID(id int) bulkOption {
	return func(m *BulkMutation) {
		var (
			err   error
			once  sync.Once
			value *Bulk
		)
		m.oldValue = func(ctx context.Context) (*Bulk, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bulk.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBulk sets the old Bulk of the mutation.
func withBulk(node *Bulk) bulkOption {
	return func(m *BulkMutation) {
		m.oldValue = func(context.Context) (*Bulk, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BulkMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BulkMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Bulk entities.
func (m *BulkMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *BulkMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBulkCreditSameday sets the "bulkCreditSameday" field.
func (m *BulkMutation) SetBulkCreditSameday(f float64) {
	m.bulkCreditSameday = &f
	m.addbulkCreditSameday = nil
}

// BulkCreditSameday returns the value of the "bulkCreditSameday" field in the mutation.
func (m *BulkMutation) BulkCreditSameday() (r float64, exists bool) {
	v := m.bulkCreditSameday
	if v == nil {
		return
	}
	return *v, true
}

// OldBulkCreditSameday returns the old "bulkCreditSameday" field's value of the Bulk entity.
// If the Bulk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BulkMutation) OldBulkCreditSameday(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBulkCreditSameday is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBulkCreditSameday requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulkCreditSameday: %w", err)
	}
	return oldValue.BulkCreditSameday, nil
}

// AddBulkCreditSameday adds f to the "bulkCreditSameday" field.
func (m *BulkMutation) AddBulkCreditSameday(f float64) {
	if m.addbulkCreditSameday != nil {
		*m.addbulkCreditSameday += f
	} else {
		m.addbulkCreditSameday = &f
	}
}

// AddedBulkCreditSameday returns the value that was added to the "bulkCreditSameday" field in this mutation.
func (m *BulkMutation) AddedBulkCreditSameday() (r float64, exists bool) {
	v := m.addbulkCreditSameday
	if v == nil {
		return
	}
	return *v, true
}

// ClearBulkCreditSameday clears the value of the "bulkCreditSameday" field.
func (m *BulkMutation) ClearBulkCreditSameday() {
	m.bulkCreditSameday = nil
	m.addbulkCreditSameday = nil
	m.clearedFields[bulk.FieldBulkCreditSameday] = struct{}{}
}

// BulkCreditSamedayCleared returns if the "bulkCreditSameday" field was cleared in this mutation.
func (m *BulkMutation) BulkCreditSamedayCleared() bool {
	_, ok := m.clearedFields[bulk.FieldBulkCreditSameday]
	return ok
}

// ResetBulkCreditSameday resets all changes to the "bulkCreditSameday" field.
func (m *BulkMutation) ResetBulkCreditSameday() {
	m.bulkCreditSameday = nil
	m.addbulkCreditSameday = nil
	delete(m.clearedFields, bulk.FieldBulkCreditSameday)
}

// SetBulkCreditSamedayFee sets the "bulkCreditSamedayFee" field.
func (m *BulkMutation) SetBulkCreditSamedayFee(f float64) {
	m.bulkCreditSamedayFee = &f
	m.addbulkCreditSamedayFee = nil
}

// BulkCreditSamedayFee returns the value of the "bulkCreditSamedayFee" field in the mutation.
func (m *BulkMutation) BulkCreditSamedayFee() (r float64, exists bool) {
	v := m.bulkCreditSamedayFee
	if v == nil {
		return
	}
	return *v, true
}

// OldBulkCreditSamedayFee returns the old "bulkCreditSamedayFee" field's value of the Bulk entity.
// If the Bulk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BulkMutation) OldBulkCreditSamedayFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBulkCreditSamedayFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBulkCreditSamedayFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBulkCreditSamedayFee: %w", err)
	}
	return oldValue.BulkCreditSamedayFee, nil
}

// AddBulkCreditSamedayFee adds f to the "bulkCreditSamedayFee" field.
func (m *BulkMutation) AddBulkCreditSamedayFee(f float64) {
	if m.addbulkCreditSamedayFee != nil {
		*m.addbulkCreditSamedayFee += f
	} else {
		m.addbulkCreditSamedayFee = &f
	}
}

// AddedBulkCreditSamedayFee returns the value that was added to the "bulkCreditSamedayFee" field in this mutation.
func (m *BulkMutation) AddedBulkCreditSamedayFee() (r float64, exists bool) {
	v := m.addbulkCreditSamedayFee
	if v == nil {
		return
	}
	return *v, true
}

// ClearBulkCreditSamedayFee clears the value of the "bulkCreditSamedayFee" field.
func (m *BulkMutation) ClearBulkCreditSamedayFee() {
	m.bulkCreditSamedayFee = nil
	m.addbulkCreditSamedayFee = nil
	m.clearedFields[bulk.FieldBulkCreditSamedayFee] = struct{}{}
}

// BulkCreditSamedayFeeCleared returns if the "bulkCreditSamedayFee" field was cleared in this mutation.
func (m *BulkMutation) BulkCreditSamedayFeeCleared() bool {
	_, ok := m.clearedFields[bulk.FieldBulkCreditSamedayFee]
	return ok
}

// ResetBulkCreditSamedayFee resets all changes to the "bulkCreditSamedayFee" field.
func (m *BulkMutation) ResetBulkCreditSamedayFee() {
	m.bulkCreditSamedayFee = nil
	m.addbulkCreditSamedayFee = nil
	delete(m.clearedFields, bulk.FieldBulkCreditSamedayFee)
}

// SetTransfertobankaccount sets the "transfertobankaccount" field.
func (m *BulkMutation) SetTransfertobankaccount(f float64) {
	m.transfertobankaccount = &f
	m.addtransfertobankaccount = nil
}

// Transfertobankaccount returns the value of the "transfertobankaccount" field in the mutation.
func (m *BulkMutation) Transfertobankaccount() (r float64, exists bool) {
	v := m.transfertobankaccount
	if v == nil {
		return
	}
	return *v, true
}

// OldTransfertobankaccount returns the old "transfertobankaccount" field's value of the Bulk entity.
// If the Bulk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BulkMutation) OldTransfertobankaccount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransfertobankaccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransfertobankaccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransfertobankaccount: %w", err)
	}
	return oldValue.Transfertobankaccount, nil
}

// AddTransfertobankaccount adds f to the "transfertobankaccount" field.
func (m *BulkMutation) AddTransfertobankaccount(f float64) {
	if m.addtransfertobankaccount != nil {
		*m.addtransfertobankaccount += f
	} else {
		m.addtransfertobankaccount = &f
	}
}

// AddedTransfertobankaccount returns the value that was added to the "transfertobankaccount" field in this mutation.
func (m *BulkMutation) AddedTransfertobankaccount() (r float64, exists bool) {
	v := m.addtransfertobankaccount
	if v == nil {
		return
	}
	return *v, true
}

// ClearTransfertobankaccount clears the value of the "transfertobankaccount" field.
func (m *BulkMutation) ClearTransfertobankaccount() {
	m.transfertobankaccount = nil
	m.addtransfertobankaccount = nil
	m.clearedFields[bulk.FieldTransfertobankaccount] = struct{}{}
}

// TransfertobankaccountCleared returns if the "transfertobankaccount" field was cleared in this mutation.
func (m *BulkMutation) TransfertobankaccountCleared() bool {
	_, ok := m.clearedFields[bulk.FieldTransfertobankaccount]
	return ok
}

// ResetTransfertobankaccount resets all changes to the "transfertobankaccount" field.
func (m *BulkMutation) ResetTransfertobankaccount() {
	m.transfertobankaccount = nil
	m.addtransfertobankaccount = nil
	delete(m.clearedFields, bulk.FieldTransfertobankaccount)
}

// SetDateTime sets the "dateTime" field.
func (m *BulkMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *BulkMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the Bulk entity.
// If the Bulk object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BulkMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *BulkMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[bulk.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *BulkMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[bulk.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *BulkMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, bulk.FieldDateTime)
}

// Op returns the operation name.
func (m *BulkMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bulk).
func (m *BulkMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BulkMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.bulkCreditSameday != nil {
		fields = append(fields, bulk.FieldBulkCreditSameday)
	}
	if m.bulkCreditSamedayFee != nil {
		fields = append(fields, bulk.FieldBulkCreditSamedayFee)
	}
	if m.transfertobankaccount != nil {
		fields = append(fields, bulk.FieldTransfertobankaccount)
	}
	if m.dateTime != nil {
		fields = append(fields, bulk.FieldDateTime)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BulkMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bulk.FieldBulkCreditSameday:
		return m.BulkCreditSameday()
	case bulk.FieldBulkCreditSamedayFee:
		return m.BulkCreditSamedayFee()
	case bulk.FieldTransfertobankaccount:
		return m.Transfertobankaccount()
	case bulk.FieldDateTime:
		return m.DateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BulkMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bulk.FieldBulkCreditSameday:
		return m.OldBulkCreditSameday(ctx)
	case bulk.FieldBulkCreditSamedayFee:
		return m.OldBulkCreditSamedayFee(ctx)
	case bulk.FieldTransfertobankaccount:
		return m.OldTransfertobankaccount(ctx)
	case bulk.FieldDateTime:
		return m.OldDateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Bulk field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BulkMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bulk.FieldBulkCreditSameday:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulkCreditSameday(v)
		return nil
	case bulk.FieldBulkCreditSamedayFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBulkCreditSamedayFee(v)
		return nil
	case bulk.FieldTransfertobankaccount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransfertobankaccount(v)
		return nil
	case bulk.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Bulk field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BulkMutation) AddedFields() []string {
	var fields []string
	if m.addbulkCreditSameday != nil {
		fields = append(fields, bulk.FieldBulkCreditSameday)
	}
	if m.addbulkCreditSamedayFee != nil {
		fields = append(fields, bulk.FieldBulkCreditSamedayFee)
	}
	if m.addtransfertobankaccount != nil {
		fields = append(fields, bulk.FieldTransfertobankaccount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BulkMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case bulk.FieldBulkCreditSameday:
		return m.AddedBulkCreditSameday()
	case bulk.FieldBulkCreditSamedayFee:
		return m.AddedBulkCreditSamedayFee()
	case bulk.FieldTransfertobankaccount:
		return m.AddedTransfertobankaccount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BulkMutation) AddField(name string, value ent.Value) error {
	switch name {
	case bulk.FieldBulkCreditSameday:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBulkCreditSameday(v)
		return nil
	case bulk.FieldBulkCreditSamedayFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBulkCreditSamedayFee(v)
		return nil
	case bulk.FieldTransfertobankaccount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransfertobankaccount(v)
		return nil
	}
	return fmt.Errorf("unknown Bulk numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BulkMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(bulk.FieldBulkCreditSameday) {
		fields = append(fields, bulk.FieldBulkCreditSameday)
	}
	if m.FieldCleared(bulk.FieldBulkCreditSamedayFee) {
		fields = append(fields, bulk.FieldBulkCreditSamedayFee)
	}
	if m.FieldCleared(bulk.FieldTransfertobankaccount) {
		fields = append(fields, bulk.FieldTransfertobankaccount)
	}
	if m.FieldCleared(bulk.FieldDateTime) {
		fields = append(fields, bulk.FieldDateTime)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BulkMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BulkMutation) ClearField(name string) error {
	switch name {
	case bulk.FieldBulkCreditSameday:
		m.ClearBulkCreditSameday()
		return nil
	case bulk.FieldBulkCreditSamedayFee:
		m.ClearBulkCreditSamedayFee()
		return nil
	case bulk.FieldTransfertobankaccount:
		m.ClearTransfertobankaccount()
		return nil
	case bulk.FieldDateTime:
		m.ClearDateTime()
		return nil
	}
	return fmt.Errorf("unknown Bulk nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BulkMutation) ResetField(name string) error {
	switch name {
	case bulk.FieldBulkCreditSameday:
		m.ResetBulkCreditSameday()
		return nil
	case bulk.FieldBulkCreditSamedayFee:
		m.ResetBulkCreditSamedayFee()
		return nil
	case bulk.FieldTransfertobankaccount:
		m.ResetTransfertobankaccount()
		return nil
	case bulk.FieldDateTime:
		m.ResetDateTime()
		return nil
	}
	return fmt.Errorf("unknown Bulk field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BulkMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BulkMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BulkMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BulkMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BulkMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BulkMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BulkMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Bulk unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BulkMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Bulk edge %s", name)
}

// ConfigareaMutation represents an operation that mutates the Configarea nodes in the graph.
type ConfigareaMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_ProvinceID        *int
	add_ProvinceID     *int
	_ProvinceNameTH    *string
	_DistrictID        *int
	add_DistrictID     *int
	_DistrictNameTH    *string
	_DistrictNameEN    *string
	_Rank              *string
	_RankTmp           *string
	_UpdateDate        *time.Time
	_ZipCode           *string
	_SubDistrictNameTH *string
	_ApproveBy         *string
	_ApproveDate       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Configarea, error)
	predicates         []predicate.Configarea
}

var _ ent.Mutation = (*ConfigareaMutation)(nil)

// configareaOption allows management of the mutation configuration using functional options.
type configareaOption func(*ConfigareaMutation)

// newConfigareaMutation creates new mutation for the Configarea entity.
func newConfigareaMutation(c config, op Op, opts ...configareaOption) *ConfigareaMutation {
	m := &ConfigareaMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigarea,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigareaID sets the ID field of the mutation.
func withConfigareaID(id int) configareaOption {
	return func(m *ConfigareaMutation) {
		var (
			err   error
			once  sync.Once
			value *Configarea
		)
		m.oldValue = func(ctx context.Context) (*Configarea, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configarea.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigarea sets the old Configarea of the mutation.
func withConfigarea(node *Configarea) configareaOption {
	return func(m *ConfigareaMutation) {
		m.oldValue = func(context.Context) (*Configarea, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigareaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigareaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configarea entities.
func (m *ConfigareaMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConfigareaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetProvinceID sets the "ProvinceID" field.
func (m *ConfigareaMutation) SetProvinceID(i int) {
	m._ProvinceID = &i
	m.add_ProvinceID = nil
}

// ProvinceID returns the value of the "ProvinceID" field in the mutation.
func (m *ConfigareaMutation) ProvinceID() (r int, exists bool) {
	v := m._ProvinceID
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceID returns the old "ProvinceID" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldProvinceID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvinceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvinceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceID: %w", err)
	}
	return oldValue.ProvinceID, nil
}

// AddProvinceID adds i to the "ProvinceID" field.
func (m *ConfigareaMutation) AddProvinceID(i int) {
	if m.add_ProvinceID != nil {
		*m.add_ProvinceID += i
	} else {
		m.add_ProvinceID = &i
	}
}

// AddedProvinceID returns the value that was added to the "ProvinceID" field in this mutation.
func (m *ConfigareaMutation) AddedProvinceID() (r int, exists bool) {
	v := m.add_ProvinceID
	if v == nil {
		return
	}
	return *v, true
}

// ClearProvinceID clears the value of the "ProvinceID" field.
func (m *ConfigareaMutation) ClearProvinceID() {
	m._ProvinceID = nil
	m.add_ProvinceID = nil
	m.clearedFields[configarea.FieldProvinceID] = struct{}{}
}

// ProvinceIDCleared returns if the "ProvinceID" field was cleared in this mutation.
func (m *ConfigareaMutation) ProvinceIDCleared() bool {
	_, ok := m.clearedFields[configarea.FieldProvinceID]
	return ok
}

// ResetProvinceID resets all changes to the "ProvinceID" field.
func (m *ConfigareaMutation) ResetProvinceID() {
	m._ProvinceID = nil
	m.add_ProvinceID = nil
	delete(m.clearedFields, configarea.FieldProvinceID)
}

// SetProvinceNameTH sets the "ProvinceNameTH" field.
func (m *ConfigareaMutation) SetProvinceNameTH(s string) {
	m._ProvinceNameTH = &s
}

// ProvinceNameTH returns the value of the "ProvinceNameTH" field in the mutation.
func (m *ConfigareaMutation) ProvinceNameTH() (r string, exists bool) {
	v := m._ProvinceNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceNameTH returns the old "ProvinceNameTH" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldProvinceNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvinceNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvinceNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceNameTH: %w", err)
	}
	return oldValue.ProvinceNameTH, nil
}

// ClearProvinceNameTH clears the value of the "ProvinceNameTH" field.
func (m *ConfigareaMutation) ClearProvinceNameTH() {
	m._ProvinceNameTH = nil
	m.clearedFields[configarea.FieldProvinceNameTH] = struct{}{}
}

// ProvinceNameTHCleared returns if the "ProvinceNameTH" field was cleared in this mutation.
func (m *ConfigareaMutation) ProvinceNameTHCleared() bool {
	_, ok := m.clearedFields[configarea.FieldProvinceNameTH]
	return ok
}

// ResetProvinceNameTH resets all changes to the "ProvinceNameTH" field.
func (m *ConfigareaMutation) ResetProvinceNameTH() {
	m._ProvinceNameTH = nil
	delete(m.clearedFields, configarea.FieldProvinceNameTH)
}

// SetDistrictID sets the "DistrictID" field.
func (m *ConfigareaMutation) SetDistrictID(i int) {
	m._DistrictID = &i
	m.add_DistrictID = nil
}

// DistrictID returns the value of the "DistrictID" field in the mutation.
func (m *ConfigareaMutation) DistrictID() (r int, exists bool) {
	v := m._DistrictID
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictID returns the old "DistrictID" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldDistrictID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictID: %w", err)
	}
	return oldValue.DistrictID, nil
}

// AddDistrictID adds i to the "DistrictID" field.
func (m *ConfigareaMutation) AddDistrictID(i int) {
	if m.add_DistrictID != nil {
		*m.add_DistrictID += i
	} else {
		m.add_DistrictID = &i
	}
}

// AddedDistrictID returns the value that was added to the "DistrictID" field in this mutation.
func (m *ConfigareaMutation) AddedDistrictID() (r int, exists bool) {
	v := m.add_DistrictID
	if v == nil {
		return
	}
	return *v, true
}

// ClearDistrictID clears the value of the "DistrictID" field.
func (m *ConfigareaMutation) ClearDistrictID() {
	m._DistrictID = nil
	m.add_DistrictID = nil
	m.clearedFields[configarea.FieldDistrictID] = struct{}{}
}

// DistrictIDCleared returns if the "DistrictID" field was cleared in this mutation.
func (m *ConfigareaMutation) DistrictIDCleared() bool {
	_, ok := m.clearedFields[configarea.FieldDistrictID]
	return ok
}

// ResetDistrictID resets all changes to the "DistrictID" field.
func (m *ConfigareaMutation) ResetDistrictID() {
	m._DistrictID = nil
	m.add_DistrictID = nil
	delete(m.clearedFields, configarea.FieldDistrictID)
}

// SetDistrictNameTH sets the "DistrictNameTH" field.
func (m *ConfigareaMutation) SetDistrictNameTH(s string) {
	m._DistrictNameTH = &s
}

// DistrictNameTH returns the value of the "DistrictNameTH" field in the mutation.
func (m *ConfigareaMutation) DistrictNameTH() (r string, exists bool) {
	v := m._DistrictNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictNameTH returns the old "DistrictNameTH" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldDistrictNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictNameTH: %w", err)
	}
	return oldValue.DistrictNameTH, nil
}

// ClearDistrictNameTH clears the value of the "DistrictNameTH" field.
func (m *ConfigareaMutation) ClearDistrictNameTH() {
	m._DistrictNameTH = nil
	m.clearedFields[configarea.FieldDistrictNameTH] = struct{}{}
}

// DistrictNameTHCleared returns if the "DistrictNameTH" field was cleared in this mutation.
func (m *ConfigareaMutation) DistrictNameTHCleared() bool {
	_, ok := m.clearedFields[configarea.FieldDistrictNameTH]
	return ok
}

// ResetDistrictNameTH resets all changes to the "DistrictNameTH" field.
func (m *ConfigareaMutation) ResetDistrictNameTH() {
	m._DistrictNameTH = nil
	delete(m.clearedFields, configarea.FieldDistrictNameTH)
}

// SetDistrictNameEN sets the "DistrictNameEN" field.
func (m *ConfigareaMutation) SetDistrictNameEN(s string) {
	m._DistrictNameEN = &s
}

// DistrictNameEN returns the value of the "DistrictNameEN" field in the mutation.
func (m *ConfigareaMutation) DistrictNameEN() (r string, exists bool) {
	v := m._DistrictNameEN
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictNameEN returns the old "DistrictNameEN" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldDistrictNameEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictNameEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictNameEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictNameEN: %w", err)
	}
	return oldValue.DistrictNameEN, nil
}

// ClearDistrictNameEN clears the value of the "DistrictNameEN" field.
func (m *ConfigareaMutation) ClearDistrictNameEN() {
	m._DistrictNameEN = nil
	m.clearedFields[configarea.FieldDistrictNameEN] = struct{}{}
}

// DistrictNameENCleared returns if the "DistrictNameEN" field was cleared in this mutation.
func (m *ConfigareaMutation) DistrictNameENCleared() bool {
	_, ok := m.clearedFields[configarea.FieldDistrictNameEN]
	return ok
}

// ResetDistrictNameEN resets all changes to the "DistrictNameEN" field.
func (m *ConfigareaMutation) ResetDistrictNameEN() {
	m._DistrictNameEN = nil
	delete(m.clearedFields, configarea.FieldDistrictNameEN)
}

// SetRank sets the "Rank" field.
func (m *ConfigareaMutation) SetRank(s string) {
	m._Rank = &s
}

// Rank returns the value of the "Rank" field in the mutation.
func (m *ConfigareaMutation) Rank() (r string, exists bool) {
	v := m._Rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "Rank" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldRank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// ClearRank clears the value of the "Rank" field.
func (m *ConfigareaMutation) ClearRank() {
	m._Rank = nil
	m.clearedFields[configarea.FieldRank] = struct{}{}
}

// RankCleared returns if the "Rank" field was cleared in this mutation.
func (m *ConfigareaMutation) RankCleared() bool {
	_, ok := m.clearedFields[configarea.FieldRank]
	return ok
}

// ResetRank resets all changes to the "Rank" field.
func (m *ConfigareaMutation) ResetRank() {
	m._Rank = nil
	delete(m.clearedFields, configarea.FieldRank)
}

// SetRankTmp sets the "RankTmp" field.
func (m *ConfigareaMutation) SetRankTmp(s string) {
	m._RankTmp = &s
}

// RankTmp returns the value of the "RankTmp" field in the mutation.
func (m *ConfigareaMutation) RankTmp() (r string, exists bool) {
	v := m._RankTmp
	if v == nil {
		return
	}
	return *v, true
}

// OldRankTmp returns the old "RankTmp" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldRankTmp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankTmp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankTmp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankTmp: %w", err)
	}
	return oldValue.RankTmp, nil
}

// ClearRankTmp clears the value of the "RankTmp" field.
func (m *ConfigareaMutation) ClearRankTmp() {
	m._RankTmp = nil
	m.clearedFields[configarea.FieldRankTmp] = struct{}{}
}

// RankTmpCleared returns if the "RankTmp" field was cleared in this mutation.
func (m *ConfigareaMutation) RankTmpCleared() bool {
	_, ok := m.clearedFields[configarea.FieldRankTmp]
	return ok
}

// ResetRankTmp resets all changes to the "RankTmp" field.
func (m *ConfigareaMutation) ResetRankTmp() {
	m._RankTmp = nil
	delete(m.clearedFields, configarea.FieldRankTmp)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *ConfigareaMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *ConfigareaMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldUpdateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *ConfigareaMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[configarea.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *ConfigareaMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[configarea.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *ConfigareaMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, configarea.FieldUpdateDate)
}

// SetZipCode sets the "ZipCode" field.
func (m *ConfigareaMutation) SetZipCode(s string) {
	m._ZipCode = &s
}

// ZipCode returns the value of the "ZipCode" field in the mutation.
func (m *ConfigareaMutation) ZipCode() (r string, exists bool) {
	v := m._ZipCode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "ZipCode" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldZipCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ClearZipCode clears the value of the "ZipCode" field.
func (m *ConfigareaMutation) ClearZipCode() {
	m._ZipCode = nil
	m.clearedFields[configarea.FieldZipCode] = struct{}{}
}

// ZipCodeCleared returns if the "ZipCode" field was cleared in this mutation.
func (m *ConfigareaMutation) ZipCodeCleared() bool {
	_, ok := m.clearedFields[configarea.FieldZipCode]
	return ok
}

// ResetZipCode resets all changes to the "ZipCode" field.
func (m *ConfigareaMutation) ResetZipCode() {
	m._ZipCode = nil
	delete(m.clearedFields, configarea.FieldZipCode)
}

// SetSubDistrictNameTH sets the "SubDistrictNameTH" field.
func (m *ConfigareaMutation) SetSubDistrictNameTH(s string) {
	m._SubDistrictNameTH = &s
}

// SubDistrictNameTH returns the value of the "SubDistrictNameTH" field in the mutation.
func (m *ConfigareaMutation) SubDistrictNameTH() (r string, exists bool) {
	v := m._SubDistrictNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrictNameTH returns the old "SubDistrictNameTH" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldSubDistrictNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrictNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrictNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrictNameTH: %w", err)
	}
	return oldValue.SubDistrictNameTH, nil
}

// ClearSubDistrictNameTH clears the value of the "SubDistrictNameTH" field.
func (m *ConfigareaMutation) ClearSubDistrictNameTH() {
	m._SubDistrictNameTH = nil
	m.clearedFields[configarea.FieldSubDistrictNameTH] = struct{}{}
}

// SubDistrictNameTHCleared returns if the "SubDistrictNameTH" field was cleared in this mutation.
func (m *ConfigareaMutation) SubDistrictNameTHCleared() bool {
	_, ok := m.clearedFields[configarea.FieldSubDistrictNameTH]
	return ok
}

// ResetSubDistrictNameTH resets all changes to the "SubDistrictNameTH" field.
func (m *ConfigareaMutation) ResetSubDistrictNameTH() {
	m._SubDistrictNameTH = nil
	delete(m.clearedFields, configarea.FieldSubDistrictNameTH)
}

// SetApproveBy sets the "ApproveBy" field.
func (m *ConfigareaMutation) SetApproveBy(s string) {
	m._ApproveBy = &s
}

// ApproveBy returns the value of the "ApproveBy" field in the mutation.
func (m *ConfigareaMutation) ApproveBy() (r string, exists bool) {
	v := m._ApproveBy
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveBy returns the old "ApproveBy" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldApproveBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApproveBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApproveBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveBy: %w", err)
	}
	return oldValue.ApproveBy, nil
}

// ClearApproveBy clears the value of the "ApproveBy" field.
func (m *ConfigareaMutation) ClearApproveBy() {
	m._ApproveBy = nil
	m.clearedFields[configarea.FieldApproveBy] = struct{}{}
}

// ApproveByCleared returns if the "ApproveBy" field was cleared in this mutation.
func (m *ConfigareaMutation) ApproveByCleared() bool {
	_, ok := m.clearedFields[configarea.FieldApproveBy]
	return ok
}

// ResetApproveBy resets all changes to the "ApproveBy" field.
func (m *ConfigareaMutation) ResetApproveBy() {
	m._ApproveBy = nil
	delete(m.clearedFields, configarea.FieldApproveBy)
}

// SetApproveDate sets the "ApproveDate" field.
func (m *ConfigareaMutation) SetApproveDate(t time.Time) {
	m._ApproveDate = &t
}

// ApproveDate returns the value of the "ApproveDate" field in the mutation.
func (m *ConfigareaMutation) ApproveDate() (r time.Time, exists bool) {
	v := m._ApproveDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveDate returns the old "ApproveDate" field's value of the Configarea entity.
// If the Configarea object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigareaMutation) OldApproveDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApproveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApproveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveDate: %w", err)
	}
	return oldValue.ApproveDate, nil
}

// ClearApproveDate clears the value of the "ApproveDate" field.
func (m *ConfigareaMutation) ClearApproveDate() {
	m._ApproveDate = nil
	m.clearedFields[configarea.FieldApproveDate] = struct{}{}
}

// ApproveDateCleared returns if the "ApproveDate" field was cleared in this mutation.
func (m *ConfigareaMutation) ApproveDateCleared() bool {
	_, ok := m.clearedFields[configarea.FieldApproveDate]
	return ok
}

// ResetApproveDate resets all changes to the "ApproveDate" field.
func (m *ConfigareaMutation) ResetApproveDate() {
	m._ApproveDate = nil
	delete(m.clearedFields, configarea.FieldApproveDate)
}

// Op returns the operation name.
func (m *ConfigareaMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configarea).
func (m *ConfigareaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigareaMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m._ProvinceID != nil {
		fields = append(fields, configarea.FieldProvinceID)
	}
	if m._ProvinceNameTH != nil {
		fields = append(fields, configarea.FieldProvinceNameTH)
	}
	if m._DistrictID != nil {
		fields = append(fields, configarea.FieldDistrictID)
	}
	if m._DistrictNameTH != nil {
		fields = append(fields, configarea.FieldDistrictNameTH)
	}
	if m._DistrictNameEN != nil {
		fields = append(fields, configarea.FieldDistrictNameEN)
	}
	if m._Rank != nil {
		fields = append(fields, configarea.FieldRank)
	}
	if m._RankTmp != nil {
		fields = append(fields, configarea.FieldRankTmp)
	}
	if m._UpdateDate != nil {
		fields = append(fields, configarea.FieldUpdateDate)
	}
	if m._ZipCode != nil {
		fields = append(fields, configarea.FieldZipCode)
	}
	if m._SubDistrictNameTH != nil {
		fields = append(fields, configarea.FieldSubDistrictNameTH)
	}
	if m._ApproveBy != nil {
		fields = append(fields, configarea.FieldApproveBy)
	}
	if m._ApproveDate != nil {
		fields = append(fields, configarea.FieldApproveDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigareaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configarea.FieldProvinceID:
		return m.ProvinceID()
	case configarea.FieldProvinceNameTH:
		return m.ProvinceNameTH()
	case configarea.FieldDistrictID:
		return m.DistrictID()
	case configarea.FieldDistrictNameTH:
		return m.DistrictNameTH()
	case configarea.FieldDistrictNameEN:
		return m.DistrictNameEN()
	case configarea.FieldRank:
		return m.Rank()
	case configarea.FieldRankTmp:
		return m.RankTmp()
	case configarea.FieldUpdateDate:
		return m.UpdateDate()
	case configarea.FieldZipCode:
		return m.ZipCode()
	case configarea.FieldSubDistrictNameTH:
		return m.SubDistrictNameTH()
	case configarea.FieldApproveBy:
		return m.ApproveBy()
	case configarea.FieldApproveDate:
		return m.ApproveDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigareaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configarea.FieldProvinceID:
		return m.OldProvinceID(ctx)
	case configarea.FieldProvinceNameTH:
		return m.OldProvinceNameTH(ctx)
	case configarea.FieldDistrictID:
		return m.OldDistrictID(ctx)
	case configarea.FieldDistrictNameTH:
		return m.OldDistrictNameTH(ctx)
	case configarea.FieldDistrictNameEN:
		return m.OldDistrictNameEN(ctx)
	case configarea.FieldRank:
		return m.OldRank(ctx)
	case configarea.FieldRankTmp:
		return m.OldRankTmp(ctx)
	case configarea.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	case configarea.FieldZipCode:
		return m.OldZipCode(ctx)
	case configarea.FieldSubDistrictNameTH:
		return m.OldSubDistrictNameTH(ctx)
	case configarea.FieldApproveBy:
		return m.OldApproveBy(ctx)
	case configarea.FieldApproveDate:
		return m.OldApproveDate(ctx)
	}
	return nil, fmt.Errorf("unknown Configarea field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigareaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configarea.FieldProvinceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceID(v)
		return nil
	case configarea.FieldProvinceNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceNameTH(v)
		return nil
	case configarea.FieldDistrictID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictID(v)
		return nil
	case configarea.FieldDistrictNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictNameTH(v)
		return nil
	case configarea.FieldDistrictNameEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictNameEN(v)
		return nil
	case configarea.FieldRank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case configarea.FieldRankTmp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankTmp(v)
		return nil
	case configarea.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	case configarea.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case configarea.FieldSubDistrictNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrictNameTH(v)
		return nil
	case configarea.FieldApproveBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveBy(v)
		return nil
	case configarea.FieldApproveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveDate(v)
		return nil
	}
	return fmt.Errorf("unknown Configarea field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigareaMutation) AddedFields() []string {
	var fields []string
	if m.add_ProvinceID != nil {
		fields = append(fields, configarea.FieldProvinceID)
	}
	if m.add_DistrictID != nil {
		fields = append(fields, configarea.FieldDistrictID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigareaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configarea.FieldProvinceID:
		return m.AddedProvinceID()
	case configarea.FieldDistrictID:
		return m.AddedDistrictID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigareaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configarea.FieldProvinceID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProvinceID(v)
		return nil
	case configarea.FieldDistrictID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDistrictID(v)
		return nil
	}
	return fmt.Errorf("unknown Configarea numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigareaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configarea.FieldProvinceID) {
		fields = append(fields, configarea.FieldProvinceID)
	}
	if m.FieldCleared(configarea.FieldProvinceNameTH) {
		fields = append(fields, configarea.FieldProvinceNameTH)
	}
	if m.FieldCleared(configarea.FieldDistrictID) {
		fields = append(fields, configarea.FieldDistrictID)
	}
	if m.FieldCleared(configarea.FieldDistrictNameTH) {
		fields = append(fields, configarea.FieldDistrictNameTH)
	}
	if m.FieldCleared(configarea.FieldDistrictNameEN) {
		fields = append(fields, configarea.FieldDistrictNameEN)
	}
	if m.FieldCleared(configarea.FieldRank) {
		fields = append(fields, configarea.FieldRank)
	}
	if m.FieldCleared(configarea.FieldRankTmp) {
		fields = append(fields, configarea.FieldRankTmp)
	}
	if m.FieldCleared(configarea.FieldUpdateDate) {
		fields = append(fields, configarea.FieldUpdateDate)
	}
	if m.FieldCleared(configarea.FieldZipCode) {
		fields = append(fields, configarea.FieldZipCode)
	}
	if m.FieldCleared(configarea.FieldSubDistrictNameTH) {
		fields = append(fields, configarea.FieldSubDistrictNameTH)
	}
	if m.FieldCleared(configarea.FieldApproveBy) {
		fields = append(fields, configarea.FieldApproveBy)
	}
	if m.FieldCleared(configarea.FieldApproveDate) {
		fields = append(fields, configarea.FieldApproveDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigareaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigareaMutation) ClearField(name string) error {
	switch name {
	case configarea.FieldProvinceID:
		m.ClearProvinceID()
		return nil
	case configarea.FieldProvinceNameTH:
		m.ClearProvinceNameTH()
		return nil
	case configarea.FieldDistrictID:
		m.ClearDistrictID()
		return nil
	case configarea.FieldDistrictNameTH:
		m.ClearDistrictNameTH()
		return nil
	case configarea.FieldDistrictNameEN:
		m.ClearDistrictNameEN()
		return nil
	case configarea.FieldRank:
		m.ClearRank()
		return nil
	case configarea.FieldRankTmp:
		m.ClearRankTmp()
		return nil
	case configarea.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	case configarea.FieldZipCode:
		m.ClearZipCode()
		return nil
	case configarea.FieldSubDistrictNameTH:
		m.ClearSubDistrictNameTH()
		return nil
	case configarea.FieldApproveBy:
		m.ClearApproveBy()
		return nil
	case configarea.FieldApproveDate:
		m.ClearApproveDate()
		return nil
	}
	return fmt.Errorf("unknown Configarea nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigareaMutation) ResetField(name string) error {
	switch name {
	case configarea.FieldProvinceID:
		m.ResetProvinceID()
		return nil
	case configarea.FieldProvinceNameTH:
		m.ResetProvinceNameTH()
		return nil
	case configarea.FieldDistrictID:
		m.ResetDistrictID()
		return nil
	case configarea.FieldDistrictNameTH:
		m.ResetDistrictNameTH()
		return nil
	case configarea.FieldDistrictNameEN:
		m.ResetDistrictNameEN()
		return nil
	case configarea.FieldRank:
		m.ResetRank()
		return nil
	case configarea.FieldRankTmp:
		m.ResetRankTmp()
		return nil
	case configarea.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	case configarea.FieldZipCode:
		m.ResetZipCode()
		return nil
	case configarea.FieldSubDistrictNameTH:
		m.ResetSubDistrictNameTH()
		return nil
	case configarea.FieldApproveBy:
		m.ResetApproveBy()
		return nil
	case configarea.FieldApproveDate:
		m.ResetApproveDate()
		return nil
	}
	return fmt.Errorf("unknown Configarea field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigareaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigareaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigareaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigareaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigareaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigareaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigareaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configarea unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigareaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configarea edge %s", name)
}

// ConfigdatecalculaterankMutation represents an operation that mutates the Configdatecalculaterank nodes in the graph.
type ConfigdatecalculaterankMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Rank                    *string
	_NumDateCalculateRank    *int
	add_NumDateCalculateRank *int
	_NumDateCalculateRankTmp *string
	_UpdateDate              *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Configdatecalculaterank, error)
	predicates               []predicate.Configdatecalculaterank
}

var _ ent.Mutation = (*ConfigdatecalculaterankMutation)(nil)

// configdatecalculaterankOption allows management of the mutation configuration using functional options.
type configdatecalculaterankOption func(*ConfigdatecalculaterankMutation)

// newConfigdatecalculaterankMutation creates new mutation for the Configdatecalculaterank entity.
func newConfigdatecalculaterankMutation(c config, op Op, opts ...configdatecalculaterankOption) *ConfigdatecalculaterankMutation {
	m := &ConfigdatecalculaterankMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigdatecalculaterank,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigdatecalculaterankID sets the ID field of the mutation.
func withConfigdatecalculaterankID(id int) configdatecalculaterankOption {
	return func(m *ConfigdatecalculaterankMutation) {
		var (
			err   error
			once  sync.Once
			value *Configdatecalculaterank
		)
		m.oldValue = func(ctx context.Context) (*Configdatecalculaterank, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configdatecalculaterank.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigdatecalculaterank sets the old Configdatecalculaterank of the mutation.
func withConfigdatecalculaterank(node *Configdatecalculaterank) configdatecalculaterankOption {
	return func(m *ConfigdatecalculaterankMutation) {
		m.oldValue = func(context.Context) (*Configdatecalculaterank, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigdatecalculaterankMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigdatecalculaterankMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configdatecalculaterank entities.
func (m *ConfigdatecalculaterankMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConfigdatecalculaterankMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetRank sets the "Rank" field.
func (m *ConfigdatecalculaterankMutation) SetRank(s string) {
	m._Rank = &s
}

// Rank returns the value of the "Rank" field in the mutation.
func (m *ConfigdatecalculaterankMutation) Rank() (r string, exists bool) {
	v := m._Rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "Rank" field's value of the Configdatecalculaterank entity.
// If the Configdatecalculaterank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigdatecalculaterankMutation) OldRank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// ClearRank clears the value of the "Rank" field.
func (m *ConfigdatecalculaterankMutation) ClearRank() {
	m._Rank = nil
	m.clearedFields[configdatecalculaterank.FieldRank] = struct{}{}
}

// RankCleared returns if the "Rank" field was cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) RankCleared() bool {
	_, ok := m.clearedFields[configdatecalculaterank.FieldRank]
	return ok
}

// ResetRank resets all changes to the "Rank" field.
func (m *ConfigdatecalculaterankMutation) ResetRank() {
	m._Rank = nil
	delete(m.clearedFields, configdatecalculaterank.FieldRank)
}

// SetNumDateCalculateRank sets the "NumDateCalculateRank" field.
func (m *ConfigdatecalculaterankMutation) SetNumDateCalculateRank(i int) {
	m._NumDateCalculateRank = &i
	m.add_NumDateCalculateRank = nil
}

// NumDateCalculateRank returns the value of the "NumDateCalculateRank" field in the mutation.
func (m *ConfigdatecalculaterankMutation) NumDateCalculateRank() (r int, exists bool) {
	v := m._NumDateCalculateRank
	if v == nil {
		return
	}
	return *v, true
}

// OldNumDateCalculateRank returns the old "NumDateCalculateRank" field's value of the Configdatecalculaterank entity.
// If the Configdatecalculaterank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigdatecalculaterankMutation) OldNumDateCalculateRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumDateCalculateRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumDateCalculateRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumDateCalculateRank: %w", err)
	}
	return oldValue.NumDateCalculateRank, nil
}

// AddNumDateCalculateRank adds i to the "NumDateCalculateRank" field.
func (m *ConfigdatecalculaterankMutation) AddNumDateCalculateRank(i int) {
	if m.add_NumDateCalculateRank != nil {
		*m.add_NumDateCalculateRank += i
	} else {
		m.add_NumDateCalculateRank = &i
	}
}

// AddedNumDateCalculateRank returns the value that was added to the "NumDateCalculateRank" field in this mutation.
func (m *ConfigdatecalculaterankMutation) AddedNumDateCalculateRank() (r int, exists bool) {
	v := m.add_NumDateCalculateRank
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumDateCalculateRank clears the value of the "NumDateCalculateRank" field.
func (m *ConfigdatecalculaterankMutation) ClearNumDateCalculateRank() {
	m._NumDateCalculateRank = nil
	m.add_NumDateCalculateRank = nil
	m.clearedFields[configdatecalculaterank.FieldNumDateCalculateRank] = struct{}{}
}

// NumDateCalculateRankCleared returns if the "NumDateCalculateRank" field was cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) NumDateCalculateRankCleared() bool {
	_, ok := m.clearedFields[configdatecalculaterank.FieldNumDateCalculateRank]
	return ok
}

// ResetNumDateCalculateRank resets all changes to the "NumDateCalculateRank" field.
func (m *ConfigdatecalculaterankMutation) ResetNumDateCalculateRank() {
	m._NumDateCalculateRank = nil
	m.add_NumDateCalculateRank = nil
	delete(m.clearedFields, configdatecalculaterank.FieldNumDateCalculateRank)
}

// SetNumDateCalculateRankTmp sets the "NumDateCalculateRankTmp" field.
func (m *ConfigdatecalculaterankMutation) SetNumDateCalculateRankTmp(s string) {
	m._NumDateCalculateRankTmp = &s
}

// NumDateCalculateRankTmp returns the value of the "NumDateCalculateRankTmp" field in the mutation.
func (m *ConfigdatecalculaterankMutation) NumDateCalculateRankTmp() (r string, exists bool) {
	v := m._NumDateCalculateRankTmp
	if v == nil {
		return
	}
	return *v, true
}

// OldNumDateCalculateRankTmp returns the old "NumDateCalculateRankTmp" field's value of the Configdatecalculaterank entity.
// If the Configdatecalculaterank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigdatecalculaterankMutation) OldNumDateCalculateRankTmp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumDateCalculateRankTmp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumDateCalculateRankTmp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumDateCalculateRankTmp: %w", err)
	}
	return oldValue.NumDateCalculateRankTmp, nil
}

// ClearNumDateCalculateRankTmp clears the value of the "NumDateCalculateRankTmp" field.
func (m *ConfigdatecalculaterankMutation) ClearNumDateCalculateRankTmp() {
	m._NumDateCalculateRankTmp = nil
	m.clearedFields[configdatecalculaterank.FieldNumDateCalculateRankTmp] = struct{}{}
}

// NumDateCalculateRankTmpCleared returns if the "NumDateCalculateRankTmp" field was cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) NumDateCalculateRankTmpCleared() bool {
	_, ok := m.clearedFields[configdatecalculaterank.FieldNumDateCalculateRankTmp]
	return ok
}

// ResetNumDateCalculateRankTmp resets all changes to the "NumDateCalculateRankTmp" field.
func (m *ConfigdatecalculaterankMutation) ResetNumDateCalculateRankTmp() {
	m._NumDateCalculateRankTmp = nil
	delete(m.clearedFields, configdatecalculaterank.FieldNumDateCalculateRankTmp)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *ConfigdatecalculaterankMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *ConfigdatecalculaterankMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Configdatecalculaterank entity.
// If the Configdatecalculaterank object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigdatecalculaterankMutation) OldUpdateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *ConfigdatecalculaterankMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[configdatecalculaterank.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[configdatecalculaterank.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *ConfigdatecalculaterankMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, configdatecalculaterank.FieldUpdateDate)
}

// Op returns the operation name.
func (m *ConfigdatecalculaterankMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configdatecalculaterank).
func (m *ConfigdatecalculaterankMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigdatecalculaterankMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Rank != nil {
		fields = append(fields, configdatecalculaterank.FieldRank)
	}
	if m._NumDateCalculateRank != nil {
		fields = append(fields, configdatecalculaterank.FieldNumDateCalculateRank)
	}
	if m._NumDateCalculateRankTmp != nil {
		fields = append(fields, configdatecalculaterank.FieldNumDateCalculateRankTmp)
	}
	if m._UpdateDate != nil {
		fields = append(fields, configdatecalculaterank.FieldUpdateDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigdatecalculaterankMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configdatecalculaterank.FieldRank:
		return m.Rank()
	case configdatecalculaterank.FieldNumDateCalculateRank:
		return m.NumDateCalculateRank()
	case configdatecalculaterank.FieldNumDateCalculateRankTmp:
		return m.NumDateCalculateRankTmp()
	case configdatecalculaterank.FieldUpdateDate:
		return m.UpdateDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigdatecalculaterankMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configdatecalculaterank.FieldRank:
		return m.OldRank(ctx)
	case configdatecalculaterank.FieldNumDateCalculateRank:
		return m.OldNumDateCalculateRank(ctx)
	case configdatecalculaterank.FieldNumDateCalculateRankTmp:
		return m.OldNumDateCalculateRankTmp(ctx)
	case configdatecalculaterank.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	}
	return nil, fmt.Errorf("unknown Configdatecalculaterank field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigdatecalculaterankMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configdatecalculaterank.FieldRank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumDateCalculateRank(v)
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRankTmp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumDateCalculateRankTmp(v)
		return nil
	case configdatecalculaterank.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	}
	return fmt.Errorf("unknown Configdatecalculaterank field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigdatecalculaterankMutation) AddedFields() []string {
	var fields []string
	if m.add_NumDateCalculateRank != nil {
		fields = append(fields, configdatecalculaterank.FieldNumDateCalculateRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigdatecalculaterankMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configdatecalculaterank.FieldNumDateCalculateRank:
		return m.AddedNumDateCalculateRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigdatecalculaterankMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configdatecalculaterank.FieldNumDateCalculateRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumDateCalculateRank(v)
		return nil
	}
	return fmt.Errorf("unknown Configdatecalculaterank numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigdatecalculaterankMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configdatecalculaterank.FieldRank) {
		fields = append(fields, configdatecalculaterank.FieldRank)
	}
	if m.FieldCleared(configdatecalculaterank.FieldNumDateCalculateRank) {
		fields = append(fields, configdatecalculaterank.FieldNumDateCalculateRank)
	}
	if m.FieldCleared(configdatecalculaterank.FieldNumDateCalculateRankTmp) {
		fields = append(fields, configdatecalculaterank.FieldNumDateCalculateRankTmp)
	}
	if m.FieldCleared(configdatecalculaterank.FieldUpdateDate) {
		fields = append(fields, configdatecalculaterank.FieldUpdateDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigdatecalculaterankMutation) ClearField(name string) error {
	switch name {
	case configdatecalculaterank.FieldRank:
		m.ClearRank()
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRank:
		m.ClearNumDateCalculateRank()
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRankTmp:
		m.ClearNumDateCalculateRankTmp()
		return nil
	case configdatecalculaterank.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Configdatecalculaterank nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigdatecalculaterankMutation) ResetField(name string) error {
	switch name {
	case configdatecalculaterank.FieldRank:
		m.ResetRank()
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRank:
		m.ResetNumDateCalculateRank()
		return nil
	case configdatecalculaterank.FieldNumDateCalculateRankTmp:
		m.ResetNumDateCalculateRankTmp()
		return nil
	case configdatecalculaterank.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Configdatecalculaterank field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigdatecalculaterankMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigdatecalculaterankMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigdatecalculaterankMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigdatecalculaterankMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigdatecalculaterankMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigdatecalculaterankMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configdatecalculaterank unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigdatecalculaterankMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configdatecalculaterank edge %s", name)
}

// ConfigoccupationMutation represents an operation that mutates the Configoccupation nodes in the graph.
type ConfigoccupationMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_OccupationName *string
	_Rank           *string
	_RankTmp        *string
	_UpdateDate     *time.Time
	_ApproveBy      *string
	_ApproveDate    *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Configoccupation, error)
	predicates      []predicate.Configoccupation
}

var _ ent.Mutation = (*ConfigoccupationMutation)(nil)

// configoccupationOption allows management of the mutation configuration using functional options.
type configoccupationOption func(*ConfigoccupationMutation)

// newConfigoccupationMutation creates new mutation for the Configoccupation entity.
func newConfigoccupationMutation(c config, op Op, opts ...configoccupationOption) *ConfigoccupationMutation {
	m := &ConfigoccupationMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigoccupation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigoccupationID sets the ID field of the mutation.
func withConfigoccupationID(id int) configoccupationOption {
	return func(m *ConfigoccupationMutation) {
		var (
			err   error
			once  sync.Once
			value *Configoccupation
		)
		m.oldValue = func(ctx context.Context) (*Configoccupation, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configoccupation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigoccupation sets the old Configoccupation of the mutation.
func withConfigoccupation(node *Configoccupation) configoccupationOption {
	return func(m *ConfigoccupationMutation) {
		m.oldValue = func(context.Context) (*Configoccupation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigoccupationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigoccupationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configoccupation entities.
func (m *ConfigoccupationMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConfigoccupationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOccupationName sets the "OccupationName" field.
func (m *ConfigoccupationMutation) SetOccupationName(s string) {
	m._OccupationName = &s
}

// OccupationName returns the value of the "OccupationName" field in the mutation.
func (m *ConfigoccupationMutation) OccupationName() (r string, exists bool) {
	v := m._OccupationName
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationName returns the old "OccupationName" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldOccupationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationName: %w", err)
	}
	return oldValue.OccupationName, nil
}

// ClearOccupationName clears the value of the "OccupationName" field.
func (m *ConfigoccupationMutation) ClearOccupationName() {
	m._OccupationName = nil
	m.clearedFields[configoccupation.FieldOccupationName] = struct{}{}
}

// OccupationNameCleared returns if the "OccupationName" field was cleared in this mutation.
func (m *ConfigoccupationMutation) OccupationNameCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldOccupationName]
	return ok
}

// ResetOccupationName resets all changes to the "OccupationName" field.
func (m *ConfigoccupationMutation) ResetOccupationName() {
	m._OccupationName = nil
	delete(m.clearedFields, configoccupation.FieldOccupationName)
}

// SetRank sets the "Rank" field.
func (m *ConfigoccupationMutation) SetRank(s string) {
	m._Rank = &s
}

// Rank returns the value of the "Rank" field in the mutation.
func (m *ConfigoccupationMutation) Rank() (r string, exists bool) {
	v := m._Rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "Rank" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldRank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// ClearRank clears the value of the "Rank" field.
func (m *ConfigoccupationMutation) ClearRank() {
	m._Rank = nil
	m.clearedFields[configoccupation.FieldRank] = struct{}{}
}

// RankCleared returns if the "Rank" field was cleared in this mutation.
func (m *ConfigoccupationMutation) RankCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldRank]
	return ok
}

// ResetRank resets all changes to the "Rank" field.
func (m *ConfigoccupationMutation) ResetRank() {
	m._Rank = nil
	delete(m.clearedFields, configoccupation.FieldRank)
}

// SetRankTmp sets the "RankTmp" field.
func (m *ConfigoccupationMutation) SetRankTmp(s string) {
	m._RankTmp = &s
}

// RankTmp returns the value of the "RankTmp" field in the mutation.
func (m *ConfigoccupationMutation) RankTmp() (r string, exists bool) {
	v := m._RankTmp
	if v == nil {
		return
	}
	return *v, true
}

// OldRankTmp returns the old "RankTmp" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldRankTmp(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankTmp is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankTmp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankTmp: %w", err)
	}
	return oldValue.RankTmp, nil
}

// ClearRankTmp clears the value of the "RankTmp" field.
func (m *ConfigoccupationMutation) ClearRankTmp() {
	m._RankTmp = nil
	m.clearedFields[configoccupation.FieldRankTmp] = struct{}{}
}

// RankTmpCleared returns if the "RankTmp" field was cleared in this mutation.
func (m *ConfigoccupationMutation) RankTmpCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldRankTmp]
	return ok
}

// ResetRankTmp resets all changes to the "RankTmp" field.
func (m *ConfigoccupationMutation) ResetRankTmp() {
	m._RankTmp = nil
	delete(m.clearedFields, configoccupation.FieldRankTmp)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *ConfigoccupationMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *ConfigoccupationMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldUpdateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *ConfigoccupationMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[configoccupation.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *ConfigoccupationMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *ConfigoccupationMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, configoccupation.FieldUpdateDate)
}

// SetApproveBy sets the "ApproveBy" field.
func (m *ConfigoccupationMutation) SetApproveBy(s string) {
	m._ApproveBy = &s
}

// ApproveBy returns the value of the "ApproveBy" field in the mutation.
func (m *ConfigoccupationMutation) ApproveBy() (r string, exists bool) {
	v := m._ApproveBy
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveBy returns the old "ApproveBy" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldApproveBy(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApproveBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApproveBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveBy: %w", err)
	}
	return oldValue.ApproveBy, nil
}

// ClearApproveBy clears the value of the "ApproveBy" field.
func (m *ConfigoccupationMutation) ClearApproveBy() {
	m._ApproveBy = nil
	m.clearedFields[configoccupation.FieldApproveBy] = struct{}{}
}

// ApproveByCleared returns if the "ApproveBy" field was cleared in this mutation.
func (m *ConfigoccupationMutation) ApproveByCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldApproveBy]
	return ok
}

// ResetApproveBy resets all changes to the "ApproveBy" field.
func (m *ConfigoccupationMutation) ResetApproveBy() {
	m._ApproveBy = nil
	delete(m.clearedFields, configoccupation.FieldApproveBy)
}

// SetApproveDate sets the "ApproveDate" field.
func (m *ConfigoccupationMutation) SetApproveDate(t time.Time) {
	m._ApproveDate = &t
}

// ApproveDate returns the value of the "ApproveDate" field in the mutation.
func (m *ConfigoccupationMutation) ApproveDate() (r time.Time, exists bool) {
	v := m._ApproveDate
	if v == nil {
		return
	}
	return *v, true
}

// OldApproveDate returns the old "ApproveDate" field's value of the Configoccupation entity.
// If the Configoccupation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigoccupationMutation) OldApproveDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApproveDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApproveDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApproveDate: %w", err)
	}
	return oldValue.ApproveDate, nil
}

// ClearApproveDate clears the value of the "ApproveDate" field.
func (m *ConfigoccupationMutation) ClearApproveDate() {
	m._ApproveDate = nil
	m.clearedFields[configoccupation.FieldApproveDate] = struct{}{}
}

// ApproveDateCleared returns if the "ApproveDate" field was cleared in this mutation.
func (m *ConfigoccupationMutation) ApproveDateCleared() bool {
	_, ok := m.clearedFields[configoccupation.FieldApproveDate]
	return ok
}

// ResetApproveDate resets all changes to the "ApproveDate" field.
func (m *ConfigoccupationMutation) ResetApproveDate() {
	m._ApproveDate = nil
	delete(m.clearedFields, configoccupation.FieldApproveDate)
}

// Op returns the operation name.
func (m *ConfigoccupationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configoccupation).
func (m *ConfigoccupationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigoccupationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._OccupationName != nil {
		fields = append(fields, configoccupation.FieldOccupationName)
	}
	if m._Rank != nil {
		fields = append(fields, configoccupation.FieldRank)
	}
	if m._RankTmp != nil {
		fields = append(fields, configoccupation.FieldRankTmp)
	}
	if m._UpdateDate != nil {
		fields = append(fields, configoccupation.FieldUpdateDate)
	}
	if m._ApproveBy != nil {
		fields = append(fields, configoccupation.FieldApproveBy)
	}
	if m._ApproveDate != nil {
		fields = append(fields, configoccupation.FieldApproveDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigoccupationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configoccupation.FieldOccupationName:
		return m.OccupationName()
	case configoccupation.FieldRank:
		return m.Rank()
	case configoccupation.FieldRankTmp:
		return m.RankTmp()
	case configoccupation.FieldUpdateDate:
		return m.UpdateDate()
	case configoccupation.FieldApproveBy:
		return m.ApproveBy()
	case configoccupation.FieldApproveDate:
		return m.ApproveDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigoccupationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configoccupation.FieldOccupationName:
		return m.OldOccupationName(ctx)
	case configoccupation.FieldRank:
		return m.OldRank(ctx)
	case configoccupation.FieldRankTmp:
		return m.OldRankTmp(ctx)
	case configoccupation.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	case configoccupation.FieldApproveBy:
		return m.OldApproveBy(ctx)
	case configoccupation.FieldApproveDate:
		return m.OldApproveDate(ctx)
	}
	return nil, fmt.Errorf("unknown Configoccupation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigoccupationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configoccupation.FieldOccupationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationName(v)
		return nil
	case configoccupation.FieldRank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case configoccupation.FieldRankTmp:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankTmp(v)
		return nil
	case configoccupation.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	case configoccupation.FieldApproveBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveBy(v)
		return nil
	case configoccupation.FieldApproveDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApproveDate(v)
		return nil
	}
	return fmt.Errorf("unknown Configoccupation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigoccupationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigoccupationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigoccupationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Configoccupation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigoccupationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configoccupation.FieldOccupationName) {
		fields = append(fields, configoccupation.FieldOccupationName)
	}
	if m.FieldCleared(configoccupation.FieldRank) {
		fields = append(fields, configoccupation.FieldRank)
	}
	if m.FieldCleared(configoccupation.FieldRankTmp) {
		fields = append(fields, configoccupation.FieldRankTmp)
	}
	if m.FieldCleared(configoccupation.FieldUpdateDate) {
		fields = append(fields, configoccupation.FieldUpdateDate)
	}
	if m.FieldCleared(configoccupation.FieldApproveBy) {
		fields = append(fields, configoccupation.FieldApproveBy)
	}
	if m.FieldCleared(configoccupation.FieldApproveDate) {
		fields = append(fields, configoccupation.FieldApproveDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigoccupationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigoccupationMutation) ClearField(name string) error {
	switch name {
	case configoccupation.FieldOccupationName:
		m.ClearOccupationName()
		return nil
	case configoccupation.FieldRank:
		m.ClearRank()
		return nil
	case configoccupation.FieldRankTmp:
		m.ClearRankTmp()
		return nil
	case configoccupation.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	case configoccupation.FieldApproveBy:
		m.ClearApproveBy()
		return nil
	case configoccupation.FieldApproveDate:
		m.ClearApproveDate()
		return nil
	}
	return fmt.Errorf("unknown Configoccupation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigoccupationMutation) ResetField(name string) error {
	switch name {
	case configoccupation.FieldOccupationName:
		m.ResetOccupationName()
		return nil
	case configoccupation.FieldRank:
		m.ResetRank()
		return nil
	case configoccupation.FieldRankTmp:
		m.ResetRankTmp()
		return nil
	case configoccupation.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	case configoccupation.FieldApproveBy:
		m.ResetApproveBy()
		return nil
	case configoccupation.FieldApproveDate:
		m.ResetApproveDate()
		return nil
	}
	return fmt.Errorf("unknown Configoccupation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigoccupationMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigoccupationMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigoccupationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigoccupationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigoccupationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigoccupationMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigoccupationMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configoccupation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigoccupationMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configoccupation edge %s", name)
}

// ConfigpointMutation represents an operation that mutates the Configpoint nodes in the graph.
type ConfigpointMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_TransactionName   *string
	_TransactionType   *string
	_PaymentChannel    *string
	_PaymentType       *string
	_DummyWallet       *string
	_Amount            *int
	add_Amount         *int
	_Point             *int
	add_Point          *int
	_Expire            *int
	add_Expire         *int
	_UpdateDate        *time.Time
	_ExpireDate        *time.Time
	_StatusTransaction *string
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Configpoint, error)
	predicates         []predicate.Configpoint
}

var _ ent.Mutation = (*ConfigpointMutation)(nil)

// configpointOption allows management of the mutation configuration using functional options.
type configpointOption func(*ConfigpointMutation)

// newConfigpointMutation creates new mutation for the Configpoint entity.
func newConfigpointMutation(c config, op Op, opts ...configpointOption) *ConfigpointMutation {
	m := &ConfigpointMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigpointID sets the ID field of the mutation.
func withConfigpointID(id int) configpointOption {
	return func(m *ConfigpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Configpoint
		)
		m.oldValue = func(ctx context.Context) (*Configpoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Configpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigpoint sets the old Configpoint of the mutation.
func withConfigpoint(node *Configpoint) configpointOption {
	return func(m *ConfigpointMutation) {
		m.oldValue = func(context.Context) (*Configpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Configpoint entities.
func (m *ConfigpointMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConfigpointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTransactionName sets the "TransactionName" field.
func (m *ConfigpointMutation) SetTransactionName(s string) {
	m._TransactionName = &s
}

// TransactionName returns the value of the "TransactionName" field in the mutation.
func (m *ConfigpointMutation) TransactionName() (r string, exists bool) {
	v := m._TransactionName
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionName returns the old "TransactionName" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldTransactionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionName: %w", err)
	}
	return oldValue.TransactionName, nil
}

// ClearTransactionName clears the value of the "TransactionName" field.
func (m *ConfigpointMutation) ClearTransactionName() {
	m._TransactionName = nil
	m.clearedFields[configpoint.FieldTransactionName] = struct{}{}
}

// TransactionNameCleared returns if the "TransactionName" field was cleared in this mutation.
func (m *ConfigpointMutation) TransactionNameCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldTransactionName]
	return ok
}

// ResetTransactionName resets all changes to the "TransactionName" field.
func (m *ConfigpointMutation) ResetTransactionName() {
	m._TransactionName = nil
	delete(m.clearedFields, configpoint.FieldTransactionName)
}

// SetTransactionType sets the "TransactionType" field.
func (m *ConfigpointMutation) SetTransactionType(s string) {
	m._TransactionType = &s
}

// TransactionType returns the value of the "TransactionType" field in the mutation.
func (m *ConfigpointMutation) TransactionType() (r string, exists bool) {
	v := m._TransactionType
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "TransactionType" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldTransactionType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ClearTransactionType clears the value of the "TransactionType" field.
func (m *ConfigpointMutation) ClearTransactionType() {
	m._TransactionType = nil
	m.clearedFields[configpoint.FieldTransactionType] = struct{}{}
}

// TransactionTypeCleared returns if the "TransactionType" field was cleared in this mutation.
func (m *ConfigpointMutation) TransactionTypeCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldTransactionType]
	return ok
}

// ResetTransactionType resets all changes to the "TransactionType" field.
func (m *ConfigpointMutation) ResetTransactionType() {
	m._TransactionType = nil
	delete(m.clearedFields, configpoint.FieldTransactionType)
}

// SetPaymentChannel sets the "PaymentChannel" field.
func (m *ConfigpointMutation) SetPaymentChannel(s string) {
	m._PaymentChannel = &s
}

// PaymentChannel returns the value of the "PaymentChannel" field in the mutation.
func (m *ConfigpointMutation) PaymentChannel() (r string, exists bool) {
	v := m._PaymentChannel
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentChannel returns the old "PaymentChannel" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldPaymentChannel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentChannel: %w", err)
	}
	return oldValue.PaymentChannel, nil
}

// ClearPaymentChannel clears the value of the "PaymentChannel" field.
func (m *ConfigpointMutation) ClearPaymentChannel() {
	m._PaymentChannel = nil
	m.clearedFields[configpoint.FieldPaymentChannel] = struct{}{}
}

// PaymentChannelCleared returns if the "PaymentChannel" field was cleared in this mutation.
func (m *ConfigpointMutation) PaymentChannelCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldPaymentChannel]
	return ok
}

// ResetPaymentChannel resets all changes to the "PaymentChannel" field.
func (m *ConfigpointMutation) ResetPaymentChannel() {
	m._PaymentChannel = nil
	delete(m.clearedFields, configpoint.FieldPaymentChannel)
}

// SetPaymentType sets the "PaymentType" field.
func (m *ConfigpointMutation) SetPaymentType(s string) {
	m._PaymentType = &s
}

// PaymentType returns the value of the "PaymentType" field in the mutation.
func (m *ConfigpointMutation) PaymentType() (r string, exists bool) {
	v := m._PaymentType
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "PaymentType" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldPaymentType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ClearPaymentType clears the value of the "PaymentType" field.
func (m *ConfigpointMutation) ClearPaymentType() {
	m._PaymentType = nil
	m.clearedFields[configpoint.FieldPaymentType] = struct{}{}
}

// PaymentTypeCleared returns if the "PaymentType" field was cleared in this mutation.
func (m *ConfigpointMutation) PaymentTypeCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldPaymentType]
	return ok
}

// ResetPaymentType resets all changes to the "PaymentType" field.
func (m *ConfigpointMutation) ResetPaymentType() {
	m._PaymentType = nil
	delete(m.clearedFields, configpoint.FieldPaymentType)
}

// SetDummyWallet sets the "DummyWallet" field.
func (m *ConfigpointMutation) SetDummyWallet(s string) {
	m._DummyWallet = &s
}

// DummyWallet returns the value of the "DummyWallet" field in the mutation.
func (m *ConfigpointMutation) DummyWallet() (r string, exists bool) {
	v := m._DummyWallet
	if v == nil {
		return
	}
	return *v, true
}

// OldDummyWallet returns the old "DummyWallet" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldDummyWallet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDummyWallet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDummyWallet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDummyWallet: %w", err)
	}
	return oldValue.DummyWallet, nil
}

// ClearDummyWallet clears the value of the "DummyWallet" field.
func (m *ConfigpointMutation) ClearDummyWallet() {
	m._DummyWallet = nil
	m.clearedFields[configpoint.FieldDummyWallet] = struct{}{}
}

// DummyWalletCleared returns if the "DummyWallet" field was cleared in this mutation.
func (m *ConfigpointMutation) DummyWalletCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldDummyWallet]
	return ok
}

// ResetDummyWallet resets all changes to the "DummyWallet" field.
func (m *ConfigpointMutation) ResetDummyWallet() {
	m._DummyWallet = nil
	delete(m.clearedFields, configpoint.FieldDummyWallet)
}

// SetAmount sets the "Amount" field.
func (m *ConfigpointMutation) SetAmount(i int) {
	m._Amount = &i
	m.add_Amount = nil
}

// Amount returns the value of the "Amount" field in the mutation.
func (m *ConfigpointMutation) Amount() (r int, exists bool) {
	v := m._Amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "Amount" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldAmount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds i to the "Amount" field.
func (m *ConfigpointMutation) AddAmount(i int) {
	if m.add_Amount != nil {
		*m.add_Amount += i
	} else {
		m.add_Amount = &i
	}
}

// AddedAmount returns the value that was added to the "Amount" field in this mutation.
func (m *ConfigpointMutation) AddedAmount() (r int, exists bool) {
	v := m.add_Amount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "Amount" field.
func (m *ConfigpointMutation) ClearAmount() {
	m._Amount = nil
	m.add_Amount = nil
	m.clearedFields[configpoint.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "Amount" field was cleared in this mutation.
func (m *ConfigpointMutation) AmountCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "Amount" field.
func (m *ConfigpointMutation) ResetAmount() {
	m._Amount = nil
	m.add_Amount = nil
	delete(m.clearedFields, configpoint.FieldAmount)
}

// SetPoint sets the "Point" field.
func (m *ConfigpointMutation) SetPoint(i int) {
	m._Point = &i
	m.add_Point = nil
}

// Point returns the value of the "Point" field in the mutation.
func (m *ConfigpointMutation) Point() (r int, exists bool) {
	v := m._Point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "Point" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "Point" field.
func (m *ConfigpointMutation) AddPoint(i int) {
	if m.add_Point != nil {
		*m.add_Point += i
	} else {
		m.add_Point = &i
	}
}

// AddedPoint returns the value that was added to the "Point" field in this mutation.
func (m *ConfigpointMutation) AddedPoint() (r int, exists bool) {
	v := m.add_Point
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoint clears the value of the "Point" field.
func (m *ConfigpointMutation) ClearPoint() {
	m._Point = nil
	m.add_Point = nil
	m.clearedFields[configpoint.FieldPoint] = struct{}{}
}

// PointCleared returns if the "Point" field was cleared in this mutation.
func (m *ConfigpointMutation) PointCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldPoint]
	return ok
}

// ResetPoint resets all changes to the "Point" field.
func (m *ConfigpointMutation) ResetPoint() {
	m._Point = nil
	m.add_Point = nil
	delete(m.clearedFields, configpoint.FieldPoint)
}

// SetExpire sets the "Expire" field.
func (m *ConfigpointMutation) SetExpire(i int) {
	m._Expire = &i
	m.add_Expire = nil
}

// Expire returns the value of the "Expire" field in the mutation.
func (m *ConfigpointMutation) Expire() (r int, exists bool) {
	v := m._Expire
	if v == nil {
		return
	}
	return *v, true
}

// OldExpire returns the old "Expire" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldExpire(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpire: %w", err)
	}
	return oldValue.Expire, nil
}

// AddExpire adds i to the "Expire" field.
func (m *ConfigpointMutation) AddExpire(i int) {
	if m.add_Expire != nil {
		*m.add_Expire += i
	} else {
		m.add_Expire = &i
	}
}

// AddedExpire returns the value that was added to the "Expire" field in this mutation.
func (m *ConfigpointMutation) AddedExpire() (r int, exists bool) {
	v := m.add_Expire
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpire clears the value of the "Expire" field.
func (m *ConfigpointMutation) ClearExpire() {
	m._Expire = nil
	m.add_Expire = nil
	m.clearedFields[configpoint.FieldExpire] = struct{}{}
}

// ExpireCleared returns if the "Expire" field was cleared in this mutation.
func (m *ConfigpointMutation) ExpireCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldExpire]
	return ok
}

// ResetExpire resets all changes to the "Expire" field.
func (m *ConfigpointMutation) ResetExpire() {
	m._Expire = nil
	m.add_Expire = nil
	delete(m.clearedFields, configpoint.FieldExpire)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *ConfigpointMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *ConfigpointMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldUpdateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *ConfigpointMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[configpoint.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *ConfigpointMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *ConfigpointMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, configpoint.FieldUpdateDate)
}

// SetExpireDate sets the "ExpireDate" field.
func (m *ConfigpointMutation) SetExpireDate(t time.Time) {
	m._ExpireDate = &t
}

// ExpireDate returns the value of the "ExpireDate" field in the mutation.
func (m *ConfigpointMutation) ExpireDate() (r time.Time, exists bool) {
	v := m._ExpireDate
	if v == nil {
		return
	}
	return *v, true
}

// OldExpireDate returns the old "ExpireDate" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldExpireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExpireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExpireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpireDate: %w", err)
	}
	return oldValue.ExpireDate, nil
}

// ClearExpireDate clears the value of the "ExpireDate" field.
func (m *ConfigpointMutation) ClearExpireDate() {
	m._ExpireDate = nil
	m.clearedFields[configpoint.FieldExpireDate] = struct{}{}
}

// ExpireDateCleared returns if the "ExpireDate" field was cleared in this mutation.
func (m *ConfigpointMutation) ExpireDateCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldExpireDate]
	return ok
}

// ResetExpireDate resets all changes to the "ExpireDate" field.
func (m *ConfigpointMutation) ResetExpireDate() {
	m._ExpireDate = nil
	delete(m.clearedFields, configpoint.FieldExpireDate)
}

// SetStatusTransaction sets the "StatusTransaction" field.
func (m *ConfigpointMutation) SetStatusTransaction(s string) {
	m._StatusTransaction = &s
}

// StatusTransaction returns the value of the "StatusTransaction" field in the mutation.
func (m *ConfigpointMutation) StatusTransaction() (r string, exists bool) {
	v := m._StatusTransaction
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusTransaction returns the old "StatusTransaction" field's value of the Configpoint entity.
// If the Configpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigpointMutation) OldStatusTransaction(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusTransaction is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusTransaction requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusTransaction: %w", err)
	}
	return oldValue.StatusTransaction, nil
}

// ClearStatusTransaction clears the value of the "StatusTransaction" field.
func (m *ConfigpointMutation) ClearStatusTransaction() {
	m._StatusTransaction = nil
	m.clearedFields[configpoint.FieldStatusTransaction] = struct{}{}
}

// StatusTransactionCleared returns if the "StatusTransaction" field was cleared in this mutation.
func (m *ConfigpointMutation) StatusTransactionCleared() bool {
	_, ok := m.clearedFields[configpoint.FieldStatusTransaction]
	return ok
}

// ResetStatusTransaction resets all changes to the "StatusTransaction" field.
func (m *ConfigpointMutation) ResetStatusTransaction() {
	m._StatusTransaction = nil
	delete(m.clearedFields, configpoint.FieldStatusTransaction)
}

// Op returns the operation name.
func (m *ConfigpointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Configpoint).
func (m *ConfigpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigpointMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._TransactionName != nil {
		fields = append(fields, configpoint.FieldTransactionName)
	}
	if m._TransactionType != nil {
		fields = append(fields, configpoint.FieldTransactionType)
	}
	if m._PaymentChannel != nil {
		fields = append(fields, configpoint.FieldPaymentChannel)
	}
	if m._PaymentType != nil {
		fields = append(fields, configpoint.FieldPaymentType)
	}
	if m._DummyWallet != nil {
		fields = append(fields, configpoint.FieldDummyWallet)
	}
	if m._Amount != nil {
		fields = append(fields, configpoint.FieldAmount)
	}
	if m._Point != nil {
		fields = append(fields, configpoint.FieldPoint)
	}
	if m._Expire != nil {
		fields = append(fields, configpoint.FieldExpire)
	}
	if m._UpdateDate != nil {
		fields = append(fields, configpoint.FieldUpdateDate)
	}
	if m._ExpireDate != nil {
		fields = append(fields, configpoint.FieldExpireDate)
	}
	if m._StatusTransaction != nil {
		fields = append(fields, configpoint.FieldStatusTransaction)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configpoint.FieldTransactionName:
		return m.TransactionName()
	case configpoint.FieldTransactionType:
		return m.TransactionType()
	case configpoint.FieldPaymentChannel:
		return m.PaymentChannel()
	case configpoint.FieldPaymentType:
		return m.PaymentType()
	case configpoint.FieldDummyWallet:
		return m.DummyWallet()
	case configpoint.FieldAmount:
		return m.Amount()
	case configpoint.FieldPoint:
		return m.Point()
	case configpoint.FieldExpire:
		return m.Expire()
	case configpoint.FieldUpdateDate:
		return m.UpdateDate()
	case configpoint.FieldExpireDate:
		return m.ExpireDate()
	case configpoint.FieldStatusTransaction:
		return m.StatusTransaction()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configpoint.FieldTransactionName:
		return m.OldTransactionName(ctx)
	case configpoint.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case configpoint.FieldPaymentChannel:
		return m.OldPaymentChannel(ctx)
	case configpoint.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case configpoint.FieldDummyWallet:
		return m.OldDummyWallet(ctx)
	case configpoint.FieldAmount:
		return m.OldAmount(ctx)
	case configpoint.FieldPoint:
		return m.OldPoint(ctx)
	case configpoint.FieldExpire:
		return m.OldExpire(ctx)
	case configpoint.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	case configpoint.FieldExpireDate:
		return m.OldExpireDate(ctx)
	case configpoint.FieldStatusTransaction:
		return m.OldStatusTransaction(ctx)
	}
	return nil, fmt.Errorf("unknown Configpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configpoint.FieldTransactionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionName(v)
		return nil
	case configpoint.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case configpoint.FieldPaymentChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentChannel(v)
		return nil
	case configpoint.FieldPaymentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case configpoint.FieldDummyWallet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDummyWallet(v)
		return nil
	case configpoint.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case configpoint.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case configpoint.FieldExpire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpire(v)
		return nil
	case configpoint.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	case configpoint.FieldExpireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpireDate(v)
		return nil
	case configpoint.FieldStatusTransaction:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusTransaction(v)
		return nil
	}
	return fmt.Errorf("unknown Configpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigpointMutation) AddedFields() []string {
	var fields []string
	if m.add_Amount != nil {
		fields = append(fields, configpoint.FieldAmount)
	}
	if m.add_Point != nil {
		fields = append(fields, configpoint.FieldPoint)
	}
	if m.add_Expire != nil {
		fields = append(fields, configpoint.FieldExpire)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigpointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configpoint.FieldAmount:
		return m.AddedAmount()
	case configpoint.FieldPoint:
		return m.AddedPoint()
	case configpoint.FieldExpire:
		return m.AddedExpire()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configpoint.FieldAmount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case configpoint.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case configpoint.FieldExpire:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpire(v)
		return nil
	}
	return fmt.Errorf("unknown Configpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configpoint.FieldTransactionName) {
		fields = append(fields, configpoint.FieldTransactionName)
	}
	if m.FieldCleared(configpoint.FieldTransactionType) {
		fields = append(fields, configpoint.FieldTransactionType)
	}
	if m.FieldCleared(configpoint.FieldPaymentChannel) {
		fields = append(fields, configpoint.FieldPaymentChannel)
	}
	if m.FieldCleared(configpoint.FieldPaymentType) {
		fields = append(fields, configpoint.FieldPaymentType)
	}
	if m.FieldCleared(configpoint.FieldDummyWallet) {
		fields = append(fields, configpoint.FieldDummyWallet)
	}
	if m.FieldCleared(configpoint.FieldAmount) {
		fields = append(fields, configpoint.FieldAmount)
	}
	if m.FieldCleared(configpoint.FieldPoint) {
		fields = append(fields, configpoint.FieldPoint)
	}
	if m.FieldCleared(configpoint.FieldExpire) {
		fields = append(fields, configpoint.FieldExpire)
	}
	if m.FieldCleared(configpoint.FieldUpdateDate) {
		fields = append(fields, configpoint.FieldUpdateDate)
	}
	if m.FieldCleared(configpoint.FieldExpireDate) {
		fields = append(fields, configpoint.FieldExpireDate)
	}
	if m.FieldCleared(configpoint.FieldStatusTransaction) {
		fields = append(fields, configpoint.FieldStatusTransaction)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigpointMutation) ClearField(name string) error {
	switch name {
	case configpoint.FieldTransactionName:
		m.ClearTransactionName()
		return nil
	case configpoint.FieldTransactionType:
		m.ClearTransactionType()
		return nil
	case configpoint.FieldPaymentChannel:
		m.ClearPaymentChannel()
		return nil
	case configpoint.FieldPaymentType:
		m.ClearPaymentType()
		return nil
	case configpoint.FieldDummyWallet:
		m.ClearDummyWallet()
		return nil
	case configpoint.FieldAmount:
		m.ClearAmount()
		return nil
	case configpoint.FieldPoint:
		m.ClearPoint()
		return nil
	case configpoint.FieldExpire:
		m.ClearExpire()
		return nil
	case configpoint.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	case configpoint.FieldExpireDate:
		m.ClearExpireDate()
		return nil
	case configpoint.FieldStatusTransaction:
		m.ClearStatusTransaction()
		return nil
	}
	return fmt.Errorf("unknown Configpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigpointMutation) ResetField(name string) error {
	switch name {
	case configpoint.FieldTransactionName:
		m.ResetTransactionName()
		return nil
	case configpoint.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case configpoint.FieldPaymentChannel:
		m.ResetPaymentChannel()
		return nil
	case configpoint.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case configpoint.FieldDummyWallet:
		m.ResetDummyWallet()
		return nil
	case configpoint.FieldAmount:
		m.ResetAmount()
		return nil
	case configpoint.FieldPoint:
		m.ResetPoint()
		return nil
	case configpoint.FieldExpire:
		m.ResetExpire()
		return nil
	case configpoint.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	case configpoint.FieldExpireDate:
		m.ResetExpireDate()
		return nil
	case configpoint.FieldStatusTransaction:
		m.ResetStatusTransaction()
		return nil
	}
	return fmt.Errorf("unknown Configpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigpointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigpointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigpointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Configpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigpointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Configpoint edge %s", name)
}

// ConsumerMutation represents an operation that mutates the Consumer nodes in the graph.
type ConsumerMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	transaction_id       *string
	_TransactionStatus   *string
	_TransactionType     *string
	_PaymentChannel      *string
	_PaymentType         *string
	_TypeCode            *string
	_ApprovalCode        *string
	_BillerID            *string
	ref1                 *string
	ref2                 *string
	ref3                 *string
	amount               *float64
	addamount            *float64
	fee                  *float64
	addfee               *float64
	total                *float64
	addtotal             *float64
	_FromReference       *string
	_FromPhoneNo         *string
	_FromName            *string
	_ToAccount           *string
	_ToAccountPhoneNo    *string
	_ToAccountName       *string
	_BankCode            *string
	_TerminalId          *string
	_TerminalType        *string
	_ToAccount105        *string
	_FromReference105    *string
	dateTime             *time.Time
	_PartnerRef          *string
	_ResponseCode        *string
	_ResponseDescription *string
	_FileimportID        *int
	add_FileimportID     *int
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*Consumer, error)
	predicates           []predicate.Consumer
}

var _ ent.Mutation = (*ConsumerMutation)(nil)

// consumerOption allows management of the mutation configuration using functional options.
type consumerOption func(*ConsumerMutation)

// newConsumerMutation creates new mutation for the Consumer entity.
func newConsumerMutation(c config, op Op, opts ...consumerOption) *ConsumerMutation {
	m := &ConsumerMutation{
		config:        c,
		op:            op,
		typ:           TypeConsumer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsumerID sets the ID field of the mutation.
func withConsumerID(id int) consumerOption {
	return func(m *ConsumerMutation) {
		var (
			err   error
			once  sync.Once
			value *Consumer
		)
		m.oldValue = func(ctx context.Context) (*Consumer, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Consumer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsumer sets the old Consumer of the mutation.
func withConsumer(node *Consumer) consumerOption {
	return func(m *ConsumerMutation) {
		m.oldValue = func(context.Context) (*Consumer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsumerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsumerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Consumer entities.
func (m *ConsumerMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ConsumerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTransactionID sets the "transaction_id" field.
func (m *ConsumerMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *ConsumerMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTransactionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *ConsumerMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[consumer.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *ConsumerMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *ConsumerMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, consumer.FieldTransactionID)
}

// SetTransactionStatus sets the "TransactionStatus" field.
func (m *ConsumerMutation) SetTransactionStatus(s string) {
	m._TransactionStatus = &s
}

// TransactionStatus returns the value of the "TransactionStatus" field in the mutation.
func (m *ConsumerMutation) TransactionStatus() (r string, exists bool) {
	v := m._TransactionStatus
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionStatus returns the old "TransactionStatus" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTransactionStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionStatus: %w", err)
	}
	return oldValue.TransactionStatus, nil
}

// ClearTransactionStatus clears the value of the "TransactionStatus" field.
func (m *ConsumerMutation) ClearTransactionStatus() {
	m._TransactionStatus = nil
	m.clearedFields[consumer.FieldTransactionStatus] = struct{}{}
}

// TransactionStatusCleared returns if the "TransactionStatus" field was cleared in this mutation.
func (m *ConsumerMutation) TransactionStatusCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTransactionStatus]
	return ok
}

// ResetTransactionStatus resets all changes to the "TransactionStatus" field.
func (m *ConsumerMutation) ResetTransactionStatus() {
	m._TransactionStatus = nil
	delete(m.clearedFields, consumer.FieldTransactionStatus)
}

// SetTransactionType sets the "TransactionType" field.
func (m *ConsumerMutation) SetTransactionType(s string) {
	m._TransactionType = &s
}

// TransactionType returns the value of the "TransactionType" field in the mutation.
func (m *ConsumerMutation) TransactionType() (r string, exists bool) {
	v := m._TransactionType
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "TransactionType" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTransactionType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ClearTransactionType clears the value of the "TransactionType" field.
func (m *ConsumerMutation) ClearTransactionType() {
	m._TransactionType = nil
	m.clearedFields[consumer.FieldTransactionType] = struct{}{}
}

// TransactionTypeCleared returns if the "TransactionType" field was cleared in this mutation.
func (m *ConsumerMutation) TransactionTypeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTransactionType]
	return ok
}

// ResetTransactionType resets all changes to the "TransactionType" field.
func (m *ConsumerMutation) ResetTransactionType() {
	m._TransactionType = nil
	delete(m.clearedFields, consumer.FieldTransactionType)
}

// SetPaymentChannel sets the "PaymentChannel" field.
func (m *ConsumerMutation) SetPaymentChannel(s string) {
	m._PaymentChannel = &s
}

// PaymentChannel returns the value of the "PaymentChannel" field in the mutation.
func (m *ConsumerMutation) PaymentChannel() (r string, exists bool) {
	v := m._PaymentChannel
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentChannel returns the old "PaymentChannel" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldPaymentChannel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentChannel: %w", err)
	}
	return oldValue.PaymentChannel, nil
}

// ClearPaymentChannel clears the value of the "PaymentChannel" field.
func (m *ConsumerMutation) ClearPaymentChannel() {
	m._PaymentChannel = nil
	m.clearedFields[consumer.FieldPaymentChannel] = struct{}{}
}

// PaymentChannelCleared returns if the "PaymentChannel" field was cleared in this mutation.
func (m *ConsumerMutation) PaymentChannelCleared() bool {
	_, ok := m.clearedFields[consumer.FieldPaymentChannel]
	return ok
}

// ResetPaymentChannel resets all changes to the "PaymentChannel" field.
func (m *ConsumerMutation) ResetPaymentChannel() {
	m._PaymentChannel = nil
	delete(m.clearedFields, consumer.FieldPaymentChannel)
}

// SetPaymentType sets the "PaymentType" field.
func (m *ConsumerMutation) SetPaymentType(s string) {
	m._PaymentType = &s
}

// PaymentType returns the value of the "PaymentType" field in the mutation.
func (m *ConsumerMutation) PaymentType() (r string, exists bool) {
	v := m._PaymentType
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "PaymentType" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldPaymentType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ClearPaymentType clears the value of the "PaymentType" field.
func (m *ConsumerMutation) ClearPaymentType() {
	m._PaymentType = nil
	m.clearedFields[consumer.FieldPaymentType] = struct{}{}
}

// PaymentTypeCleared returns if the "PaymentType" field was cleared in this mutation.
func (m *ConsumerMutation) PaymentTypeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldPaymentType]
	return ok
}

// ResetPaymentType resets all changes to the "PaymentType" field.
func (m *ConsumerMutation) ResetPaymentType() {
	m._PaymentType = nil
	delete(m.clearedFields, consumer.FieldPaymentType)
}

// SetTypeCode sets the "TypeCode" field.
func (m *ConsumerMutation) SetTypeCode(s string) {
	m._TypeCode = &s
}

// TypeCode returns the value of the "TypeCode" field in the mutation.
func (m *ConsumerMutation) TypeCode() (r string, exists bool) {
	v := m._TypeCode
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeCode returns the old "TypeCode" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTypeCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeCode: %w", err)
	}
	return oldValue.TypeCode, nil
}

// ClearTypeCode clears the value of the "TypeCode" field.
func (m *ConsumerMutation) ClearTypeCode() {
	m._TypeCode = nil
	m.clearedFields[consumer.FieldTypeCode] = struct{}{}
}

// TypeCodeCleared returns if the "TypeCode" field was cleared in this mutation.
func (m *ConsumerMutation) TypeCodeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTypeCode]
	return ok
}

// ResetTypeCode resets all changes to the "TypeCode" field.
func (m *ConsumerMutation) ResetTypeCode() {
	m._TypeCode = nil
	delete(m.clearedFields, consumer.FieldTypeCode)
}

// SetApprovalCode sets the "ApprovalCode" field.
func (m *ConsumerMutation) SetApprovalCode(s string) {
	m._ApprovalCode = &s
}

// ApprovalCode returns the value of the "ApprovalCode" field in the mutation.
func (m *ConsumerMutation) ApprovalCode() (r string, exists bool) {
	v := m._ApprovalCode
	if v == nil {
		return
	}
	return *v, true
}

// OldApprovalCode returns the old "ApprovalCode" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldApprovalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApprovalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApprovalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApprovalCode: %w", err)
	}
	return oldValue.ApprovalCode, nil
}

// ClearApprovalCode clears the value of the "ApprovalCode" field.
func (m *ConsumerMutation) ClearApprovalCode() {
	m._ApprovalCode = nil
	m.clearedFields[consumer.FieldApprovalCode] = struct{}{}
}

// ApprovalCodeCleared returns if the "ApprovalCode" field was cleared in this mutation.
func (m *ConsumerMutation) ApprovalCodeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldApprovalCode]
	return ok
}

// ResetApprovalCode resets all changes to the "ApprovalCode" field.
func (m *ConsumerMutation) ResetApprovalCode() {
	m._ApprovalCode = nil
	delete(m.clearedFields, consumer.FieldApprovalCode)
}

// SetBillerID sets the "BillerID" field.
func (m *ConsumerMutation) SetBillerID(s string) {
	m._BillerID = &s
}

// BillerID returns the value of the "BillerID" field in the mutation.
func (m *ConsumerMutation) BillerID() (r string, exists bool) {
	v := m._BillerID
	if v == nil {
		return
	}
	return *v, true
}

// OldBillerID returns the old "BillerID" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldBillerID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBillerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBillerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBillerID: %w", err)
	}
	return oldValue.BillerID, nil
}

// ClearBillerID clears the value of the "BillerID" field.
func (m *ConsumerMutation) ClearBillerID() {
	m._BillerID = nil
	m.clearedFields[consumer.FieldBillerID] = struct{}{}
}

// BillerIDCleared returns if the "BillerID" field was cleared in this mutation.
func (m *ConsumerMutation) BillerIDCleared() bool {
	_, ok := m.clearedFields[consumer.FieldBillerID]
	return ok
}

// ResetBillerID resets all changes to the "BillerID" field.
func (m *ConsumerMutation) ResetBillerID() {
	m._BillerID = nil
	delete(m.clearedFields, consumer.FieldBillerID)
}

// SetRef1 sets the "ref1" field.
func (m *ConsumerMutation) SetRef1(s string) {
	m.ref1 = &s
}

// Ref1 returns the value of the "ref1" field in the mutation.
func (m *ConsumerMutation) Ref1() (r string, exists bool) {
	v := m.ref1
	if v == nil {
		return
	}
	return *v, true
}

// OldRef1 returns the old "ref1" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldRef1(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRef1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRef1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef1: %w", err)
	}
	return oldValue.Ref1, nil
}

// ClearRef1 clears the value of the "ref1" field.
func (m *ConsumerMutation) ClearRef1() {
	m.ref1 = nil
	m.clearedFields[consumer.FieldRef1] = struct{}{}
}

// Ref1Cleared returns if the "ref1" field was cleared in this mutation.
func (m *ConsumerMutation) Ref1Cleared() bool {
	_, ok := m.clearedFields[consumer.FieldRef1]
	return ok
}

// ResetRef1 resets all changes to the "ref1" field.
func (m *ConsumerMutation) ResetRef1() {
	m.ref1 = nil
	delete(m.clearedFields, consumer.FieldRef1)
}

// SetRef2 sets the "ref2" field.
func (m *ConsumerMutation) SetRef2(s string) {
	m.ref2 = &s
}

// Ref2 returns the value of the "ref2" field in the mutation.
func (m *ConsumerMutation) Ref2() (r string, exists bool) {
	v := m.ref2
	if v == nil {
		return
	}
	return *v, true
}

// OldRef2 returns the old "ref2" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldRef2(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRef2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRef2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef2: %w", err)
	}
	return oldValue.Ref2, nil
}

// ClearRef2 clears the value of the "ref2" field.
func (m *ConsumerMutation) ClearRef2() {
	m.ref2 = nil
	m.clearedFields[consumer.FieldRef2] = struct{}{}
}

// Ref2Cleared returns if the "ref2" field was cleared in this mutation.
func (m *ConsumerMutation) Ref2Cleared() bool {
	_, ok := m.clearedFields[consumer.FieldRef2]
	return ok
}

// ResetRef2 resets all changes to the "ref2" field.
func (m *ConsumerMutation) ResetRef2() {
	m.ref2 = nil
	delete(m.clearedFields, consumer.FieldRef2)
}

// SetRef3 sets the "ref3" field.
func (m *ConsumerMutation) SetRef3(s string) {
	m.ref3 = &s
}

// Ref3 returns the value of the "ref3" field in the mutation.
func (m *ConsumerMutation) Ref3() (r string, exists bool) {
	v := m.ref3
	if v == nil {
		return
	}
	return *v, true
}

// OldRef3 returns the old "ref3" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldRef3(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRef3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRef3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef3: %w", err)
	}
	return oldValue.Ref3, nil
}

// ClearRef3 clears the value of the "ref3" field.
func (m *ConsumerMutation) ClearRef3() {
	m.ref3 = nil
	m.clearedFields[consumer.FieldRef3] = struct{}{}
}

// Ref3Cleared returns if the "ref3" field was cleared in this mutation.
func (m *ConsumerMutation) Ref3Cleared() bool {
	_, ok := m.clearedFields[consumer.FieldRef3]
	return ok
}

// ResetRef3 resets all changes to the "ref3" field.
func (m *ConsumerMutation) ResetRef3() {
	m.ref3 = nil
	delete(m.clearedFields, consumer.FieldRef3)
}

// SetAmount sets the "amount" field.
func (m *ConsumerMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *ConsumerMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *ConsumerMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *ConsumerMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *ConsumerMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[consumer.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *ConsumerMutation) AmountCleared() bool {
	_, ok := m.clearedFields[consumer.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *ConsumerMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, consumer.FieldAmount)
}

// SetFee sets the "fee" field.
func (m *ConsumerMutation) SetFee(f float64) {
	m.fee = &f
	m.addfee = nil
}

// Fee returns the value of the "fee" field in the mutation.
func (m *ConsumerMutation) Fee() (r float64, exists bool) {
	v := m.fee
	if v == nil {
		return
	}
	return *v, true
}

// OldFee returns the old "fee" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFee(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFee: %w", err)
	}
	return oldValue.Fee, nil
}

// AddFee adds f to the "fee" field.
func (m *ConsumerMutation) AddFee(f float64) {
	if m.addfee != nil {
		*m.addfee += f
	} else {
		m.addfee = &f
	}
}

// AddedFee returns the value that was added to the "fee" field in this mutation.
func (m *ConsumerMutation) AddedFee() (r float64, exists bool) {
	v := m.addfee
	if v == nil {
		return
	}
	return *v, true
}

// ClearFee clears the value of the "fee" field.
func (m *ConsumerMutation) ClearFee() {
	m.fee = nil
	m.addfee = nil
	m.clearedFields[consumer.FieldFee] = struct{}{}
}

// FeeCleared returns if the "fee" field was cleared in this mutation.
func (m *ConsumerMutation) FeeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldFee]
	return ok
}

// ResetFee resets all changes to the "fee" field.
func (m *ConsumerMutation) ResetFee() {
	m.fee = nil
	m.addfee = nil
	delete(m.clearedFields, consumer.FieldFee)
}

// SetTotal sets the "total" field.
func (m *ConsumerMutation) SetTotal(f float64) {
	m.total = &f
	m.addtotal = nil
}

// Total returns the value of the "total" field in the mutation.
func (m *ConsumerMutation) Total() (r float64, exists bool) {
	v := m.total
	if v == nil {
		return
	}
	return *v, true
}

// OldTotal returns the old "total" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTotal(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotal: %w", err)
	}
	return oldValue.Total, nil
}

// AddTotal adds f to the "total" field.
func (m *ConsumerMutation) AddTotal(f float64) {
	if m.addtotal != nil {
		*m.addtotal += f
	} else {
		m.addtotal = &f
	}
}

// AddedTotal returns the value that was added to the "total" field in this mutation.
func (m *ConsumerMutation) AddedTotal() (r float64, exists bool) {
	v := m.addtotal
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotal clears the value of the "total" field.
func (m *ConsumerMutation) ClearTotal() {
	m.total = nil
	m.addtotal = nil
	m.clearedFields[consumer.FieldTotal] = struct{}{}
}

// TotalCleared returns if the "total" field was cleared in this mutation.
func (m *ConsumerMutation) TotalCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTotal]
	return ok
}

// ResetTotal resets all changes to the "total" field.
func (m *ConsumerMutation) ResetTotal() {
	m.total = nil
	m.addtotal = nil
	delete(m.clearedFields, consumer.FieldTotal)
}

// SetFromReference sets the "FromReference" field.
func (m *ConsumerMutation) SetFromReference(s string) {
	m._FromReference = &s
}

// FromReference returns the value of the "FromReference" field in the mutation.
func (m *ConsumerMutation) FromReference() (r string, exists bool) {
	v := m._FromReference
	if v == nil {
		return
	}
	return *v, true
}

// OldFromReference returns the old "FromReference" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFromReference(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromReference: %w", err)
	}
	return oldValue.FromReference, nil
}

// ClearFromReference clears the value of the "FromReference" field.
func (m *ConsumerMutation) ClearFromReference() {
	m._FromReference = nil
	m.clearedFields[consumer.FieldFromReference] = struct{}{}
}

// FromReferenceCleared returns if the "FromReference" field was cleared in this mutation.
func (m *ConsumerMutation) FromReferenceCleared() bool {
	_, ok := m.clearedFields[consumer.FieldFromReference]
	return ok
}

// ResetFromReference resets all changes to the "FromReference" field.
func (m *ConsumerMutation) ResetFromReference() {
	m._FromReference = nil
	delete(m.clearedFields, consumer.FieldFromReference)
}

// SetFromPhoneNo sets the "FromPhoneNo" field.
func (m *ConsumerMutation) SetFromPhoneNo(s string) {
	m._FromPhoneNo = &s
}

// FromPhoneNo returns the value of the "FromPhoneNo" field in the mutation.
func (m *ConsumerMutation) FromPhoneNo() (r string, exists bool) {
	v := m._FromPhoneNo
	if v == nil {
		return
	}
	return *v, true
}

// OldFromPhoneNo returns the old "FromPhoneNo" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFromPhoneNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromPhoneNo: %w", err)
	}
	return oldValue.FromPhoneNo, nil
}

// ClearFromPhoneNo clears the value of the "FromPhoneNo" field.
func (m *ConsumerMutation) ClearFromPhoneNo() {
	m._FromPhoneNo = nil
	m.clearedFields[consumer.FieldFromPhoneNo] = struct{}{}
}

// FromPhoneNoCleared returns if the "FromPhoneNo" field was cleared in this mutation.
func (m *ConsumerMutation) FromPhoneNoCleared() bool {
	_, ok := m.clearedFields[consumer.FieldFromPhoneNo]
	return ok
}

// ResetFromPhoneNo resets all changes to the "FromPhoneNo" field.
func (m *ConsumerMutation) ResetFromPhoneNo() {
	m._FromPhoneNo = nil
	delete(m.clearedFields, consumer.FieldFromPhoneNo)
}

// SetFromName sets the "FromName" field.
func (m *ConsumerMutation) SetFromName(s string) {
	m._FromName = &s
}

// FromName returns the value of the "FromName" field in the mutation.
func (m *ConsumerMutation) FromName() (r string, exists bool) {
	v := m._FromName
	if v == nil {
		return
	}
	return *v, true
}

// OldFromName returns the old "FromName" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFromName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromName: %w", err)
	}
	return oldValue.FromName, nil
}

// ClearFromName clears the value of the "FromName" field.
func (m *ConsumerMutation) ClearFromName() {
	m._FromName = nil
	m.clearedFields[consumer.FieldFromName] = struct{}{}
}

// FromNameCleared returns if the "FromName" field was cleared in this mutation.
func (m *ConsumerMutation) FromNameCleared() bool {
	_, ok := m.clearedFields[consumer.FieldFromName]
	return ok
}

// ResetFromName resets all changes to the "FromName" field.
func (m *ConsumerMutation) ResetFromName() {
	m._FromName = nil
	delete(m.clearedFields, consumer.FieldFromName)
}

// SetToAccount sets the "ToAccount" field.
func (m *ConsumerMutation) SetToAccount(s string) {
	m._ToAccount = &s
}

// ToAccount returns the value of the "ToAccount" field in the mutation.
func (m *ConsumerMutation) ToAccount() (r string, exists bool) {
	v := m._ToAccount
	if v == nil {
		return
	}
	return *v, true
}

// OldToAccount returns the old "ToAccount" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldToAccount(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAccount: %w", err)
	}
	return oldValue.ToAccount, nil
}

// ClearToAccount clears the value of the "ToAccount" field.
func (m *ConsumerMutation) ClearToAccount() {
	m._ToAccount = nil
	m.clearedFields[consumer.FieldToAccount] = struct{}{}
}

// ToAccountCleared returns if the "ToAccount" field was cleared in this mutation.
func (m *ConsumerMutation) ToAccountCleared() bool {
	_, ok := m.clearedFields[consumer.FieldToAccount]
	return ok
}

// ResetToAccount resets all changes to the "ToAccount" field.
func (m *ConsumerMutation) ResetToAccount() {
	m._ToAccount = nil
	delete(m.clearedFields, consumer.FieldToAccount)
}

// SetToAccountPhoneNo sets the "ToAccountPhoneNo" field.
func (m *ConsumerMutation) SetToAccountPhoneNo(s string) {
	m._ToAccountPhoneNo = &s
}

// ToAccountPhoneNo returns the value of the "ToAccountPhoneNo" field in the mutation.
func (m *ConsumerMutation) ToAccountPhoneNo() (r string, exists bool) {
	v := m._ToAccountPhoneNo
	if v == nil {
		return
	}
	return *v, true
}

// OldToAccountPhoneNo returns the old "ToAccountPhoneNo" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldToAccountPhoneNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToAccountPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToAccountPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAccountPhoneNo: %w", err)
	}
	return oldValue.ToAccountPhoneNo, nil
}

// ClearToAccountPhoneNo clears the value of the "ToAccountPhoneNo" field.
func (m *ConsumerMutation) ClearToAccountPhoneNo() {
	m._ToAccountPhoneNo = nil
	m.clearedFields[consumer.FieldToAccountPhoneNo] = struct{}{}
}

// ToAccountPhoneNoCleared returns if the "ToAccountPhoneNo" field was cleared in this mutation.
func (m *ConsumerMutation) ToAccountPhoneNoCleared() bool {
	_, ok := m.clearedFields[consumer.FieldToAccountPhoneNo]
	return ok
}

// ResetToAccountPhoneNo resets all changes to the "ToAccountPhoneNo" field.
func (m *ConsumerMutation) ResetToAccountPhoneNo() {
	m._ToAccountPhoneNo = nil
	delete(m.clearedFields, consumer.FieldToAccountPhoneNo)
}

// SetToAccountName sets the "ToAccountName" field.
func (m *ConsumerMutation) SetToAccountName(s string) {
	m._ToAccountName = &s
}

// ToAccountName returns the value of the "ToAccountName" field in the mutation.
func (m *ConsumerMutation) ToAccountName() (r string, exists bool) {
	v := m._ToAccountName
	if v == nil {
		return
	}
	return *v, true
}

// OldToAccountName returns the old "ToAccountName" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldToAccountName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToAccountName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToAccountName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAccountName: %w", err)
	}
	return oldValue.ToAccountName, nil
}

// ClearToAccountName clears the value of the "ToAccountName" field.
func (m *ConsumerMutation) ClearToAccountName() {
	m._ToAccountName = nil
	m.clearedFields[consumer.FieldToAccountName] = struct{}{}
}

// ToAccountNameCleared returns if the "ToAccountName" field was cleared in this mutation.
func (m *ConsumerMutation) ToAccountNameCleared() bool {
	_, ok := m.clearedFields[consumer.FieldToAccountName]
	return ok
}

// ResetToAccountName resets all changes to the "ToAccountName" field.
func (m *ConsumerMutation) ResetToAccountName() {
	m._ToAccountName = nil
	delete(m.clearedFields, consumer.FieldToAccountName)
}

// SetBankCode sets the "BankCode" field.
func (m *ConsumerMutation) SetBankCode(s string) {
	m._BankCode = &s
}

// BankCode returns the value of the "BankCode" field in the mutation.
func (m *ConsumerMutation) BankCode() (r string, exists bool) {
	v := m._BankCode
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCode returns the old "BankCode" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldBankCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCode: %w", err)
	}
	return oldValue.BankCode, nil
}

// ClearBankCode clears the value of the "BankCode" field.
func (m *ConsumerMutation) ClearBankCode() {
	m._BankCode = nil
	m.clearedFields[consumer.FieldBankCode] = struct{}{}
}

// BankCodeCleared returns if the "BankCode" field was cleared in this mutation.
func (m *ConsumerMutation) BankCodeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldBankCode]
	return ok
}

// ResetBankCode resets all changes to the "BankCode" field.
func (m *ConsumerMutation) ResetBankCode() {
	m._BankCode = nil
	delete(m.clearedFields, consumer.FieldBankCode)
}

// SetTerminalId sets the "TerminalId" field.
func (m *ConsumerMutation) SetTerminalId(s string) {
	m._TerminalId = &s
}

// TerminalId returns the value of the "TerminalId" field in the mutation.
func (m *ConsumerMutation) TerminalId() (r string, exists bool) {
	v := m._TerminalId
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminalId returns the old "TerminalId" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTerminalId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerminalId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerminalId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminalId: %w", err)
	}
	return oldValue.TerminalId, nil
}

// ClearTerminalId clears the value of the "TerminalId" field.
func (m *ConsumerMutation) ClearTerminalId() {
	m._TerminalId = nil
	m.clearedFields[consumer.FieldTerminalId] = struct{}{}
}

// TerminalIdCleared returns if the "TerminalId" field was cleared in this mutation.
func (m *ConsumerMutation) TerminalIdCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTerminalId]
	return ok
}

// ResetTerminalId resets all changes to the "TerminalId" field.
func (m *ConsumerMutation) ResetTerminalId() {
	m._TerminalId = nil
	delete(m.clearedFields, consumer.FieldTerminalId)
}

// SetTerminalType sets the "TerminalType" field.
func (m *ConsumerMutation) SetTerminalType(s string) {
	m._TerminalType = &s
}

// TerminalType returns the value of the "TerminalType" field in the mutation.
func (m *ConsumerMutation) TerminalType() (r string, exists bool) {
	v := m._TerminalType
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminalType returns the old "TerminalType" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldTerminalType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerminalType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerminalType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminalType: %w", err)
	}
	return oldValue.TerminalType, nil
}

// ClearTerminalType clears the value of the "TerminalType" field.
func (m *ConsumerMutation) ClearTerminalType() {
	m._TerminalType = nil
	m.clearedFields[consumer.FieldTerminalType] = struct{}{}
}

// TerminalTypeCleared returns if the "TerminalType" field was cleared in this mutation.
func (m *ConsumerMutation) TerminalTypeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldTerminalType]
	return ok
}

// ResetTerminalType resets all changes to the "TerminalType" field.
func (m *ConsumerMutation) ResetTerminalType() {
	m._TerminalType = nil
	delete(m.clearedFields, consumer.FieldTerminalType)
}

// SetToAccount105 sets the "ToAccount105" field.
func (m *ConsumerMutation) SetToAccount105(s string) {
	m._ToAccount105 = &s
}

// ToAccount105 returns the value of the "ToAccount105" field in the mutation.
func (m *ConsumerMutation) ToAccount105() (r string, exists bool) {
	v := m._ToAccount105
	if v == nil {
		return
	}
	return *v, true
}

// OldToAccount105 returns the old "ToAccount105" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldToAccount105(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToAccount105 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToAccount105 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToAccount105: %w", err)
	}
	return oldValue.ToAccount105, nil
}

// ClearToAccount105 clears the value of the "ToAccount105" field.
func (m *ConsumerMutation) ClearToAccount105() {
	m._ToAccount105 = nil
	m.clearedFields[consumer.FieldToAccount105] = struct{}{}
}

// ToAccount105Cleared returns if the "ToAccount105" field was cleared in this mutation.
func (m *ConsumerMutation) ToAccount105Cleared() bool {
	_, ok := m.clearedFields[consumer.FieldToAccount105]
	return ok
}

// ResetToAccount105 resets all changes to the "ToAccount105" field.
func (m *ConsumerMutation) ResetToAccount105() {
	m._ToAccount105 = nil
	delete(m.clearedFields, consumer.FieldToAccount105)
}

// SetFromReference105 sets the "FromReference105" field.
func (m *ConsumerMutation) SetFromReference105(s string) {
	m._FromReference105 = &s
}

// FromReference105 returns the value of the "FromReference105" field in the mutation.
func (m *ConsumerMutation) FromReference105() (r string, exists bool) {
	v := m._FromReference105
	if v == nil {
		return
	}
	return *v, true
}

// OldFromReference105 returns the old "FromReference105" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFromReference105(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromReference105 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromReference105 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromReference105: %w", err)
	}
	return oldValue.FromReference105, nil
}

// ClearFromReference105 clears the value of the "FromReference105" field.
func (m *ConsumerMutation) ClearFromReference105() {
	m._FromReference105 = nil
	m.clearedFields[consumer.FieldFromReference105] = struct{}{}
}

// FromReference105Cleared returns if the "FromReference105" field was cleared in this mutation.
func (m *ConsumerMutation) FromReference105Cleared() bool {
	_, ok := m.clearedFields[consumer.FieldFromReference105]
	return ok
}

// ResetFromReference105 resets all changes to the "FromReference105" field.
func (m *ConsumerMutation) ResetFromReference105() {
	m._FromReference105 = nil
	delete(m.clearedFields, consumer.FieldFromReference105)
}

// SetDateTime sets the "dateTime" field.
func (m *ConsumerMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *ConsumerMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *ConsumerMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[consumer.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *ConsumerMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *ConsumerMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, consumer.FieldDateTime)
}

// SetPartnerRef sets the "PartnerRef" field.
func (m *ConsumerMutation) SetPartnerRef(s string) {
	m._PartnerRef = &s
}

// PartnerRef returns the value of the "PartnerRef" field in the mutation.
func (m *ConsumerMutation) PartnerRef() (r string, exists bool) {
	v := m._PartnerRef
	if v == nil {
		return
	}
	return *v, true
}

// OldPartnerRef returns the old "PartnerRef" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldPartnerRef(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPartnerRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPartnerRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartnerRef: %w", err)
	}
	return oldValue.PartnerRef, nil
}

// ClearPartnerRef clears the value of the "PartnerRef" field.
func (m *ConsumerMutation) ClearPartnerRef() {
	m._PartnerRef = nil
	m.clearedFields[consumer.FieldPartnerRef] = struct{}{}
}

// PartnerRefCleared returns if the "PartnerRef" field was cleared in this mutation.
func (m *ConsumerMutation) PartnerRefCleared() bool {
	_, ok := m.clearedFields[consumer.FieldPartnerRef]
	return ok
}

// ResetPartnerRef resets all changes to the "PartnerRef" field.
func (m *ConsumerMutation) ResetPartnerRef() {
	m._PartnerRef = nil
	delete(m.clearedFields, consumer.FieldPartnerRef)
}

// SetResponseCode sets the "ResponseCode" field.
func (m *ConsumerMutation) SetResponseCode(s string) {
	m._ResponseCode = &s
}

// ResponseCode returns the value of the "ResponseCode" field in the mutation.
func (m *ConsumerMutation) ResponseCode() (r string, exists bool) {
	v := m._ResponseCode
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseCode returns the old "ResponseCode" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldResponseCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResponseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResponseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseCode: %w", err)
	}
	return oldValue.ResponseCode, nil
}

// ClearResponseCode clears the value of the "ResponseCode" field.
func (m *ConsumerMutation) ClearResponseCode() {
	m._ResponseCode = nil
	m.clearedFields[consumer.FieldResponseCode] = struct{}{}
}

// ResponseCodeCleared returns if the "ResponseCode" field was cleared in this mutation.
func (m *ConsumerMutation) ResponseCodeCleared() bool {
	_, ok := m.clearedFields[consumer.FieldResponseCode]
	return ok
}

// ResetResponseCode resets all changes to the "ResponseCode" field.
func (m *ConsumerMutation) ResetResponseCode() {
	m._ResponseCode = nil
	delete(m.clearedFields, consumer.FieldResponseCode)
}

// SetResponseDescription sets the "ResponseDescription" field.
func (m *ConsumerMutation) SetResponseDescription(s string) {
	m._ResponseDescription = &s
}

// ResponseDescription returns the value of the "ResponseDescription" field in the mutation.
func (m *ConsumerMutation) ResponseDescription() (r string, exists bool) {
	v := m._ResponseDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseDescription returns the old "ResponseDescription" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldResponseDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResponseDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResponseDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseDescription: %w", err)
	}
	return oldValue.ResponseDescription, nil
}

// ClearResponseDescription clears the value of the "ResponseDescription" field.
func (m *ConsumerMutation) ClearResponseDescription() {
	m._ResponseDescription = nil
	m.clearedFields[consumer.FieldResponseDescription] = struct{}{}
}

// ResponseDescriptionCleared returns if the "ResponseDescription" field was cleared in this mutation.
func (m *ConsumerMutation) ResponseDescriptionCleared() bool {
	_, ok := m.clearedFields[consumer.FieldResponseDescription]
	return ok
}

// ResetResponseDescription resets all changes to the "ResponseDescription" field.
func (m *ConsumerMutation) ResetResponseDescription() {
	m._ResponseDescription = nil
	delete(m.clearedFields, consumer.FieldResponseDescription)
}

// SetFileimportID sets the "FileimportID" field.
func (m *ConsumerMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *ConsumerMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Consumer entity.
// If the Consumer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsumerMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *ConsumerMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *ConsumerMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *ConsumerMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[consumer.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *ConsumerMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[consumer.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *ConsumerMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, consumer.FieldFileimportID)
}

// Op returns the operation name.
func (m *ConsumerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Consumer).
func (m *ConsumerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsumerMutation) Fields() []string {
	fields := make([]string, 0, 30)
	if m.transaction_id != nil {
		fields = append(fields, consumer.FieldTransactionID)
	}
	if m._TransactionStatus != nil {
		fields = append(fields, consumer.FieldTransactionStatus)
	}
	if m._TransactionType != nil {
		fields = append(fields, consumer.FieldTransactionType)
	}
	if m._PaymentChannel != nil {
		fields = append(fields, consumer.FieldPaymentChannel)
	}
	if m._PaymentType != nil {
		fields = append(fields, consumer.FieldPaymentType)
	}
	if m._TypeCode != nil {
		fields = append(fields, consumer.FieldTypeCode)
	}
	if m._ApprovalCode != nil {
		fields = append(fields, consumer.FieldApprovalCode)
	}
	if m._BillerID != nil {
		fields = append(fields, consumer.FieldBillerID)
	}
	if m.ref1 != nil {
		fields = append(fields, consumer.FieldRef1)
	}
	if m.ref2 != nil {
		fields = append(fields, consumer.FieldRef2)
	}
	if m.ref3 != nil {
		fields = append(fields, consumer.FieldRef3)
	}
	if m.amount != nil {
		fields = append(fields, consumer.FieldAmount)
	}
	if m.fee != nil {
		fields = append(fields, consumer.FieldFee)
	}
	if m.total != nil {
		fields = append(fields, consumer.FieldTotal)
	}
	if m._FromReference != nil {
		fields = append(fields, consumer.FieldFromReference)
	}
	if m._FromPhoneNo != nil {
		fields = append(fields, consumer.FieldFromPhoneNo)
	}
	if m._FromName != nil {
		fields = append(fields, consumer.FieldFromName)
	}
	if m._ToAccount != nil {
		fields = append(fields, consumer.FieldToAccount)
	}
	if m._ToAccountPhoneNo != nil {
		fields = append(fields, consumer.FieldToAccountPhoneNo)
	}
	if m._ToAccountName != nil {
		fields = append(fields, consumer.FieldToAccountName)
	}
	if m._BankCode != nil {
		fields = append(fields, consumer.FieldBankCode)
	}
	if m._TerminalId != nil {
		fields = append(fields, consumer.FieldTerminalId)
	}
	if m._TerminalType != nil {
		fields = append(fields, consumer.FieldTerminalType)
	}
	if m._ToAccount105 != nil {
		fields = append(fields, consumer.FieldToAccount105)
	}
	if m._FromReference105 != nil {
		fields = append(fields, consumer.FieldFromReference105)
	}
	if m.dateTime != nil {
		fields = append(fields, consumer.FieldDateTime)
	}
	if m._PartnerRef != nil {
		fields = append(fields, consumer.FieldPartnerRef)
	}
	if m._ResponseCode != nil {
		fields = append(fields, consumer.FieldResponseCode)
	}
	if m._ResponseDescription != nil {
		fields = append(fields, consumer.FieldResponseDescription)
	}
	if m._FileimportID != nil {
		fields = append(fields, consumer.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsumerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consumer.FieldTransactionID:
		return m.TransactionID()
	case consumer.FieldTransactionStatus:
		return m.TransactionStatus()
	case consumer.FieldTransactionType:
		return m.TransactionType()
	case consumer.FieldPaymentChannel:
		return m.PaymentChannel()
	case consumer.FieldPaymentType:
		return m.PaymentType()
	case consumer.FieldTypeCode:
		return m.TypeCode()
	case consumer.FieldApprovalCode:
		return m.ApprovalCode()
	case consumer.FieldBillerID:
		return m.BillerID()
	case consumer.FieldRef1:
		return m.Ref1()
	case consumer.FieldRef2:
		return m.Ref2()
	case consumer.FieldRef3:
		return m.Ref3()
	case consumer.FieldAmount:
		return m.Amount()
	case consumer.FieldFee:
		return m.Fee()
	case consumer.FieldTotal:
		return m.Total()
	case consumer.FieldFromReference:
		return m.FromReference()
	case consumer.FieldFromPhoneNo:
		return m.FromPhoneNo()
	case consumer.FieldFromName:
		return m.FromName()
	case consumer.FieldToAccount:
		return m.ToAccount()
	case consumer.FieldToAccountPhoneNo:
		return m.ToAccountPhoneNo()
	case consumer.FieldToAccountName:
		return m.ToAccountName()
	case consumer.FieldBankCode:
		return m.BankCode()
	case consumer.FieldTerminalId:
		return m.TerminalId()
	case consumer.FieldTerminalType:
		return m.TerminalType()
	case consumer.FieldToAccount105:
		return m.ToAccount105()
	case consumer.FieldFromReference105:
		return m.FromReference105()
	case consumer.FieldDateTime:
		return m.DateTime()
	case consumer.FieldPartnerRef:
		return m.PartnerRef()
	case consumer.FieldResponseCode:
		return m.ResponseCode()
	case consumer.FieldResponseDescription:
		return m.ResponseDescription()
	case consumer.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsumerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consumer.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case consumer.FieldTransactionStatus:
		return m.OldTransactionStatus(ctx)
	case consumer.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case consumer.FieldPaymentChannel:
		return m.OldPaymentChannel(ctx)
	case consumer.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case consumer.FieldTypeCode:
		return m.OldTypeCode(ctx)
	case consumer.FieldApprovalCode:
		return m.OldApprovalCode(ctx)
	case consumer.FieldBillerID:
		return m.OldBillerID(ctx)
	case consumer.FieldRef1:
		return m.OldRef1(ctx)
	case consumer.FieldRef2:
		return m.OldRef2(ctx)
	case consumer.FieldRef3:
		return m.OldRef3(ctx)
	case consumer.FieldAmount:
		return m.OldAmount(ctx)
	case consumer.FieldFee:
		return m.OldFee(ctx)
	case consumer.FieldTotal:
		return m.OldTotal(ctx)
	case consumer.FieldFromReference:
		return m.OldFromReference(ctx)
	case consumer.FieldFromPhoneNo:
		return m.OldFromPhoneNo(ctx)
	case consumer.FieldFromName:
		return m.OldFromName(ctx)
	case consumer.FieldToAccount:
		return m.OldToAccount(ctx)
	case consumer.FieldToAccountPhoneNo:
		return m.OldToAccountPhoneNo(ctx)
	case consumer.FieldToAccountName:
		return m.OldToAccountName(ctx)
	case consumer.FieldBankCode:
		return m.OldBankCode(ctx)
	case consumer.FieldTerminalId:
		return m.OldTerminalId(ctx)
	case consumer.FieldTerminalType:
		return m.OldTerminalType(ctx)
	case consumer.FieldToAccount105:
		return m.OldToAccount105(ctx)
	case consumer.FieldFromReference105:
		return m.OldFromReference105(ctx)
	case consumer.FieldDateTime:
		return m.OldDateTime(ctx)
	case consumer.FieldPartnerRef:
		return m.OldPartnerRef(ctx)
	case consumer.FieldResponseCode:
		return m.OldResponseCode(ctx)
	case consumer.FieldResponseDescription:
		return m.OldResponseDescription(ctx)
	case consumer.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Consumer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consumer.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case consumer.FieldTransactionStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionStatus(v)
		return nil
	case consumer.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case consumer.FieldPaymentChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentChannel(v)
		return nil
	case consumer.FieldPaymentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case consumer.FieldTypeCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeCode(v)
		return nil
	case consumer.FieldApprovalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApprovalCode(v)
		return nil
	case consumer.FieldBillerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBillerID(v)
		return nil
	case consumer.FieldRef1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef1(v)
		return nil
	case consumer.FieldRef2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef2(v)
		return nil
	case consumer.FieldRef3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef3(v)
		return nil
	case consumer.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case consumer.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFee(v)
		return nil
	case consumer.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotal(v)
		return nil
	case consumer.FieldFromReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromReference(v)
		return nil
	case consumer.FieldFromPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromPhoneNo(v)
		return nil
	case consumer.FieldFromName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromName(v)
		return nil
	case consumer.FieldToAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAccount(v)
		return nil
	case consumer.FieldToAccountPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAccountPhoneNo(v)
		return nil
	case consumer.FieldToAccountName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAccountName(v)
		return nil
	case consumer.FieldBankCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCode(v)
		return nil
	case consumer.FieldTerminalId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminalId(v)
		return nil
	case consumer.FieldTerminalType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminalType(v)
		return nil
	case consumer.FieldToAccount105:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToAccount105(v)
		return nil
	case consumer.FieldFromReference105:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromReference105(v)
		return nil
	case consumer.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case consumer.FieldPartnerRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartnerRef(v)
		return nil
	case consumer.FieldResponseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseCode(v)
		return nil
	case consumer.FieldResponseDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseDescription(v)
		return nil
	case consumer.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Consumer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsumerMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, consumer.FieldAmount)
	}
	if m.addfee != nil {
		fields = append(fields, consumer.FieldFee)
	}
	if m.addtotal != nil {
		fields = append(fields, consumer.FieldTotal)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, consumer.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsumerMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case consumer.FieldAmount:
		return m.AddedAmount()
	case consumer.FieldFee:
		return m.AddedFee()
	case consumer.FieldTotal:
		return m.AddedTotal()
	case consumer.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsumerMutation) AddField(name string, value ent.Value) error {
	switch name {
	case consumer.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case consumer.FieldFee:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFee(v)
		return nil
	case consumer.FieldTotal:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotal(v)
		return nil
	case consumer.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Consumer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsumerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(consumer.FieldTransactionID) {
		fields = append(fields, consumer.FieldTransactionID)
	}
	if m.FieldCleared(consumer.FieldTransactionStatus) {
		fields = append(fields, consumer.FieldTransactionStatus)
	}
	if m.FieldCleared(consumer.FieldTransactionType) {
		fields = append(fields, consumer.FieldTransactionType)
	}
	if m.FieldCleared(consumer.FieldPaymentChannel) {
		fields = append(fields, consumer.FieldPaymentChannel)
	}
	if m.FieldCleared(consumer.FieldPaymentType) {
		fields = append(fields, consumer.FieldPaymentType)
	}
	if m.FieldCleared(consumer.FieldTypeCode) {
		fields = append(fields, consumer.FieldTypeCode)
	}
	if m.FieldCleared(consumer.FieldApprovalCode) {
		fields = append(fields, consumer.FieldApprovalCode)
	}
	if m.FieldCleared(consumer.FieldBillerID) {
		fields = append(fields, consumer.FieldBillerID)
	}
	if m.FieldCleared(consumer.FieldRef1) {
		fields = append(fields, consumer.FieldRef1)
	}
	if m.FieldCleared(consumer.FieldRef2) {
		fields = append(fields, consumer.FieldRef2)
	}
	if m.FieldCleared(consumer.FieldRef3) {
		fields = append(fields, consumer.FieldRef3)
	}
	if m.FieldCleared(consumer.FieldAmount) {
		fields = append(fields, consumer.FieldAmount)
	}
	if m.FieldCleared(consumer.FieldFee) {
		fields = append(fields, consumer.FieldFee)
	}
	if m.FieldCleared(consumer.FieldTotal) {
		fields = append(fields, consumer.FieldTotal)
	}
	if m.FieldCleared(consumer.FieldFromReference) {
		fields = append(fields, consumer.FieldFromReference)
	}
	if m.FieldCleared(consumer.FieldFromPhoneNo) {
		fields = append(fields, consumer.FieldFromPhoneNo)
	}
	if m.FieldCleared(consumer.FieldFromName) {
		fields = append(fields, consumer.FieldFromName)
	}
	if m.FieldCleared(consumer.FieldToAccount) {
		fields = append(fields, consumer.FieldToAccount)
	}
	if m.FieldCleared(consumer.FieldToAccountPhoneNo) {
		fields = append(fields, consumer.FieldToAccountPhoneNo)
	}
	if m.FieldCleared(consumer.FieldToAccountName) {
		fields = append(fields, consumer.FieldToAccountName)
	}
	if m.FieldCleared(consumer.FieldBankCode) {
		fields = append(fields, consumer.FieldBankCode)
	}
	if m.FieldCleared(consumer.FieldTerminalId) {
		fields = append(fields, consumer.FieldTerminalId)
	}
	if m.FieldCleared(consumer.FieldTerminalType) {
		fields = append(fields, consumer.FieldTerminalType)
	}
	if m.FieldCleared(consumer.FieldToAccount105) {
		fields = append(fields, consumer.FieldToAccount105)
	}
	if m.FieldCleared(consumer.FieldFromReference105) {
		fields = append(fields, consumer.FieldFromReference105)
	}
	if m.FieldCleared(consumer.FieldDateTime) {
		fields = append(fields, consumer.FieldDateTime)
	}
	if m.FieldCleared(consumer.FieldPartnerRef) {
		fields = append(fields, consumer.FieldPartnerRef)
	}
	if m.FieldCleared(consumer.FieldResponseCode) {
		fields = append(fields, consumer.FieldResponseCode)
	}
	if m.FieldCleared(consumer.FieldResponseDescription) {
		fields = append(fields, consumer.FieldResponseDescription)
	}
	if m.FieldCleared(consumer.FieldFileimportID) {
		fields = append(fields, consumer.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsumerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsumerMutation) ClearField(name string) error {
	switch name {
	case consumer.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	case consumer.FieldTransactionStatus:
		m.ClearTransactionStatus()
		return nil
	case consumer.FieldTransactionType:
		m.ClearTransactionType()
		return nil
	case consumer.FieldPaymentChannel:
		m.ClearPaymentChannel()
		return nil
	case consumer.FieldPaymentType:
		m.ClearPaymentType()
		return nil
	case consumer.FieldTypeCode:
		m.ClearTypeCode()
		return nil
	case consumer.FieldApprovalCode:
		m.ClearApprovalCode()
		return nil
	case consumer.FieldBillerID:
		m.ClearBillerID()
		return nil
	case consumer.FieldRef1:
		m.ClearRef1()
		return nil
	case consumer.FieldRef2:
		m.ClearRef2()
		return nil
	case consumer.FieldRef3:
		m.ClearRef3()
		return nil
	case consumer.FieldAmount:
		m.ClearAmount()
		return nil
	case consumer.FieldFee:
		m.ClearFee()
		return nil
	case consumer.FieldTotal:
		m.ClearTotal()
		return nil
	case consumer.FieldFromReference:
		m.ClearFromReference()
		return nil
	case consumer.FieldFromPhoneNo:
		m.ClearFromPhoneNo()
		return nil
	case consumer.FieldFromName:
		m.ClearFromName()
		return nil
	case consumer.FieldToAccount:
		m.ClearToAccount()
		return nil
	case consumer.FieldToAccountPhoneNo:
		m.ClearToAccountPhoneNo()
		return nil
	case consumer.FieldToAccountName:
		m.ClearToAccountName()
		return nil
	case consumer.FieldBankCode:
		m.ClearBankCode()
		return nil
	case consumer.FieldTerminalId:
		m.ClearTerminalId()
		return nil
	case consumer.FieldTerminalType:
		m.ClearTerminalType()
		return nil
	case consumer.FieldToAccount105:
		m.ClearToAccount105()
		return nil
	case consumer.FieldFromReference105:
		m.ClearFromReference105()
		return nil
	case consumer.FieldDateTime:
		m.ClearDateTime()
		return nil
	case consumer.FieldPartnerRef:
		m.ClearPartnerRef()
		return nil
	case consumer.FieldResponseCode:
		m.ClearResponseCode()
		return nil
	case consumer.FieldResponseDescription:
		m.ClearResponseDescription()
		return nil
	case consumer.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Consumer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsumerMutation) ResetField(name string) error {
	switch name {
	case consumer.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case consumer.FieldTransactionStatus:
		m.ResetTransactionStatus()
		return nil
	case consumer.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case consumer.FieldPaymentChannel:
		m.ResetPaymentChannel()
		return nil
	case consumer.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case consumer.FieldTypeCode:
		m.ResetTypeCode()
		return nil
	case consumer.FieldApprovalCode:
		m.ResetApprovalCode()
		return nil
	case consumer.FieldBillerID:
		m.ResetBillerID()
		return nil
	case consumer.FieldRef1:
		m.ResetRef1()
		return nil
	case consumer.FieldRef2:
		m.ResetRef2()
		return nil
	case consumer.FieldRef3:
		m.ResetRef3()
		return nil
	case consumer.FieldAmount:
		m.ResetAmount()
		return nil
	case consumer.FieldFee:
		m.ResetFee()
		return nil
	case consumer.FieldTotal:
		m.ResetTotal()
		return nil
	case consumer.FieldFromReference:
		m.ResetFromReference()
		return nil
	case consumer.FieldFromPhoneNo:
		m.ResetFromPhoneNo()
		return nil
	case consumer.FieldFromName:
		m.ResetFromName()
		return nil
	case consumer.FieldToAccount:
		m.ResetToAccount()
		return nil
	case consumer.FieldToAccountPhoneNo:
		m.ResetToAccountPhoneNo()
		return nil
	case consumer.FieldToAccountName:
		m.ResetToAccountName()
		return nil
	case consumer.FieldBankCode:
		m.ResetBankCode()
		return nil
	case consumer.FieldTerminalId:
		m.ResetTerminalId()
		return nil
	case consumer.FieldTerminalType:
		m.ResetTerminalType()
		return nil
	case consumer.FieldToAccount105:
		m.ResetToAccount105()
		return nil
	case consumer.FieldFromReference105:
		m.ResetFromReference105()
		return nil
	case consumer.FieldDateTime:
		m.ResetDateTime()
		return nil
	case consumer.FieldPartnerRef:
		m.ResetPartnerRef()
		return nil
	case consumer.FieldResponseCode:
		m.ResetResponseCode()
		return nil
	case consumer.FieldResponseDescription:
		m.ResetResponseDescription()
		return nil
	case consumer.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Consumer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsumerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsumerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsumerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsumerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsumerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsumerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsumerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Consumer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsumerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Consumer edge %s", name)
}

// FileimportMutation represents an operation that mutates the Fileimport nodes in the graph.
type FileimportMutation struct {
	config
	op            Op
	typ           string
	id            *int
	filename      *string
	filetype      *string
	importdate    *time.Time
	status        *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Fileimport, error)
	predicates    []predicate.Fileimport
}

var _ ent.Mutation = (*FileimportMutation)(nil)

// fileimportOption allows management of the mutation configuration using functional options.
type fileimportOption func(*FileimportMutation)

// newFileimportMutation creates new mutation for the Fileimport entity.
func newFileimportMutation(c config, op Op, opts ...fileimportOption) *FileimportMutation {
	m := &FileimportMutation{
		config:        c,
		op:            op,
		typ:           TypeFileimport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileimportID sets the ID field of the mutation.
func withFileimportID(id int) fileimportOption {
	return func(m *FileimportMutation) {
		var (
			err   error
			once  sync.Once
			value *Fileimport
		)
		m.oldValue = func(ctx context.Context) (*Fileimport, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fileimport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileimport sets the old Fileimport of the mutation.
func withFileimport(node *Fileimport) fileimportOption {
	return func(m *FileimportMutation) {
		m.oldValue = func(context.Context) (*Fileimport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileimportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileimportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fileimport entities.
func (m *FileimportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FileimportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFilename sets the "filename" field.
func (m *FileimportMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *FileimportMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the Fileimport entity.
// If the Fileimport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileimportMutation) OldFilename(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ClearFilename clears the value of the "filename" field.
func (m *FileimportMutation) ClearFilename() {
	m.filename = nil
	m.clearedFields[fileimport.FieldFilename] = struct{}{}
}

// FilenameCleared returns if the "filename" field was cleared in this mutation.
func (m *FileimportMutation) FilenameCleared() bool {
	_, ok := m.clearedFields[fileimport.FieldFilename]
	return ok
}

// ResetFilename resets all changes to the "filename" field.
func (m *FileimportMutation) ResetFilename() {
	m.filename = nil
	delete(m.clearedFields, fileimport.FieldFilename)
}

// SetFiletype sets the "filetype" field.
func (m *FileimportMutation) SetFiletype(s string) {
	m.filetype = &s
}

// Filetype returns the value of the "filetype" field in the mutation.
func (m *FileimportMutation) Filetype() (r string, exists bool) {
	v := m.filetype
	if v == nil {
		return
	}
	return *v, true
}

// OldFiletype returns the old "filetype" field's value of the Fileimport entity.
// If the Fileimport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileimportMutation) OldFiletype(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFiletype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFiletype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFiletype: %w", err)
	}
	return oldValue.Filetype, nil
}

// ClearFiletype clears the value of the "filetype" field.
func (m *FileimportMutation) ClearFiletype() {
	m.filetype = nil
	m.clearedFields[fileimport.FieldFiletype] = struct{}{}
}

// FiletypeCleared returns if the "filetype" field was cleared in this mutation.
func (m *FileimportMutation) FiletypeCleared() bool {
	_, ok := m.clearedFields[fileimport.FieldFiletype]
	return ok
}

// ResetFiletype resets all changes to the "filetype" field.
func (m *FileimportMutation) ResetFiletype() {
	m.filetype = nil
	delete(m.clearedFields, fileimport.FieldFiletype)
}

// SetImportdate sets the "importdate" field.
func (m *FileimportMutation) SetImportdate(t time.Time) {
	m.importdate = &t
}

// Importdate returns the value of the "importdate" field in the mutation.
func (m *FileimportMutation) Importdate() (r time.Time, exists bool) {
	v := m.importdate
	if v == nil {
		return
	}
	return *v, true
}

// OldImportdate returns the old "importdate" field's value of the Fileimport entity.
// If the Fileimport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileimportMutation) OldImportdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImportdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImportdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportdate: %w", err)
	}
	return oldValue.Importdate, nil
}

// ClearImportdate clears the value of the "importdate" field.
func (m *FileimportMutation) ClearImportdate() {
	m.importdate = nil
	m.clearedFields[fileimport.FieldImportdate] = struct{}{}
}

// ImportdateCleared returns if the "importdate" field was cleared in this mutation.
func (m *FileimportMutation) ImportdateCleared() bool {
	_, ok := m.clearedFields[fileimport.FieldImportdate]
	return ok
}

// ResetImportdate resets all changes to the "importdate" field.
func (m *FileimportMutation) ResetImportdate() {
	m.importdate = nil
	delete(m.clearedFields, fileimport.FieldImportdate)
}

// SetStatus sets the "status" field.
func (m *FileimportMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *FileimportMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Fileimport entity.
// If the Fileimport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileimportMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *FileimportMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[fileimport.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *FileimportMutation) StatusCleared() bool {
	_, ok := m.clearedFields[fileimport.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *FileimportMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, fileimport.FieldStatus)
}

// Op returns the operation name.
func (m *FileimportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Fileimport).
func (m *FileimportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileimportMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.filename != nil {
		fields = append(fields, fileimport.FieldFilename)
	}
	if m.filetype != nil {
		fields = append(fields, fileimport.FieldFiletype)
	}
	if m.importdate != nil {
		fields = append(fields, fileimport.FieldImportdate)
	}
	if m.status != nil {
		fields = append(fields, fileimport.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileimportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileimport.FieldFilename:
		return m.Filename()
	case fileimport.FieldFiletype:
		return m.Filetype()
	case fileimport.FieldImportdate:
		return m.Importdate()
	case fileimport.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileimportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileimport.FieldFilename:
		return m.OldFilename(ctx)
	case fileimport.FieldFiletype:
		return m.OldFiletype(ctx)
	case fileimport.FieldImportdate:
		return m.OldImportdate(ctx)
	case fileimport.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Fileimport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileimportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileimport.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case fileimport.FieldFiletype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFiletype(v)
		return nil
	case fileimport.FieldImportdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportdate(v)
		return nil
	case fileimport.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Fileimport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileimportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileimportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileimportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fileimport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileimportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fileimport.FieldFilename) {
		fields = append(fields, fileimport.FieldFilename)
	}
	if m.FieldCleared(fileimport.FieldFiletype) {
		fields = append(fields, fileimport.FieldFiletype)
	}
	if m.FieldCleared(fileimport.FieldImportdate) {
		fields = append(fields, fileimport.FieldImportdate)
	}
	if m.FieldCleared(fileimport.FieldStatus) {
		fields = append(fields, fileimport.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileimportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileimportMutation) ClearField(name string) error {
	switch name {
	case fileimport.FieldFilename:
		m.ClearFilename()
		return nil
	case fileimport.FieldFiletype:
		m.ClearFiletype()
		return nil
	case fileimport.FieldImportdate:
		m.ClearImportdate()
		return nil
	case fileimport.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Fileimport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileimportMutation) ResetField(name string) error {
	switch name {
	case fileimport.FieldFilename:
		m.ResetFilename()
		return nil
	case fileimport.FieldFiletype:
		m.ResetFiletype()
		return nil
	case fileimport.FieldImportdate:
		m.ResetImportdate()
		return nil
	case fileimport.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Fileimport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileimportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileimportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileimportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileimportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileimportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileimportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileimportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Fileimport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileimportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Fileimport edge %s", name)
}

// FileinsertMutation represents an operation that mutates the Fileinsert nodes in the graph.
type FileinsertMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	importdate    *time.Time
	_IsSuccess    *bool
	_UpdateDate   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Fileinsert, error)
	predicates    []predicate.Fileinsert
}

var _ ent.Mutation = (*FileinsertMutation)(nil)

// fileinsertOption allows management of the mutation configuration using functional options.
type fileinsertOption func(*FileinsertMutation)

// newFileinsertMutation creates new mutation for the Fileinsert entity.
func newFileinsertMutation(c config, op Op, opts ...fileinsertOption) *FileinsertMutation {
	m := &FileinsertMutation{
		config:        c,
		op:            op,
		typ:           TypeFileinsert,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileinsertID sets the ID field of the mutation.
func withFileinsertID(id int) fileinsertOption {
	return func(m *FileinsertMutation) {
		var (
			err   error
			once  sync.Once
			value *Fileinsert
		)
		m.oldValue = func(ctx context.Context) (*Fileinsert, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fileinsert.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFileinsert sets the old Fileinsert of the mutation.
func withFileinsert(node *Fileinsert) fileinsertOption {
	return func(m *FileinsertMutation) {
		m.oldValue = func(context.Context) (*Fileinsert, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileinsertMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileinsertMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Fileinsert entities.
func (m *FileinsertMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *FileinsertMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *FileinsertMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileinsertMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Fileinsert entity.
// If the Fileinsert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileinsertMutation) OldName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *FileinsertMutation) ClearName() {
	m.name = nil
	m.clearedFields[fileinsert.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *FileinsertMutation) NameCleared() bool {
	_, ok := m.clearedFields[fileinsert.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *FileinsertMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, fileinsert.FieldName)
}

// SetImportdate sets the "importdate" field.
func (m *FileinsertMutation) SetImportdate(t time.Time) {
	m.importdate = &t
}

// Importdate returns the value of the "importdate" field in the mutation.
func (m *FileinsertMutation) Importdate() (r time.Time, exists bool) {
	v := m.importdate
	if v == nil {
		return
	}
	return *v, true
}

// OldImportdate returns the old "importdate" field's value of the Fileinsert entity.
// If the Fileinsert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileinsertMutation) OldImportdate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImportdate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImportdate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportdate: %w", err)
	}
	return oldValue.Importdate, nil
}

// ClearImportdate clears the value of the "importdate" field.
func (m *FileinsertMutation) ClearImportdate() {
	m.importdate = nil
	m.clearedFields[fileinsert.FieldImportdate] = struct{}{}
}

// ImportdateCleared returns if the "importdate" field was cleared in this mutation.
func (m *FileinsertMutation) ImportdateCleared() bool {
	_, ok := m.clearedFields[fileinsert.FieldImportdate]
	return ok
}

// ResetImportdate resets all changes to the "importdate" field.
func (m *FileinsertMutation) ResetImportdate() {
	m.importdate = nil
	delete(m.clearedFields, fileinsert.FieldImportdate)
}

// SetIsSuccess sets the "IsSuccess" field.
func (m *FileinsertMutation) SetIsSuccess(b bool) {
	m._IsSuccess = &b
}

// IsSuccess returns the value of the "IsSuccess" field in the mutation.
func (m *FileinsertMutation) IsSuccess() (r bool, exists bool) {
	v := m._IsSuccess
	if v == nil {
		return
	}
	return *v, true
}

// OldIsSuccess returns the old "IsSuccess" field's value of the Fileinsert entity.
// If the Fileinsert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileinsertMutation) OldIsSuccess(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsSuccess: %w", err)
	}
	return oldValue.IsSuccess, nil
}

// ClearIsSuccess clears the value of the "IsSuccess" field.
func (m *FileinsertMutation) ClearIsSuccess() {
	m._IsSuccess = nil
	m.clearedFields[fileinsert.FieldIsSuccess] = struct{}{}
}

// IsSuccessCleared returns if the "IsSuccess" field was cleared in this mutation.
func (m *FileinsertMutation) IsSuccessCleared() bool {
	_, ok := m.clearedFields[fileinsert.FieldIsSuccess]
	return ok
}

// ResetIsSuccess resets all changes to the "IsSuccess" field.
func (m *FileinsertMutation) ResetIsSuccess() {
	m._IsSuccess = nil
	delete(m.clearedFields, fileinsert.FieldIsSuccess)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *FileinsertMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *FileinsertMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Fileinsert entity.
// If the Fileinsert object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileinsertMutation) OldUpdateDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *FileinsertMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[fileinsert.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *FileinsertMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[fileinsert.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *FileinsertMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, fileinsert.FieldUpdateDate)
}

// Op returns the operation name.
func (m *FileinsertMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Fileinsert).
func (m *FileinsertMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileinsertMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, fileinsert.FieldName)
	}
	if m.importdate != nil {
		fields = append(fields, fileinsert.FieldImportdate)
	}
	if m._IsSuccess != nil {
		fields = append(fields, fileinsert.FieldIsSuccess)
	}
	if m._UpdateDate != nil {
		fields = append(fields, fileinsert.FieldUpdateDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileinsertMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fileinsert.FieldName:
		return m.Name()
	case fileinsert.FieldImportdate:
		return m.Importdate()
	case fileinsert.FieldIsSuccess:
		return m.IsSuccess()
	case fileinsert.FieldUpdateDate:
		return m.UpdateDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileinsertMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fileinsert.FieldName:
		return m.OldName(ctx)
	case fileinsert.FieldImportdate:
		return m.OldImportdate(ctx)
	case fileinsert.FieldIsSuccess:
		return m.OldIsSuccess(ctx)
	case fileinsert.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	}
	return nil, fmt.Errorf("unknown Fileinsert field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileinsertMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fileinsert.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case fileinsert.FieldImportdate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportdate(v)
		return nil
	case fileinsert.FieldIsSuccess:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsSuccess(v)
		return nil
	case fileinsert.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	}
	return fmt.Errorf("unknown Fileinsert field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileinsertMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileinsertMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileinsertMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fileinsert numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileinsertMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(fileinsert.FieldName) {
		fields = append(fields, fileinsert.FieldName)
	}
	if m.FieldCleared(fileinsert.FieldImportdate) {
		fields = append(fields, fileinsert.FieldImportdate)
	}
	if m.FieldCleared(fileinsert.FieldIsSuccess) {
		fields = append(fields, fileinsert.FieldIsSuccess)
	}
	if m.FieldCleared(fileinsert.FieldUpdateDate) {
		fields = append(fields, fileinsert.FieldUpdateDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileinsertMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileinsertMutation) ClearField(name string) error {
	switch name {
	case fileinsert.FieldName:
		m.ClearName()
		return nil
	case fileinsert.FieldImportdate:
		m.ClearImportdate()
		return nil
	case fileinsert.FieldIsSuccess:
		m.ClearIsSuccess()
		return nil
	case fileinsert.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Fileinsert nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileinsertMutation) ResetField(name string) error {
	switch name {
	case fileinsert.FieldName:
		m.ResetName()
		return nil
	case fileinsert.FieldImportdate:
		m.ResetImportdate()
		return nil
	case fileinsert.FieldIsSuccess:
		m.ResetIsSuccess()
		return nil
	case fileinsert.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Fileinsert field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileinsertMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileinsertMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileinsertMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileinsertMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileinsertMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileinsertMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileinsertMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Fileinsert unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileinsertMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Fileinsert edge %s", name)
}

// LimitpointMutation represents an operation that mutates the Limitpoint nodes in the graph.
type LimitpointMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_LimitPoint    *int
	add_LimitPoint *int
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Limitpoint, error)
	predicates     []predicate.Limitpoint
}

var _ ent.Mutation = (*LimitpointMutation)(nil)

// limitpointOption allows management of the mutation configuration using functional options.
type limitpointOption func(*LimitpointMutation)

// newLimitpointMutation creates new mutation for the Limitpoint entity.
func newLimitpointMutation(c config, op Op, opts ...limitpointOption) *LimitpointMutation {
	m := &LimitpointMutation{
		config:        c,
		op:            op,
		typ:           TypeLimitpoint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLimitpointID sets the ID field of the mutation.
func withLimitpointID(id int) limitpointOption {
	return func(m *LimitpointMutation) {
		var (
			err   error
			once  sync.Once
			value *Limitpoint
		)
		m.oldValue = func(ctx context.Context) (*Limitpoint, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Limitpoint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLimitpoint sets the old Limitpoint of the mutation.
func withLimitpoint(node *Limitpoint) limitpointOption {
	return func(m *LimitpointMutation) {
		m.oldValue = func(context.Context) (*Limitpoint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LimitpointMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LimitpointMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Limitpoint entities.
func (m *LimitpointMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *LimitpointMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetLimitPoint sets the "LimitPoint" field.
func (m *LimitpointMutation) SetLimitPoint(i int) {
	m._LimitPoint = &i
	m.add_LimitPoint = nil
}

// LimitPoint returns the value of the "LimitPoint" field in the mutation.
func (m *LimitpointMutation) LimitPoint() (r int, exists bool) {
	v := m._LimitPoint
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitPoint returns the old "LimitPoint" field's value of the Limitpoint entity.
// If the Limitpoint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LimitpointMutation) OldLimitPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLimitPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLimitPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitPoint: %w", err)
	}
	return oldValue.LimitPoint, nil
}

// AddLimitPoint adds i to the "LimitPoint" field.
func (m *LimitpointMutation) AddLimitPoint(i int) {
	if m.add_LimitPoint != nil {
		*m.add_LimitPoint += i
	} else {
		m.add_LimitPoint = &i
	}
}

// AddedLimitPoint returns the value that was added to the "LimitPoint" field in this mutation.
func (m *LimitpointMutation) AddedLimitPoint() (r int, exists bool) {
	v := m.add_LimitPoint
	if v == nil {
		return
	}
	return *v, true
}

// ClearLimitPoint clears the value of the "LimitPoint" field.
func (m *LimitpointMutation) ClearLimitPoint() {
	m._LimitPoint = nil
	m.add_LimitPoint = nil
	m.clearedFields[limitpoint.FieldLimitPoint] = struct{}{}
}

// LimitPointCleared returns if the "LimitPoint" field was cleared in this mutation.
func (m *LimitpointMutation) LimitPointCleared() bool {
	_, ok := m.clearedFields[limitpoint.FieldLimitPoint]
	return ok
}

// ResetLimitPoint resets all changes to the "LimitPoint" field.
func (m *LimitpointMutation) ResetLimitPoint() {
	m._LimitPoint = nil
	m.add_LimitPoint = nil
	delete(m.clearedFields, limitpoint.FieldLimitPoint)
}

// Op returns the operation name.
func (m *LimitpointMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Limitpoint).
func (m *LimitpointMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LimitpointMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._LimitPoint != nil {
		fields = append(fields, limitpoint.FieldLimitPoint)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LimitpointMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case limitpoint.FieldLimitPoint:
		return m.LimitPoint()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LimitpointMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case limitpoint.FieldLimitPoint:
		return m.OldLimitPoint(ctx)
	}
	return nil, fmt.Errorf("unknown Limitpoint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LimitpointMutation) SetField(name string, value ent.Value) error {
	switch name {
	case limitpoint.FieldLimitPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Limitpoint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LimitpointMutation) AddedFields() []string {
	var fields []string
	if m.add_LimitPoint != nil {
		fields = append(fields, limitpoint.FieldLimitPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LimitpointMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case limitpoint.FieldLimitPoint:
		return m.AddedLimitPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LimitpointMutation) AddField(name string, value ent.Value) error {
	switch name {
	case limitpoint.FieldLimitPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLimitPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Limitpoint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LimitpointMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(limitpoint.FieldLimitPoint) {
		fields = append(fields, limitpoint.FieldLimitPoint)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LimitpointMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LimitpointMutation) ClearField(name string) error {
	switch name {
	case limitpoint.FieldLimitPoint:
		m.ClearLimitPoint()
		return nil
	}
	return fmt.Errorf("unknown Limitpoint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LimitpointMutation) ResetField(name string) error {
	switch name {
	case limitpoint.FieldLimitPoint:
		m.ResetLimitPoint()
		return nil
	}
	return fmt.Errorf("unknown Limitpoint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LimitpointMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LimitpointMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LimitpointMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LimitpointMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LimitpointMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LimitpointMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LimitpointMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Limitpoint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LimitpointMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Limitpoint edge %s", name)
}

// LoanbindingMutation represents an operation that mutates the Loanbinding nodes in the graph.
type LoanbindingMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Status           *string
	dateTime          *time.Time
	_WalletId         *string
	_AccountReference *string
	_LoanAccountNo    *string
	_RequestDateTime  *time.Time
	_FileimportID     *int
	add_FileimportID  *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Loanbinding, error)
	predicates        []predicate.Loanbinding
}

var _ ent.Mutation = (*LoanbindingMutation)(nil)

// loanbindingOption allows management of the mutation configuration using functional options.
type loanbindingOption func(*LoanbindingMutation)

// newLoanbindingMutation creates new mutation for the Loanbinding entity.
func newLoanbindingMutation(c config, op Op, opts ...loanbindingOption) *LoanbindingMutation {
	m := &LoanbindingMutation{
		config:        c,
		op:            op,
		typ:           TypeLoanbinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLoanbindingID sets the ID field of the mutation.
func withLoanbindingID(id int) loanbindingOption {
	return func(m *LoanbindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Loanbinding
		)
		m.oldValue = func(ctx context.Context) (*Loanbinding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Loanbinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLoanbinding sets the old Loanbinding of the mutation.
func withLoanbinding(node *Loanbinding) loanbindingOption {
	return func(m *LoanbindingMutation) {
		m.oldValue = func(context.Context) (*Loanbinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LoanbindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LoanbindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Loanbinding entities.
func (m *LoanbindingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *LoanbindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatus sets the "Status" field.
func (m *LoanbindingMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *LoanbindingMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *LoanbindingMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[loanbinding.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *LoanbindingMutation) StatusCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *LoanbindingMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, loanbinding.FieldStatus)
}

// SetDateTime sets the "dateTime" field.
func (m *LoanbindingMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *LoanbindingMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *LoanbindingMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[loanbinding.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *LoanbindingMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *LoanbindingMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, loanbinding.FieldDateTime)
}

// SetWalletId sets the "WalletId" field.
func (m *LoanbindingMutation) SetWalletId(s string) {
	m._WalletId = &s
}

// WalletId returns the value of the "WalletId" field in the mutation.
func (m *LoanbindingMutation) WalletId() (r string, exists bool) {
	v := m._WalletId
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletId returns the old "WalletId" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldWalletId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletId: %w", err)
	}
	return oldValue.WalletId, nil
}

// ClearWalletId clears the value of the "WalletId" field.
func (m *LoanbindingMutation) ClearWalletId() {
	m._WalletId = nil
	m.clearedFields[loanbinding.FieldWalletId] = struct{}{}
}

// WalletIdCleared returns if the "WalletId" field was cleared in this mutation.
func (m *LoanbindingMutation) WalletIdCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldWalletId]
	return ok
}

// ResetWalletId resets all changes to the "WalletId" field.
func (m *LoanbindingMutation) ResetWalletId() {
	m._WalletId = nil
	delete(m.clearedFields, loanbinding.FieldWalletId)
}

// SetAccountReference sets the "AccountReference" field.
func (m *LoanbindingMutation) SetAccountReference(s string) {
	m._AccountReference = &s
}

// AccountReference returns the value of the "AccountReference" field in the mutation.
func (m *LoanbindingMutation) AccountReference() (r string, exists bool) {
	v := m._AccountReference
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountReference returns the old "AccountReference" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldAccountReference(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountReference: %w", err)
	}
	return oldValue.AccountReference, nil
}

// ClearAccountReference clears the value of the "AccountReference" field.
func (m *LoanbindingMutation) ClearAccountReference() {
	m._AccountReference = nil
	m.clearedFields[loanbinding.FieldAccountReference] = struct{}{}
}

// AccountReferenceCleared returns if the "AccountReference" field was cleared in this mutation.
func (m *LoanbindingMutation) AccountReferenceCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldAccountReference]
	return ok
}

// ResetAccountReference resets all changes to the "AccountReference" field.
func (m *LoanbindingMutation) ResetAccountReference() {
	m._AccountReference = nil
	delete(m.clearedFields, loanbinding.FieldAccountReference)
}

// SetLoanAccountNo sets the "LoanAccountNo" field.
func (m *LoanbindingMutation) SetLoanAccountNo(s string) {
	m._LoanAccountNo = &s
}

// LoanAccountNo returns the value of the "LoanAccountNo" field in the mutation.
func (m *LoanbindingMutation) LoanAccountNo() (r string, exists bool) {
	v := m._LoanAccountNo
	if v == nil {
		return
	}
	return *v, true
}

// OldLoanAccountNo returns the old "LoanAccountNo" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldLoanAccountNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLoanAccountNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLoanAccountNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLoanAccountNo: %w", err)
	}
	return oldValue.LoanAccountNo, nil
}

// ClearLoanAccountNo clears the value of the "LoanAccountNo" field.
func (m *LoanbindingMutation) ClearLoanAccountNo() {
	m._LoanAccountNo = nil
	m.clearedFields[loanbinding.FieldLoanAccountNo] = struct{}{}
}

// LoanAccountNoCleared returns if the "LoanAccountNo" field was cleared in this mutation.
func (m *LoanbindingMutation) LoanAccountNoCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldLoanAccountNo]
	return ok
}

// ResetLoanAccountNo resets all changes to the "LoanAccountNo" field.
func (m *LoanbindingMutation) ResetLoanAccountNo() {
	m._LoanAccountNo = nil
	delete(m.clearedFields, loanbinding.FieldLoanAccountNo)
}

// SetRequestDateTime sets the "RequestDateTime" field.
func (m *LoanbindingMutation) SetRequestDateTime(t time.Time) {
	m._RequestDateTime = &t
}

// RequestDateTime returns the value of the "RequestDateTime" field in the mutation.
func (m *LoanbindingMutation) RequestDateTime() (r time.Time, exists bool) {
	v := m._RequestDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestDateTime returns the old "RequestDateTime" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldRequestDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRequestDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRequestDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestDateTime: %w", err)
	}
	return oldValue.RequestDateTime, nil
}

// ClearRequestDateTime clears the value of the "RequestDateTime" field.
func (m *LoanbindingMutation) ClearRequestDateTime() {
	m._RequestDateTime = nil
	m.clearedFields[loanbinding.FieldRequestDateTime] = struct{}{}
}

// RequestDateTimeCleared returns if the "RequestDateTime" field was cleared in this mutation.
func (m *LoanbindingMutation) RequestDateTimeCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldRequestDateTime]
	return ok
}

// ResetRequestDateTime resets all changes to the "RequestDateTime" field.
func (m *LoanbindingMutation) ResetRequestDateTime() {
	m._RequestDateTime = nil
	delete(m.clearedFields, loanbinding.FieldRequestDateTime)
}

// SetFileimportID sets the "FileimportID" field.
func (m *LoanbindingMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *LoanbindingMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Loanbinding entity.
// If the Loanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LoanbindingMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *LoanbindingMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *LoanbindingMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *LoanbindingMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[loanbinding.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *LoanbindingMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[loanbinding.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *LoanbindingMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, loanbinding.FieldFileimportID)
}

// Op returns the operation name.
func (m *LoanbindingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Loanbinding).
func (m *LoanbindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LoanbindingMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Status != nil {
		fields = append(fields, loanbinding.FieldStatus)
	}
	if m.dateTime != nil {
		fields = append(fields, loanbinding.FieldDateTime)
	}
	if m._WalletId != nil {
		fields = append(fields, loanbinding.FieldWalletId)
	}
	if m._AccountReference != nil {
		fields = append(fields, loanbinding.FieldAccountReference)
	}
	if m._LoanAccountNo != nil {
		fields = append(fields, loanbinding.FieldLoanAccountNo)
	}
	if m._RequestDateTime != nil {
		fields = append(fields, loanbinding.FieldRequestDateTime)
	}
	if m._FileimportID != nil {
		fields = append(fields, loanbinding.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LoanbindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case loanbinding.FieldStatus:
		return m.Status()
	case loanbinding.FieldDateTime:
		return m.DateTime()
	case loanbinding.FieldWalletId:
		return m.WalletId()
	case loanbinding.FieldAccountReference:
		return m.AccountReference()
	case loanbinding.FieldLoanAccountNo:
		return m.LoanAccountNo()
	case loanbinding.FieldRequestDateTime:
		return m.RequestDateTime()
	case loanbinding.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LoanbindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case loanbinding.FieldStatus:
		return m.OldStatus(ctx)
	case loanbinding.FieldDateTime:
		return m.OldDateTime(ctx)
	case loanbinding.FieldWalletId:
		return m.OldWalletId(ctx)
	case loanbinding.FieldAccountReference:
		return m.OldAccountReference(ctx)
	case loanbinding.FieldLoanAccountNo:
		return m.OldLoanAccountNo(ctx)
	case loanbinding.FieldRequestDateTime:
		return m.OldRequestDateTime(ctx)
	case loanbinding.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Loanbinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanbindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case loanbinding.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case loanbinding.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case loanbinding.FieldWalletId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletId(v)
		return nil
	case loanbinding.FieldAccountReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountReference(v)
		return nil
	case loanbinding.FieldLoanAccountNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLoanAccountNo(v)
		return nil
	case loanbinding.FieldRequestDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestDateTime(v)
		return nil
	case loanbinding.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Loanbinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LoanbindingMutation) AddedFields() []string {
	var fields []string
	if m.add_FileimportID != nil {
		fields = append(fields, loanbinding.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LoanbindingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case loanbinding.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LoanbindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case loanbinding.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Loanbinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LoanbindingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(loanbinding.FieldStatus) {
		fields = append(fields, loanbinding.FieldStatus)
	}
	if m.FieldCleared(loanbinding.FieldDateTime) {
		fields = append(fields, loanbinding.FieldDateTime)
	}
	if m.FieldCleared(loanbinding.FieldWalletId) {
		fields = append(fields, loanbinding.FieldWalletId)
	}
	if m.FieldCleared(loanbinding.FieldAccountReference) {
		fields = append(fields, loanbinding.FieldAccountReference)
	}
	if m.FieldCleared(loanbinding.FieldLoanAccountNo) {
		fields = append(fields, loanbinding.FieldLoanAccountNo)
	}
	if m.FieldCleared(loanbinding.FieldRequestDateTime) {
		fields = append(fields, loanbinding.FieldRequestDateTime)
	}
	if m.FieldCleared(loanbinding.FieldFileimportID) {
		fields = append(fields, loanbinding.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LoanbindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LoanbindingMutation) ClearField(name string) error {
	switch name {
	case loanbinding.FieldStatus:
		m.ClearStatus()
		return nil
	case loanbinding.FieldDateTime:
		m.ClearDateTime()
		return nil
	case loanbinding.FieldWalletId:
		m.ClearWalletId()
		return nil
	case loanbinding.FieldAccountReference:
		m.ClearAccountReference()
		return nil
	case loanbinding.FieldLoanAccountNo:
		m.ClearLoanAccountNo()
		return nil
	case loanbinding.FieldRequestDateTime:
		m.ClearRequestDateTime()
		return nil
	case loanbinding.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Loanbinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LoanbindingMutation) ResetField(name string) error {
	switch name {
	case loanbinding.FieldStatus:
		m.ResetStatus()
		return nil
	case loanbinding.FieldDateTime:
		m.ResetDateTime()
		return nil
	case loanbinding.FieldWalletId:
		m.ResetWalletId()
		return nil
	case loanbinding.FieldAccountReference:
		m.ResetAccountReference()
		return nil
	case loanbinding.FieldLoanAccountNo:
		m.ResetLoanAccountNo()
		return nil
	case loanbinding.FieldRequestDateTime:
		m.ResetRequestDateTime()
		return nil
	case loanbinding.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Loanbinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LoanbindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LoanbindingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LoanbindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LoanbindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LoanbindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LoanbindingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LoanbindingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Loanbinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LoanbindingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Loanbinding edge %s", name)
}

// LogexportMutation represents an operation that mutates the Logexport nodes in the graph.
type LogexportMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_UserName     *string
	_FileName     *string
	_ExportDate   *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Logexport, error)
	predicates    []predicate.Logexport
}

var _ ent.Mutation = (*LogexportMutation)(nil)

// logexportOption allows management of the mutation configuration using functional options.
type logexportOption func(*LogexportMutation)

// newLogexportMutation creates new mutation for the Logexport entity.
func newLogexportMutation(c config, op Op, opts ...logexportOption) *LogexportMutation {
	m := &LogexportMutation{
		config:        c,
		op:            op,
		typ:           TypeLogexport,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogexportID sets the ID field of the mutation.
func withLogexportID(id int) logexportOption {
	return func(m *LogexportMutation) {
		var (
			err   error
			once  sync.Once
			value *Logexport
		)
		m.oldValue = func(ctx context.Context) (*Logexport, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Logexport.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogexport sets the old Logexport of the mutation.
func withLogexport(node *Logexport) logexportOption {
	return func(m *LogexportMutation) {
		m.oldValue = func(context.Context) (*Logexport, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogexportMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogexportMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Logexport entities.
func (m *LogexportMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *LogexportMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserName sets the "UserName" field.
func (m *LogexportMutation) SetUserName(s string) {
	m._UserName = &s
}

// UserName returns the value of the "UserName" field in the mutation.
func (m *LogexportMutation) UserName() (r string, exists bool) {
	v := m._UserName
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old "UserName" field's value of the Logexport entity.
// If the Logexport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogexportMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ClearUserName clears the value of the "UserName" field.
func (m *LogexportMutation) ClearUserName() {
	m._UserName = nil
	m.clearedFields[logexport.FieldUserName] = struct{}{}
}

// UserNameCleared returns if the "UserName" field was cleared in this mutation.
func (m *LogexportMutation) UserNameCleared() bool {
	_, ok := m.clearedFields[logexport.FieldUserName]
	return ok
}

// ResetUserName resets all changes to the "UserName" field.
func (m *LogexportMutation) ResetUserName() {
	m._UserName = nil
	delete(m.clearedFields, logexport.FieldUserName)
}

// SetFileName sets the "FileName" field.
func (m *LogexportMutation) SetFileName(s string) {
	m._FileName = &s
}

// FileName returns the value of the "FileName" field in the mutation.
func (m *LogexportMutation) FileName() (r string, exists bool) {
	v := m._FileName
	if v == nil {
		return
	}
	return *v, true
}

// OldFileName returns the old "FileName" field's value of the Logexport entity.
// If the Logexport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogexportMutation) OldFileName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileName: %w", err)
	}
	return oldValue.FileName, nil
}

// ClearFileName clears the value of the "FileName" field.
func (m *LogexportMutation) ClearFileName() {
	m._FileName = nil
	m.clearedFields[logexport.FieldFileName] = struct{}{}
}

// FileNameCleared returns if the "FileName" field was cleared in this mutation.
func (m *LogexportMutation) FileNameCleared() bool {
	_, ok := m.clearedFields[logexport.FieldFileName]
	return ok
}

// ResetFileName resets all changes to the "FileName" field.
func (m *LogexportMutation) ResetFileName() {
	m._FileName = nil
	delete(m.clearedFields, logexport.FieldFileName)
}

// SetExportDate sets the "ExportDate" field.
func (m *LogexportMutation) SetExportDate(t time.Time) {
	m._ExportDate = &t
}

// ExportDate returns the value of the "ExportDate" field in the mutation.
func (m *LogexportMutation) ExportDate() (r time.Time, exists bool) {
	v := m._ExportDate
	if v == nil {
		return
	}
	return *v, true
}

// OldExportDate returns the old "ExportDate" field's value of the Logexport entity.
// If the Logexport object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogexportMutation) OldExportDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExportDate: %w", err)
	}
	return oldValue.ExportDate, nil
}

// ClearExportDate clears the value of the "ExportDate" field.
func (m *LogexportMutation) ClearExportDate() {
	m._ExportDate = nil
	m.clearedFields[logexport.FieldExportDate] = struct{}{}
}

// ExportDateCleared returns if the "ExportDate" field was cleared in this mutation.
func (m *LogexportMutation) ExportDateCleared() bool {
	_, ok := m.clearedFields[logexport.FieldExportDate]
	return ok
}

// ResetExportDate resets all changes to the "ExportDate" field.
func (m *LogexportMutation) ResetExportDate() {
	m._ExportDate = nil
	delete(m.clearedFields, logexport.FieldExportDate)
}

// Op returns the operation name.
func (m *LogexportMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Logexport).
func (m *LogexportMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogexportMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._UserName != nil {
		fields = append(fields, logexport.FieldUserName)
	}
	if m._FileName != nil {
		fields = append(fields, logexport.FieldFileName)
	}
	if m._ExportDate != nil {
		fields = append(fields, logexport.FieldExportDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogexportMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logexport.FieldUserName:
		return m.UserName()
	case logexport.FieldFileName:
		return m.FileName()
	case logexport.FieldExportDate:
		return m.ExportDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogexportMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logexport.FieldUserName:
		return m.OldUserName(ctx)
	case logexport.FieldFileName:
		return m.OldFileName(ctx)
	case logexport.FieldExportDate:
		return m.OldExportDate(ctx)
	}
	return nil, fmt.Errorf("unknown Logexport field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogexportMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logexport.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case logexport.FieldFileName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileName(v)
		return nil
	case logexport.FieldExportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExportDate(v)
		return nil
	}
	return fmt.Errorf("unknown Logexport field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogexportMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogexportMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogexportMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Logexport numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogexportMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logexport.FieldUserName) {
		fields = append(fields, logexport.FieldUserName)
	}
	if m.FieldCleared(logexport.FieldFileName) {
		fields = append(fields, logexport.FieldFileName)
	}
	if m.FieldCleared(logexport.FieldExportDate) {
		fields = append(fields, logexport.FieldExportDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogexportMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogexportMutation) ClearField(name string) error {
	switch name {
	case logexport.FieldUserName:
		m.ClearUserName()
		return nil
	case logexport.FieldFileName:
		m.ClearFileName()
		return nil
	case logexport.FieldExportDate:
		m.ClearExportDate()
		return nil
	}
	return fmt.Errorf("unknown Logexport nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogexportMutation) ResetField(name string) error {
	switch name {
	case logexport.FieldUserName:
		m.ResetUserName()
		return nil
	case logexport.FieldFileName:
		m.ResetFileName()
		return nil
	case logexport.FieldExportDate:
		m.ResetExportDate()
		return nil
	}
	return fmt.Errorf("unknown Logexport field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogexportMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogexportMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogexportMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogexportMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogexportMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogexportMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogexportMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Logexport unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogexportMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Logexport edge %s", name)
}

// MerchantTransactionMutation represents an operation that mutates the MerchantTransaction nodes in the graph.
type MerchantTransactionMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	transaction_id        *string
	dateTime              *time.Time
	amount                *float64
	addamount             *float64
	_PaymentType          *string
	_PaymentChannel       *string
	_Status               *string
	_MerchantID           *string
	_TerminalID           *string
	_MerchantFullName     *string
	_FromAccount          *string
	_SettlementAccount    *string
	_MDR_FEETHB           *float64
	add_MDR_FEETHB        *float64
	_TransactionFEETHB    *float64
	add_TransactionFEETHB *float64
	_TotalFeeincVAT       *float64
	add_TotalFeeincVAT    *float64
	_VATTHB               *float64
	add_VATTHB            *float64
	_TotalFeeExcVAT       *float64
	add_TotalFeeExcVAT    *float64
	_WHTTHB               *float64
	add_WHTTHB            *float64
	_NetPayTHB            *float64
	add_NetPayTHB         *float64
	_TransactionType      *string
	_BankCode             *string
	_FileimportID         *int
	add_FileimportID      *int
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*MerchantTransaction, error)
	predicates            []predicate.MerchantTransaction
}

var _ ent.Mutation = (*MerchantTransactionMutation)(nil)

// merchanttransactionOption allows management of the mutation configuration using functional options.
type merchanttransactionOption func(*MerchantTransactionMutation)

// newMerchantTransactionMutation creates new mutation for the MerchantTransaction entity.
func newMerchantTransactionMutation(c config, op Op, opts ...merchanttransactionOption) *MerchantTransactionMutation {
	m := &MerchantTransactionMutation{
		config:        c,
		op:            op,
		typ:           TypeMerchantTransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMerchantTransactionID sets the ID field of the mutation.
func withMerchantTransactionID(id int) merchanttransactionOption {
	return func(m *MerchantTransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *MerchantTransaction
		)
		m.oldValue = func(ctx context.Context) (*MerchantTransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MerchantTransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMerchantTransaction sets the old MerchantTransaction of the mutation.
func withMerchantTransaction(node *MerchantTransaction) merchanttransactionOption {
	return func(m *MerchantTransactionMutation) {
		m.oldValue = func(context.Context) (*MerchantTransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MerchantTransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MerchantTransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MerchantTransaction entities.
func (m *MerchantTransactionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *MerchantTransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTransactionID sets the "transaction_id" field.
func (m *MerchantTransactionMutation) SetTransactionID(s string) {
	m.transaction_id = &s
}

// TransactionID returns the value of the "transaction_id" field in the mutation.
func (m *MerchantTransactionMutation) TransactionID() (r string, exists bool) {
	v := m.transaction_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionID returns the old "transaction_id" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTransactionID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionID: %w", err)
	}
	return oldValue.TransactionID, nil
}

// ClearTransactionID clears the value of the "transaction_id" field.
func (m *MerchantTransactionMutation) ClearTransactionID() {
	m.transaction_id = nil
	m.clearedFields[merchanttransaction.FieldTransactionID] = struct{}{}
}

// TransactionIDCleared returns if the "transaction_id" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TransactionIDCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTransactionID]
	return ok
}

// ResetTransactionID resets all changes to the "transaction_id" field.
func (m *MerchantTransactionMutation) ResetTransactionID() {
	m.transaction_id = nil
	delete(m.clearedFields, merchanttransaction.FieldTransactionID)
}

// SetDateTime sets the "dateTime" field.
func (m *MerchantTransactionMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *MerchantTransactionMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *MerchantTransactionMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[merchanttransaction.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *MerchantTransactionMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *MerchantTransactionMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, merchanttransaction.FieldDateTime)
}

// SetAmount sets the "amount" field.
func (m *MerchantTransactionMutation) SetAmount(f float64) {
	m.amount = &f
	m.addamount = nil
}

// Amount returns the value of the "amount" field in the mutation.
func (m *MerchantTransactionMutation) Amount() (r float64, exists bool) {
	v := m.amount
	if v == nil {
		return
	}
	return *v, true
}

// OldAmount returns the old "amount" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldAmount(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmount: %w", err)
	}
	return oldValue.Amount, nil
}

// AddAmount adds f to the "amount" field.
func (m *MerchantTransactionMutation) AddAmount(f float64) {
	if m.addamount != nil {
		*m.addamount += f
	} else {
		m.addamount = &f
	}
}

// AddedAmount returns the value that was added to the "amount" field in this mutation.
func (m *MerchantTransactionMutation) AddedAmount() (r float64, exists bool) {
	v := m.addamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAmount clears the value of the "amount" field.
func (m *MerchantTransactionMutation) ClearAmount() {
	m.amount = nil
	m.addamount = nil
	m.clearedFields[merchanttransaction.FieldAmount] = struct{}{}
}

// AmountCleared returns if the "amount" field was cleared in this mutation.
func (m *MerchantTransactionMutation) AmountCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldAmount]
	return ok
}

// ResetAmount resets all changes to the "amount" field.
func (m *MerchantTransactionMutation) ResetAmount() {
	m.amount = nil
	m.addamount = nil
	delete(m.clearedFields, merchanttransaction.FieldAmount)
}

// SetPaymentType sets the "PaymentType" field.
func (m *MerchantTransactionMutation) SetPaymentType(s string) {
	m._PaymentType = &s
}

// PaymentType returns the value of the "PaymentType" field in the mutation.
func (m *MerchantTransactionMutation) PaymentType() (r string, exists bool) {
	v := m._PaymentType
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "PaymentType" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldPaymentType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ClearPaymentType clears the value of the "PaymentType" field.
func (m *MerchantTransactionMutation) ClearPaymentType() {
	m._PaymentType = nil
	m.clearedFields[merchanttransaction.FieldPaymentType] = struct{}{}
}

// PaymentTypeCleared returns if the "PaymentType" field was cleared in this mutation.
func (m *MerchantTransactionMutation) PaymentTypeCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldPaymentType]
	return ok
}

// ResetPaymentType resets all changes to the "PaymentType" field.
func (m *MerchantTransactionMutation) ResetPaymentType() {
	m._PaymentType = nil
	delete(m.clearedFields, merchanttransaction.FieldPaymentType)
}

// SetPaymentChannel sets the "PaymentChannel" field.
func (m *MerchantTransactionMutation) SetPaymentChannel(s string) {
	m._PaymentChannel = &s
}

// PaymentChannel returns the value of the "PaymentChannel" field in the mutation.
func (m *MerchantTransactionMutation) PaymentChannel() (r string, exists bool) {
	v := m._PaymentChannel
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentChannel returns the old "PaymentChannel" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldPaymentChannel(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentChannel: %w", err)
	}
	return oldValue.PaymentChannel, nil
}

// ClearPaymentChannel clears the value of the "PaymentChannel" field.
func (m *MerchantTransactionMutation) ClearPaymentChannel() {
	m._PaymentChannel = nil
	m.clearedFields[merchanttransaction.FieldPaymentChannel] = struct{}{}
}

// PaymentChannelCleared returns if the "PaymentChannel" field was cleared in this mutation.
func (m *MerchantTransactionMutation) PaymentChannelCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldPaymentChannel]
	return ok
}

// ResetPaymentChannel resets all changes to the "PaymentChannel" field.
func (m *MerchantTransactionMutation) ResetPaymentChannel() {
	m._PaymentChannel = nil
	delete(m.clearedFields, merchanttransaction.FieldPaymentChannel)
}

// SetStatus sets the "Status" field.
func (m *MerchantTransactionMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *MerchantTransactionMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *MerchantTransactionMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[merchanttransaction.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *MerchantTransactionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *MerchantTransactionMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, merchanttransaction.FieldStatus)
}

// SetMerchantID sets the "MerchantID" field.
func (m *MerchantTransactionMutation) SetMerchantID(s string) {
	m._MerchantID = &s
}

// MerchantID returns the value of the "MerchantID" field in the mutation.
func (m *MerchantTransactionMutation) MerchantID() (r string, exists bool) {
	v := m._MerchantID
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "MerchantID" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldMerchantID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ClearMerchantID clears the value of the "MerchantID" field.
func (m *MerchantTransactionMutation) ClearMerchantID() {
	m._MerchantID = nil
	m.clearedFields[merchanttransaction.FieldMerchantID] = struct{}{}
}

// MerchantIDCleared returns if the "MerchantID" field was cleared in this mutation.
func (m *MerchantTransactionMutation) MerchantIDCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldMerchantID]
	return ok
}

// ResetMerchantID resets all changes to the "MerchantID" field.
func (m *MerchantTransactionMutation) ResetMerchantID() {
	m._MerchantID = nil
	delete(m.clearedFields, merchanttransaction.FieldMerchantID)
}

// SetTerminalID sets the "TerminalID" field.
func (m *MerchantTransactionMutation) SetTerminalID(s string) {
	m._TerminalID = &s
}

// TerminalID returns the value of the "TerminalID" field in the mutation.
func (m *MerchantTransactionMutation) TerminalID() (r string, exists bool) {
	v := m._TerminalID
	if v == nil {
		return
	}
	return *v, true
}

// OldTerminalID returns the old "TerminalID" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTerminalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTerminalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTerminalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTerminalID: %w", err)
	}
	return oldValue.TerminalID, nil
}

// ClearTerminalID clears the value of the "TerminalID" field.
func (m *MerchantTransactionMutation) ClearTerminalID() {
	m._TerminalID = nil
	m.clearedFields[merchanttransaction.FieldTerminalID] = struct{}{}
}

// TerminalIDCleared returns if the "TerminalID" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TerminalIDCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTerminalID]
	return ok
}

// ResetTerminalID resets all changes to the "TerminalID" field.
func (m *MerchantTransactionMutation) ResetTerminalID() {
	m._TerminalID = nil
	delete(m.clearedFields, merchanttransaction.FieldTerminalID)
}

// SetMerchantFullName sets the "MerchantFullName" field.
func (m *MerchantTransactionMutation) SetMerchantFullName(s string) {
	m._MerchantFullName = &s
}

// MerchantFullName returns the value of the "MerchantFullName" field in the mutation.
func (m *MerchantTransactionMutation) MerchantFullName() (r string, exists bool) {
	v := m._MerchantFullName
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantFullName returns the old "MerchantFullName" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldMerchantFullName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMerchantFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMerchantFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantFullName: %w", err)
	}
	return oldValue.MerchantFullName, nil
}

// ClearMerchantFullName clears the value of the "MerchantFullName" field.
func (m *MerchantTransactionMutation) ClearMerchantFullName() {
	m._MerchantFullName = nil
	m.clearedFields[merchanttransaction.FieldMerchantFullName] = struct{}{}
}

// MerchantFullNameCleared returns if the "MerchantFullName" field was cleared in this mutation.
func (m *MerchantTransactionMutation) MerchantFullNameCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldMerchantFullName]
	return ok
}

// ResetMerchantFullName resets all changes to the "MerchantFullName" field.
func (m *MerchantTransactionMutation) ResetMerchantFullName() {
	m._MerchantFullName = nil
	delete(m.clearedFields, merchanttransaction.FieldMerchantFullName)
}

// SetFromAccount sets the "FromAccount" field.
func (m *MerchantTransactionMutation) SetFromAccount(s string) {
	m._FromAccount = &s
}

// FromAccount returns the value of the "FromAccount" field in the mutation.
func (m *MerchantTransactionMutation) FromAccount() (r string, exists bool) {
	v := m._FromAccount
	if v == nil {
		return
	}
	return *v, true
}

// OldFromAccount returns the old "FromAccount" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldFromAccount(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFromAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFromAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromAccount: %w", err)
	}
	return oldValue.FromAccount, nil
}

// ClearFromAccount clears the value of the "FromAccount" field.
func (m *MerchantTransactionMutation) ClearFromAccount() {
	m._FromAccount = nil
	m.clearedFields[merchanttransaction.FieldFromAccount] = struct{}{}
}

// FromAccountCleared returns if the "FromAccount" field was cleared in this mutation.
func (m *MerchantTransactionMutation) FromAccountCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldFromAccount]
	return ok
}

// ResetFromAccount resets all changes to the "FromAccount" field.
func (m *MerchantTransactionMutation) ResetFromAccount() {
	m._FromAccount = nil
	delete(m.clearedFields, merchanttransaction.FieldFromAccount)
}

// SetSettlementAccount sets the "SettlementAccount" field.
func (m *MerchantTransactionMutation) SetSettlementAccount(s string) {
	m._SettlementAccount = &s
}

// SettlementAccount returns the value of the "SettlementAccount" field in the mutation.
func (m *MerchantTransactionMutation) SettlementAccount() (r string, exists bool) {
	v := m._SettlementAccount
	if v == nil {
		return
	}
	return *v, true
}

// OldSettlementAccount returns the old "SettlementAccount" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldSettlementAccount(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSettlementAccount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSettlementAccount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettlementAccount: %w", err)
	}
	return oldValue.SettlementAccount, nil
}

// ClearSettlementAccount clears the value of the "SettlementAccount" field.
func (m *MerchantTransactionMutation) ClearSettlementAccount() {
	m._SettlementAccount = nil
	m.clearedFields[merchanttransaction.FieldSettlementAccount] = struct{}{}
}

// SettlementAccountCleared returns if the "SettlementAccount" field was cleared in this mutation.
func (m *MerchantTransactionMutation) SettlementAccountCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldSettlementAccount]
	return ok
}

// ResetSettlementAccount resets all changes to the "SettlementAccount" field.
func (m *MerchantTransactionMutation) ResetSettlementAccount() {
	m._SettlementAccount = nil
	delete(m.clearedFields, merchanttransaction.FieldSettlementAccount)
}

// SetMDRFEETHB sets the "MDR_FEETHB" field.
func (m *MerchantTransactionMutation) SetMDRFEETHB(f float64) {
	m._MDR_FEETHB = &f
	m.add_MDR_FEETHB = nil
}

// MDRFEETHB returns the value of the "MDR_FEETHB" field in the mutation.
func (m *MerchantTransactionMutation) MDRFEETHB() (r float64, exists bool) {
	v := m._MDR_FEETHB
	if v == nil {
		return
	}
	return *v, true
}

// OldMDRFEETHB returns the old "MDR_FEETHB" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldMDRFEETHB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMDRFEETHB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMDRFEETHB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMDRFEETHB: %w", err)
	}
	return oldValue.MDRFEETHB, nil
}

// AddMDRFEETHB adds f to the "MDR_FEETHB" field.
func (m *MerchantTransactionMutation) AddMDRFEETHB(f float64) {
	if m.add_MDR_FEETHB != nil {
		*m.add_MDR_FEETHB += f
	} else {
		m.add_MDR_FEETHB = &f
	}
}

// AddedMDRFEETHB returns the value that was added to the "MDR_FEETHB" field in this mutation.
func (m *MerchantTransactionMutation) AddedMDRFEETHB() (r float64, exists bool) {
	v := m.add_MDR_FEETHB
	if v == nil {
		return
	}
	return *v, true
}

// ClearMDRFEETHB clears the value of the "MDR_FEETHB" field.
func (m *MerchantTransactionMutation) ClearMDRFEETHB() {
	m._MDR_FEETHB = nil
	m.add_MDR_FEETHB = nil
	m.clearedFields[merchanttransaction.FieldMDRFEETHB] = struct{}{}
}

// MDRFEETHBCleared returns if the "MDR_FEETHB" field was cleared in this mutation.
func (m *MerchantTransactionMutation) MDRFEETHBCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldMDRFEETHB]
	return ok
}

// ResetMDRFEETHB resets all changes to the "MDR_FEETHB" field.
func (m *MerchantTransactionMutation) ResetMDRFEETHB() {
	m._MDR_FEETHB = nil
	m.add_MDR_FEETHB = nil
	delete(m.clearedFields, merchanttransaction.FieldMDRFEETHB)
}

// SetTransactionFEETHB sets the "TransactionFEETHB" field.
func (m *MerchantTransactionMutation) SetTransactionFEETHB(f float64) {
	m._TransactionFEETHB = &f
	m.add_TransactionFEETHB = nil
}

// TransactionFEETHB returns the value of the "TransactionFEETHB" field in the mutation.
func (m *MerchantTransactionMutation) TransactionFEETHB() (r float64, exists bool) {
	v := m._TransactionFEETHB
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionFEETHB returns the old "TransactionFEETHB" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTransactionFEETHB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionFEETHB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionFEETHB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionFEETHB: %w", err)
	}
	return oldValue.TransactionFEETHB, nil
}

// AddTransactionFEETHB adds f to the "TransactionFEETHB" field.
func (m *MerchantTransactionMutation) AddTransactionFEETHB(f float64) {
	if m.add_TransactionFEETHB != nil {
		*m.add_TransactionFEETHB += f
	} else {
		m.add_TransactionFEETHB = &f
	}
}

// AddedTransactionFEETHB returns the value that was added to the "TransactionFEETHB" field in this mutation.
func (m *MerchantTransactionMutation) AddedTransactionFEETHB() (r float64, exists bool) {
	v := m.add_TransactionFEETHB
	if v == nil {
		return
	}
	return *v, true
}

// ClearTransactionFEETHB clears the value of the "TransactionFEETHB" field.
func (m *MerchantTransactionMutation) ClearTransactionFEETHB() {
	m._TransactionFEETHB = nil
	m.add_TransactionFEETHB = nil
	m.clearedFields[merchanttransaction.FieldTransactionFEETHB] = struct{}{}
}

// TransactionFEETHBCleared returns if the "TransactionFEETHB" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TransactionFEETHBCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTransactionFEETHB]
	return ok
}

// ResetTransactionFEETHB resets all changes to the "TransactionFEETHB" field.
func (m *MerchantTransactionMutation) ResetTransactionFEETHB() {
	m._TransactionFEETHB = nil
	m.add_TransactionFEETHB = nil
	delete(m.clearedFields, merchanttransaction.FieldTransactionFEETHB)
}

// SetTotalFeeincVAT sets the "TotalFeeincVAT" field.
func (m *MerchantTransactionMutation) SetTotalFeeincVAT(f float64) {
	m._TotalFeeincVAT = &f
	m.add_TotalFeeincVAT = nil
}

// TotalFeeincVAT returns the value of the "TotalFeeincVAT" field in the mutation.
func (m *MerchantTransactionMutation) TotalFeeincVAT() (r float64, exists bool) {
	v := m._TotalFeeincVAT
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalFeeincVAT returns the old "TotalFeeincVAT" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTotalFeeincVAT(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalFeeincVAT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalFeeincVAT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalFeeincVAT: %w", err)
	}
	return oldValue.TotalFeeincVAT, nil
}

// AddTotalFeeincVAT adds f to the "TotalFeeincVAT" field.
func (m *MerchantTransactionMutation) AddTotalFeeincVAT(f float64) {
	if m.add_TotalFeeincVAT != nil {
		*m.add_TotalFeeincVAT += f
	} else {
		m.add_TotalFeeincVAT = &f
	}
}

// AddedTotalFeeincVAT returns the value that was added to the "TotalFeeincVAT" field in this mutation.
func (m *MerchantTransactionMutation) AddedTotalFeeincVAT() (r float64, exists bool) {
	v := m.add_TotalFeeincVAT
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalFeeincVAT clears the value of the "TotalFeeincVAT" field.
func (m *MerchantTransactionMutation) ClearTotalFeeincVAT() {
	m._TotalFeeincVAT = nil
	m.add_TotalFeeincVAT = nil
	m.clearedFields[merchanttransaction.FieldTotalFeeincVAT] = struct{}{}
}

// TotalFeeincVATCleared returns if the "TotalFeeincVAT" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TotalFeeincVATCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTotalFeeincVAT]
	return ok
}

// ResetTotalFeeincVAT resets all changes to the "TotalFeeincVAT" field.
func (m *MerchantTransactionMutation) ResetTotalFeeincVAT() {
	m._TotalFeeincVAT = nil
	m.add_TotalFeeincVAT = nil
	delete(m.clearedFields, merchanttransaction.FieldTotalFeeincVAT)
}

// SetVATTHB sets the "VATTHB" field.
func (m *MerchantTransactionMutation) SetVATTHB(f float64) {
	m._VATTHB = &f
	m.add_VATTHB = nil
}

// VATTHB returns the value of the "VATTHB" field in the mutation.
func (m *MerchantTransactionMutation) VATTHB() (r float64, exists bool) {
	v := m._VATTHB
	if v == nil {
		return
	}
	return *v, true
}

// OldVATTHB returns the old "VATTHB" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldVATTHB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldVATTHB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldVATTHB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVATTHB: %w", err)
	}
	return oldValue.VATTHB, nil
}

// AddVATTHB adds f to the "VATTHB" field.
func (m *MerchantTransactionMutation) AddVATTHB(f float64) {
	if m.add_VATTHB != nil {
		*m.add_VATTHB += f
	} else {
		m.add_VATTHB = &f
	}
}

// AddedVATTHB returns the value that was added to the "VATTHB" field in this mutation.
func (m *MerchantTransactionMutation) AddedVATTHB() (r float64, exists bool) {
	v := m.add_VATTHB
	if v == nil {
		return
	}
	return *v, true
}

// ClearVATTHB clears the value of the "VATTHB" field.
func (m *MerchantTransactionMutation) ClearVATTHB() {
	m._VATTHB = nil
	m.add_VATTHB = nil
	m.clearedFields[merchanttransaction.FieldVATTHB] = struct{}{}
}

// VATTHBCleared returns if the "VATTHB" field was cleared in this mutation.
func (m *MerchantTransactionMutation) VATTHBCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldVATTHB]
	return ok
}

// ResetVATTHB resets all changes to the "VATTHB" field.
func (m *MerchantTransactionMutation) ResetVATTHB() {
	m._VATTHB = nil
	m.add_VATTHB = nil
	delete(m.clearedFields, merchanttransaction.FieldVATTHB)
}

// SetTotalFeeExcVAT sets the "TotalFeeExcVAT" field.
func (m *MerchantTransactionMutation) SetTotalFeeExcVAT(f float64) {
	m._TotalFeeExcVAT = &f
	m.add_TotalFeeExcVAT = nil
}

// TotalFeeExcVAT returns the value of the "TotalFeeExcVAT" field in the mutation.
func (m *MerchantTransactionMutation) TotalFeeExcVAT() (r float64, exists bool) {
	v := m._TotalFeeExcVAT
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalFeeExcVAT returns the old "TotalFeeExcVAT" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTotalFeeExcVAT(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTotalFeeExcVAT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTotalFeeExcVAT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalFeeExcVAT: %w", err)
	}
	return oldValue.TotalFeeExcVAT, nil
}

// AddTotalFeeExcVAT adds f to the "TotalFeeExcVAT" field.
func (m *MerchantTransactionMutation) AddTotalFeeExcVAT(f float64) {
	if m.add_TotalFeeExcVAT != nil {
		*m.add_TotalFeeExcVAT += f
	} else {
		m.add_TotalFeeExcVAT = &f
	}
}

// AddedTotalFeeExcVAT returns the value that was added to the "TotalFeeExcVAT" field in this mutation.
func (m *MerchantTransactionMutation) AddedTotalFeeExcVAT() (r float64, exists bool) {
	v := m.add_TotalFeeExcVAT
	if v == nil {
		return
	}
	return *v, true
}

// ClearTotalFeeExcVAT clears the value of the "TotalFeeExcVAT" field.
func (m *MerchantTransactionMutation) ClearTotalFeeExcVAT() {
	m._TotalFeeExcVAT = nil
	m.add_TotalFeeExcVAT = nil
	m.clearedFields[merchanttransaction.FieldTotalFeeExcVAT] = struct{}{}
}

// TotalFeeExcVATCleared returns if the "TotalFeeExcVAT" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TotalFeeExcVATCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTotalFeeExcVAT]
	return ok
}

// ResetTotalFeeExcVAT resets all changes to the "TotalFeeExcVAT" field.
func (m *MerchantTransactionMutation) ResetTotalFeeExcVAT() {
	m._TotalFeeExcVAT = nil
	m.add_TotalFeeExcVAT = nil
	delete(m.clearedFields, merchanttransaction.FieldTotalFeeExcVAT)
}

// SetWHTTHB sets the "WHTTHB" field.
func (m *MerchantTransactionMutation) SetWHTTHB(f float64) {
	m._WHTTHB = &f
	m.add_WHTTHB = nil
}

// WHTTHB returns the value of the "WHTTHB" field in the mutation.
func (m *MerchantTransactionMutation) WHTTHB() (r float64, exists bool) {
	v := m._WHTTHB
	if v == nil {
		return
	}
	return *v, true
}

// OldWHTTHB returns the old "WHTTHB" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldWHTTHB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWHTTHB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWHTTHB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWHTTHB: %w", err)
	}
	return oldValue.WHTTHB, nil
}

// AddWHTTHB adds f to the "WHTTHB" field.
func (m *MerchantTransactionMutation) AddWHTTHB(f float64) {
	if m.add_WHTTHB != nil {
		*m.add_WHTTHB += f
	} else {
		m.add_WHTTHB = &f
	}
}

// AddedWHTTHB returns the value that was added to the "WHTTHB" field in this mutation.
func (m *MerchantTransactionMutation) AddedWHTTHB() (r float64, exists bool) {
	v := m.add_WHTTHB
	if v == nil {
		return
	}
	return *v, true
}

// ClearWHTTHB clears the value of the "WHTTHB" field.
func (m *MerchantTransactionMutation) ClearWHTTHB() {
	m._WHTTHB = nil
	m.add_WHTTHB = nil
	m.clearedFields[merchanttransaction.FieldWHTTHB] = struct{}{}
}

// WHTTHBCleared returns if the "WHTTHB" field was cleared in this mutation.
func (m *MerchantTransactionMutation) WHTTHBCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldWHTTHB]
	return ok
}

// ResetWHTTHB resets all changes to the "WHTTHB" field.
func (m *MerchantTransactionMutation) ResetWHTTHB() {
	m._WHTTHB = nil
	m.add_WHTTHB = nil
	delete(m.clearedFields, merchanttransaction.FieldWHTTHB)
}

// SetNetPayTHB sets the "NetPayTHB" field.
func (m *MerchantTransactionMutation) SetNetPayTHB(f float64) {
	m._NetPayTHB = &f
	m.add_NetPayTHB = nil
}

// NetPayTHB returns the value of the "NetPayTHB" field in the mutation.
func (m *MerchantTransactionMutation) NetPayTHB() (r float64, exists bool) {
	v := m._NetPayTHB
	if v == nil {
		return
	}
	return *v, true
}

// OldNetPayTHB returns the old "NetPayTHB" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldNetPayTHB(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNetPayTHB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNetPayTHB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNetPayTHB: %w", err)
	}
	return oldValue.NetPayTHB, nil
}

// AddNetPayTHB adds f to the "NetPayTHB" field.
func (m *MerchantTransactionMutation) AddNetPayTHB(f float64) {
	if m.add_NetPayTHB != nil {
		*m.add_NetPayTHB += f
	} else {
		m.add_NetPayTHB = &f
	}
}

// AddedNetPayTHB returns the value that was added to the "NetPayTHB" field in this mutation.
func (m *MerchantTransactionMutation) AddedNetPayTHB() (r float64, exists bool) {
	v := m.add_NetPayTHB
	if v == nil {
		return
	}
	return *v, true
}

// ClearNetPayTHB clears the value of the "NetPayTHB" field.
func (m *MerchantTransactionMutation) ClearNetPayTHB() {
	m._NetPayTHB = nil
	m.add_NetPayTHB = nil
	m.clearedFields[merchanttransaction.FieldNetPayTHB] = struct{}{}
}

// NetPayTHBCleared returns if the "NetPayTHB" field was cleared in this mutation.
func (m *MerchantTransactionMutation) NetPayTHBCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldNetPayTHB]
	return ok
}

// ResetNetPayTHB resets all changes to the "NetPayTHB" field.
func (m *MerchantTransactionMutation) ResetNetPayTHB() {
	m._NetPayTHB = nil
	m.add_NetPayTHB = nil
	delete(m.clearedFields, merchanttransaction.FieldNetPayTHB)
}

// SetTransactionType sets the "TransactionType" field.
func (m *MerchantTransactionMutation) SetTransactionType(s string) {
	m._TransactionType = &s
}

// TransactionType returns the value of the "TransactionType" field in the mutation.
func (m *MerchantTransactionMutation) TransactionType() (r string, exists bool) {
	v := m._TransactionType
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "TransactionType" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldTransactionType(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ClearTransactionType clears the value of the "TransactionType" field.
func (m *MerchantTransactionMutation) ClearTransactionType() {
	m._TransactionType = nil
	m.clearedFields[merchanttransaction.FieldTransactionType] = struct{}{}
}

// TransactionTypeCleared returns if the "TransactionType" field was cleared in this mutation.
func (m *MerchantTransactionMutation) TransactionTypeCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldTransactionType]
	return ok
}

// ResetTransactionType resets all changes to the "TransactionType" field.
func (m *MerchantTransactionMutation) ResetTransactionType() {
	m._TransactionType = nil
	delete(m.clearedFields, merchanttransaction.FieldTransactionType)
}

// SetBankCode sets the "BankCode" field.
func (m *MerchantTransactionMutation) SetBankCode(s string) {
	m._BankCode = &s
}

// BankCode returns the value of the "BankCode" field in the mutation.
func (m *MerchantTransactionMutation) BankCode() (r string, exists bool) {
	v := m._BankCode
	if v == nil {
		return
	}
	return *v, true
}

// OldBankCode returns the old "BankCode" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldBankCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBankCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBankCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBankCode: %w", err)
	}
	return oldValue.BankCode, nil
}

// ClearBankCode clears the value of the "BankCode" field.
func (m *MerchantTransactionMutation) ClearBankCode() {
	m._BankCode = nil
	m.clearedFields[merchanttransaction.FieldBankCode] = struct{}{}
}

// BankCodeCleared returns if the "BankCode" field was cleared in this mutation.
func (m *MerchantTransactionMutation) BankCodeCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldBankCode]
	return ok
}

// ResetBankCode resets all changes to the "BankCode" field.
func (m *MerchantTransactionMutation) ResetBankCode() {
	m._BankCode = nil
	delete(m.clearedFields, merchanttransaction.FieldBankCode)
}

// SetFileimportID sets the "FileimportID" field.
func (m *MerchantTransactionMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *MerchantTransactionMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the MerchantTransaction entity.
// If the MerchantTransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MerchantTransactionMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *MerchantTransactionMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *MerchantTransactionMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *MerchantTransactionMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[merchanttransaction.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *MerchantTransactionMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[merchanttransaction.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *MerchantTransactionMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, merchanttransaction.FieldFileimportID)
}

// Op returns the operation name.
func (m *MerchantTransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MerchantTransaction).
func (m *MerchantTransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MerchantTransactionMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.transaction_id != nil {
		fields = append(fields, merchanttransaction.FieldTransactionID)
	}
	if m.dateTime != nil {
		fields = append(fields, merchanttransaction.FieldDateTime)
	}
	if m.amount != nil {
		fields = append(fields, merchanttransaction.FieldAmount)
	}
	if m._PaymentType != nil {
		fields = append(fields, merchanttransaction.FieldPaymentType)
	}
	if m._PaymentChannel != nil {
		fields = append(fields, merchanttransaction.FieldPaymentChannel)
	}
	if m._Status != nil {
		fields = append(fields, merchanttransaction.FieldStatus)
	}
	if m._MerchantID != nil {
		fields = append(fields, merchanttransaction.FieldMerchantID)
	}
	if m._TerminalID != nil {
		fields = append(fields, merchanttransaction.FieldTerminalID)
	}
	if m._MerchantFullName != nil {
		fields = append(fields, merchanttransaction.FieldMerchantFullName)
	}
	if m._FromAccount != nil {
		fields = append(fields, merchanttransaction.FieldFromAccount)
	}
	if m._SettlementAccount != nil {
		fields = append(fields, merchanttransaction.FieldSettlementAccount)
	}
	if m._MDR_FEETHB != nil {
		fields = append(fields, merchanttransaction.FieldMDRFEETHB)
	}
	if m._TransactionFEETHB != nil {
		fields = append(fields, merchanttransaction.FieldTransactionFEETHB)
	}
	if m._TotalFeeincVAT != nil {
		fields = append(fields, merchanttransaction.FieldTotalFeeincVAT)
	}
	if m._VATTHB != nil {
		fields = append(fields, merchanttransaction.FieldVATTHB)
	}
	if m._TotalFeeExcVAT != nil {
		fields = append(fields, merchanttransaction.FieldTotalFeeExcVAT)
	}
	if m._WHTTHB != nil {
		fields = append(fields, merchanttransaction.FieldWHTTHB)
	}
	if m._NetPayTHB != nil {
		fields = append(fields, merchanttransaction.FieldNetPayTHB)
	}
	if m._TransactionType != nil {
		fields = append(fields, merchanttransaction.FieldTransactionType)
	}
	if m._BankCode != nil {
		fields = append(fields, merchanttransaction.FieldBankCode)
	}
	if m._FileimportID != nil {
		fields = append(fields, merchanttransaction.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MerchantTransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case merchanttransaction.FieldTransactionID:
		return m.TransactionID()
	case merchanttransaction.FieldDateTime:
		return m.DateTime()
	case merchanttransaction.FieldAmount:
		return m.Amount()
	case merchanttransaction.FieldPaymentType:
		return m.PaymentType()
	case merchanttransaction.FieldPaymentChannel:
		return m.PaymentChannel()
	case merchanttransaction.FieldStatus:
		return m.Status()
	case merchanttransaction.FieldMerchantID:
		return m.MerchantID()
	case merchanttransaction.FieldTerminalID:
		return m.TerminalID()
	case merchanttransaction.FieldMerchantFullName:
		return m.MerchantFullName()
	case merchanttransaction.FieldFromAccount:
		return m.FromAccount()
	case merchanttransaction.FieldSettlementAccount:
		return m.SettlementAccount()
	case merchanttransaction.FieldMDRFEETHB:
		return m.MDRFEETHB()
	case merchanttransaction.FieldTransactionFEETHB:
		return m.TransactionFEETHB()
	case merchanttransaction.FieldTotalFeeincVAT:
		return m.TotalFeeincVAT()
	case merchanttransaction.FieldVATTHB:
		return m.VATTHB()
	case merchanttransaction.FieldTotalFeeExcVAT:
		return m.TotalFeeExcVAT()
	case merchanttransaction.FieldWHTTHB:
		return m.WHTTHB()
	case merchanttransaction.FieldNetPayTHB:
		return m.NetPayTHB()
	case merchanttransaction.FieldTransactionType:
		return m.TransactionType()
	case merchanttransaction.FieldBankCode:
		return m.BankCode()
	case merchanttransaction.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MerchantTransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case merchanttransaction.FieldTransactionID:
		return m.OldTransactionID(ctx)
	case merchanttransaction.FieldDateTime:
		return m.OldDateTime(ctx)
	case merchanttransaction.FieldAmount:
		return m.OldAmount(ctx)
	case merchanttransaction.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case merchanttransaction.FieldPaymentChannel:
		return m.OldPaymentChannel(ctx)
	case merchanttransaction.FieldStatus:
		return m.OldStatus(ctx)
	case merchanttransaction.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case merchanttransaction.FieldTerminalID:
		return m.OldTerminalID(ctx)
	case merchanttransaction.FieldMerchantFullName:
		return m.OldMerchantFullName(ctx)
	case merchanttransaction.FieldFromAccount:
		return m.OldFromAccount(ctx)
	case merchanttransaction.FieldSettlementAccount:
		return m.OldSettlementAccount(ctx)
	case merchanttransaction.FieldMDRFEETHB:
		return m.OldMDRFEETHB(ctx)
	case merchanttransaction.FieldTransactionFEETHB:
		return m.OldTransactionFEETHB(ctx)
	case merchanttransaction.FieldTotalFeeincVAT:
		return m.OldTotalFeeincVAT(ctx)
	case merchanttransaction.FieldVATTHB:
		return m.OldVATTHB(ctx)
	case merchanttransaction.FieldTotalFeeExcVAT:
		return m.OldTotalFeeExcVAT(ctx)
	case merchanttransaction.FieldWHTTHB:
		return m.OldWHTTHB(ctx)
	case merchanttransaction.FieldNetPayTHB:
		return m.OldNetPayTHB(ctx)
	case merchanttransaction.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case merchanttransaction.FieldBankCode:
		return m.OldBankCode(ctx)
	case merchanttransaction.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown MerchantTransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantTransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case merchanttransaction.FieldTransactionID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionID(v)
		return nil
	case merchanttransaction.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case merchanttransaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmount(v)
		return nil
	case merchanttransaction.FieldPaymentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case merchanttransaction.FieldPaymentChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentChannel(v)
		return nil
	case merchanttransaction.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case merchanttransaction.FieldMerchantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case merchanttransaction.FieldTerminalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTerminalID(v)
		return nil
	case merchanttransaction.FieldMerchantFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantFullName(v)
		return nil
	case merchanttransaction.FieldFromAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromAccount(v)
		return nil
	case merchanttransaction.FieldSettlementAccount:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettlementAccount(v)
		return nil
	case merchanttransaction.FieldMDRFEETHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMDRFEETHB(v)
		return nil
	case merchanttransaction.FieldTransactionFEETHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionFEETHB(v)
		return nil
	case merchanttransaction.FieldTotalFeeincVAT:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalFeeincVAT(v)
		return nil
	case merchanttransaction.FieldVATTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVATTHB(v)
		return nil
	case merchanttransaction.FieldTotalFeeExcVAT:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalFeeExcVAT(v)
		return nil
	case merchanttransaction.FieldWHTTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWHTTHB(v)
		return nil
	case merchanttransaction.FieldNetPayTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNetPayTHB(v)
		return nil
	case merchanttransaction.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case merchanttransaction.FieldBankCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBankCode(v)
		return nil
	case merchanttransaction.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantTransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MerchantTransactionMutation) AddedFields() []string {
	var fields []string
	if m.addamount != nil {
		fields = append(fields, merchanttransaction.FieldAmount)
	}
	if m.add_MDR_FEETHB != nil {
		fields = append(fields, merchanttransaction.FieldMDRFEETHB)
	}
	if m.add_TransactionFEETHB != nil {
		fields = append(fields, merchanttransaction.FieldTransactionFEETHB)
	}
	if m.add_TotalFeeincVAT != nil {
		fields = append(fields, merchanttransaction.FieldTotalFeeincVAT)
	}
	if m.add_VATTHB != nil {
		fields = append(fields, merchanttransaction.FieldVATTHB)
	}
	if m.add_TotalFeeExcVAT != nil {
		fields = append(fields, merchanttransaction.FieldTotalFeeExcVAT)
	}
	if m.add_WHTTHB != nil {
		fields = append(fields, merchanttransaction.FieldWHTTHB)
	}
	if m.add_NetPayTHB != nil {
		fields = append(fields, merchanttransaction.FieldNetPayTHB)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, merchanttransaction.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MerchantTransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case merchanttransaction.FieldAmount:
		return m.AddedAmount()
	case merchanttransaction.FieldMDRFEETHB:
		return m.AddedMDRFEETHB()
	case merchanttransaction.FieldTransactionFEETHB:
		return m.AddedTransactionFEETHB()
	case merchanttransaction.FieldTotalFeeincVAT:
		return m.AddedTotalFeeincVAT()
	case merchanttransaction.FieldVATTHB:
		return m.AddedVATTHB()
	case merchanttransaction.FieldTotalFeeExcVAT:
		return m.AddedTotalFeeExcVAT()
	case merchanttransaction.FieldWHTTHB:
		return m.AddedWHTTHB()
	case merchanttransaction.FieldNetPayTHB:
		return m.AddedNetPayTHB()
	case merchanttransaction.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MerchantTransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case merchanttransaction.FieldAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAmount(v)
		return nil
	case merchanttransaction.FieldMDRFEETHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMDRFEETHB(v)
		return nil
	case merchanttransaction.FieldTransactionFEETHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionFEETHB(v)
		return nil
	case merchanttransaction.FieldTotalFeeincVAT:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalFeeincVAT(v)
		return nil
	case merchanttransaction.FieldVATTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVATTHB(v)
		return nil
	case merchanttransaction.FieldTotalFeeExcVAT:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalFeeExcVAT(v)
		return nil
	case merchanttransaction.FieldWHTTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWHTTHB(v)
		return nil
	case merchanttransaction.FieldNetPayTHB:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNetPayTHB(v)
		return nil
	case merchanttransaction.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown MerchantTransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MerchantTransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(merchanttransaction.FieldTransactionID) {
		fields = append(fields, merchanttransaction.FieldTransactionID)
	}
	if m.FieldCleared(merchanttransaction.FieldDateTime) {
		fields = append(fields, merchanttransaction.FieldDateTime)
	}
	if m.FieldCleared(merchanttransaction.FieldAmount) {
		fields = append(fields, merchanttransaction.FieldAmount)
	}
	if m.FieldCleared(merchanttransaction.FieldPaymentType) {
		fields = append(fields, merchanttransaction.FieldPaymentType)
	}
	if m.FieldCleared(merchanttransaction.FieldPaymentChannel) {
		fields = append(fields, merchanttransaction.FieldPaymentChannel)
	}
	if m.FieldCleared(merchanttransaction.FieldStatus) {
		fields = append(fields, merchanttransaction.FieldStatus)
	}
	if m.FieldCleared(merchanttransaction.FieldMerchantID) {
		fields = append(fields, merchanttransaction.FieldMerchantID)
	}
	if m.FieldCleared(merchanttransaction.FieldTerminalID) {
		fields = append(fields, merchanttransaction.FieldTerminalID)
	}
	if m.FieldCleared(merchanttransaction.FieldMerchantFullName) {
		fields = append(fields, merchanttransaction.FieldMerchantFullName)
	}
	if m.FieldCleared(merchanttransaction.FieldFromAccount) {
		fields = append(fields, merchanttransaction.FieldFromAccount)
	}
	if m.FieldCleared(merchanttransaction.FieldSettlementAccount) {
		fields = append(fields, merchanttransaction.FieldSettlementAccount)
	}
	if m.FieldCleared(merchanttransaction.FieldMDRFEETHB) {
		fields = append(fields, merchanttransaction.FieldMDRFEETHB)
	}
	if m.FieldCleared(merchanttransaction.FieldTransactionFEETHB) {
		fields = append(fields, merchanttransaction.FieldTransactionFEETHB)
	}
	if m.FieldCleared(merchanttransaction.FieldTotalFeeincVAT) {
		fields = append(fields, merchanttransaction.FieldTotalFeeincVAT)
	}
	if m.FieldCleared(merchanttransaction.FieldVATTHB) {
		fields = append(fields, merchanttransaction.FieldVATTHB)
	}
	if m.FieldCleared(merchanttransaction.FieldTotalFeeExcVAT) {
		fields = append(fields, merchanttransaction.FieldTotalFeeExcVAT)
	}
	if m.FieldCleared(merchanttransaction.FieldWHTTHB) {
		fields = append(fields, merchanttransaction.FieldWHTTHB)
	}
	if m.FieldCleared(merchanttransaction.FieldNetPayTHB) {
		fields = append(fields, merchanttransaction.FieldNetPayTHB)
	}
	if m.FieldCleared(merchanttransaction.FieldTransactionType) {
		fields = append(fields, merchanttransaction.FieldTransactionType)
	}
	if m.FieldCleared(merchanttransaction.FieldBankCode) {
		fields = append(fields, merchanttransaction.FieldBankCode)
	}
	if m.FieldCleared(merchanttransaction.FieldFileimportID) {
		fields = append(fields, merchanttransaction.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MerchantTransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MerchantTransactionMutation) ClearField(name string) error {
	switch name {
	case merchanttransaction.FieldTransactionID:
		m.ClearTransactionID()
		return nil
	case merchanttransaction.FieldDateTime:
		m.ClearDateTime()
		return nil
	case merchanttransaction.FieldAmount:
		m.ClearAmount()
		return nil
	case merchanttransaction.FieldPaymentType:
		m.ClearPaymentType()
		return nil
	case merchanttransaction.FieldPaymentChannel:
		m.ClearPaymentChannel()
		return nil
	case merchanttransaction.FieldStatus:
		m.ClearStatus()
		return nil
	case merchanttransaction.FieldMerchantID:
		m.ClearMerchantID()
		return nil
	case merchanttransaction.FieldTerminalID:
		m.ClearTerminalID()
		return nil
	case merchanttransaction.FieldMerchantFullName:
		m.ClearMerchantFullName()
		return nil
	case merchanttransaction.FieldFromAccount:
		m.ClearFromAccount()
		return nil
	case merchanttransaction.FieldSettlementAccount:
		m.ClearSettlementAccount()
		return nil
	case merchanttransaction.FieldMDRFEETHB:
		m.ClearMDRFEETHB()
		return nil
	case merchanttransaction.FieldTransactionFEETHB:
		m.ClearTransactionFEETHB()
		return nil
	case merchanttransaction.FieldTotalFeeincVAT:
		m.ClearTotalFeeincVAT()
		return nil
	case merchanttransaction.FieldVATTHB:
		m.ClearVATTHB()
		return nil
	case merchanttransaction.FieldTotalFeeExcVAT:
		m.ClearTotalFeeExcVAT()
		return nil
	case merchanttransaction.FieldWHTTHB:
		m.ClearWHTTHB()
		return nil
	case merchanttransaction.FieldNetPayTHB:
		m.ClearNetPayTHB()
		return nil
	case merchanttransaction.FieldTransactionType:
		m.ClearTransactionType()
		return nil
	case merchanttransaction.FieldBankCode:
		m.ClearBankCode()
		return nil
	case merchanttransaction.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown MerchantTransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MerchantTransactionMutation) ResetField(name string) error {
	switch name {
	case merchanttransaction.FieldTransactionID:
		m.ResetTransactionID()
		return nil
	case merchanttransaction.FieldDateTime:
		m.ResetDateTime()
		return nil
	case merchanttransaction.FieldAmount:
		m.ResetAmount()
		return nil
	case merchanttransaction.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case merchanttransaction.FieldPaymentChannel:
		m.ResetPaymentChannel()
		return nil
	case merchanttransaction.FieldStatus:
		m.ResetStatus()
		return nil
	case merchanttransaction.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case merchanttransaction.FieldTerminalID:
		m.ResetTerminalID()
		return nil
	case merchanttransaction.FieldMerchantFullName:
		m.ResetMerchantFullName()
		return nil
	case merchanttransaction.FieldFromAccount:
		m.ResetFromAccount()
		return nil
	case merchanttransaction.FieldSettlementAccount:
		m.ResetSettlementAccount()
		return nil
	case merchanttransaction.FieldMDRFEETHB:
		m.ResetMDRFEETHB()
		return nil
	case merchanttransaction.FieldTransactionFEETHB:
		m.ResetTransactionFEETHB()
		return nil
	case merchanttransaction.FieldTotalFeeincVAT:
		m.ResetTotalFeeincVAT()
		return nil
	case merchanttransaction.FieldVATTHB:
		m.ResetVATTHB()
		return nil
	case merchanttransaction.FieldTotalFeeExcVAT:
		m.ResetTotalFeeExcVAT()
		return nil
	case merchanttransaction.FieldWHTTHB:
		m.ResetWHTTHB()
		return nil
	case merchanttransaction.FieldNetPayTHB:
		m.ResetNetPayTHB()
		return nil
	case merchanttransaction.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case merchanttransaction.FieldBankCode:
		m.ResetBankCode()
		return nil
	case merchanttransaction.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown MerchantTransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MerchantTransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MerchantTransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MerchantTransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MerchantTransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MerchantTransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MerchantTransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MerchantTransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MerchantTransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MerchantTransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MerchantTransaction edge %s", name)
}

// OccupationhistoryMutation represents an operation that mutates the Occupationhistory nodes in the graph.
type OccupationhistoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_WalletID          *string
	_OccupationName    *string
	_RankOccupation    *int
	add_RankOccupation *int
	_DateCalRank       *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Occupationhistory, error)
	predicates         []predicate.Occupationhistory
}

var _ ent.Mutation = (*OccupationhistoryMutation)(nil)

// occupationhistoryOption allows management of the mutation configuration using functional options.
type occupationhistoryOption func(*OccupationhistoryMutation)

// newOccupationhistoryMutation creates new mutation for the Occupationhistory entity.
func newOccupationhistoryMutation(c config, op Op, opts ...occupationhistoryOption) *OccupationhistoryMutation {
	m := &OccupationhistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOccupationhistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOccupationhistoryID sets the ID field of the mutation.
func withOccupationhistoryID(id int) occupationhistoryOption {
	return func(m *OccupationhistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Occupationhistory
		)
		m.oldValue = func(ctx context.Context) (*Occupationhistory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Occupationhistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOccupationhistory sets the old Occupationhistory of the mutation.
func withOccupationhistory(node *Occupationhistory) occupationhistoryOption {
	return func(m *OccupationhistoryMutation) {
		m.oldValue = func(context.Context) (*Occupationhistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OccupationhistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OccupationhistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Occupationhistory entities.
func (m *OccupationhistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *OccupationhistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *OccupationhistoryMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *OccupationhistoryMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Occupationhistory entity.
// If the Occupationhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationhistoryMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *OccupationhistoryMutation) ResetWalletID() {
	m._WalletID = nil
}

// SetOccupationName sets the "OccupationName" field.
func (m *OccupationhistoryMutation) SetOccupationName(s string) {
	m._OccupationName = &s
}

// OccupationName returns the value of the "OccupationName" field in the mutation.
func (m *OccupationhistoryMutation) OccupationName() (r string, exists bool) {
	v := m._OccupationName
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationName returns the old "OccupationName" field's value of the Occupationhistory entity.
// If the Occupationhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationhistoryMutation) OldOccupationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationName: %w", err)
	}
	return oldValue.OccupationName, nil
}

// ClearOccupationName clears the value of the "OccupationName" field.
func (m *OccupationhistoryMutation) ClearOccupationName() {
	m._OccupationName = nil
	m.clearedFields[occupationhistory.FieldOccupationName] = struct{}{}
}

// OccupationNameCleared returns if the "OccupationName" field was cleared in this mutation.
func (m *OccupationhistoryMutation) OccupationNameCleared() bool {
	_, ok := m.clearedFields[occupationhistory.FieldOccupationName]
	return ok
}

// ResetOccupationName resets all changes to the "OccupationName" field.
func (m *OccupationhistoryMutation) ResetOccupationName() {
	m._OccupationName = nil
	delete(m.clearedFields, occupationhistory.FieldOccupationName)
}

// SetRankOccupation sets the "RankOccupation" field.
func (m *OccupationhistoryMutation) SetRankOccupation(i int) {
	m._RankOccupation = &i
	m.add_RankOccupation = nil
}

// RankOccupation returns the value of the "RankOccupation" field in the mutation.
func (m *OccupationhistoryMutation) RankOccupation() (r int, exists bool) {
	v := m._RankOccupation
	if v == nil {
		return
	}
	return *v, true
}

// OldRankOccupation returns the old "RankOccupation" field's value of the Occupationhistory entity.
// If the Occupationhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationhistoryMutation) OldRankOccupation(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankOccupation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankOccupation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankOccupation: %w", err)
	}
	return oldValue.RankOccupation, nil
}

// AddRankOccupation adds i to the "RankOccupation" field.
func (m *OccupationhistoryMutation) AddRankOccupation(i int) {
	if m.add_RankOccupation != nil {
		*m.add_RankOccupation += i
	} else {
		m.add_RankOccupation = &i
	}
}

// AddedRankOccupation returns the value that was added to the "RankOccupation" field in this mutation.
func (m *OccupationhistoryMutation) AddedRankOccupation() (r int, exists bool) {
	v := m.add_RankOccupation
	if v == nil {
		return
	}
	return *v, true
}

// ClearRankOccupation clears the value of the "RankOccupation" field.
func (m *OccupationhistoryMutation) ClearRankOccupation() {
	m._RankOccupation = nil
	m.add_RankOccupation = nil
	m.clearedFields[occupationhistory.FieldRankOccupation] = struct{}{}
}

// RankOccupationCleared returns if the "RankOccupation" field was cleared in this mutation.
func (m *OccupationhistoryMutation) RankOccupationCleared() bool {
	_, ok := m.clearedFields[occupationhistory.FieldRankOccupation]
	return ok
}

// ResetRankOccupation resets all changes to the "RankOccupation" field.
func (m *OccupationhistoryMutation) ResetRankOccupation() {
	m._RankOccupation = nil
	m.add_RankOccupation = nil
	delete(m.clearedFields, occupationhistory.FieldRankOccupation)
}

// SetDateCalRank sets the "DateCalRank" field.
func (m *OccupationhistoryMutation) SetDateCalRank(t time.Time) {
	m._DateCalRank = &t
}

// DateCalRank returns the value of the "DateCalRank" field in the mutation.
func (m *OccupationhistoryMutation) DateCalRank() (r time.Time, exists bool) {
	v := m._DateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldDateCalRank returns the old "DateCalRank" field's value of the Occupationhistory entity.
// If the Occupationhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OccupationhistoryMutation) OldDateCalRank(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateCalRank: %w", err)
	}
	return oldValue.DateCalRank, nil
}

// ClearDateCalRank clears the value of the "DateCalRank" field.
func (m *OccupationhistoryMutation) ClearDateCalRank() {
	m._DateCalRank = nil
	m.clearedFields[occupationhistory.FieldDateCalRank] = struct{}{}
}

// DateCalRankCleared returns if the "DateCalRank" field was cleared in this mutation.
func (m *OccupationhistoryMutation) DateCalRankCleared() bool {
	_, ok := m.clearedFields[occupationhistory.FieldDateCalRank]
	return ok
}

// ResetDateCalRank resets all changes to the "DateCalRank" field.
func (m *OccupationhistoryMutation) ResetDateCalRank() {
	m._DateCalRank = nil
	delete(m.clearedFields, occupationhistory.FieldDateCalRank)
}

// Op returns the operation name.
func (m *OccupationhistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Occupationhistory).
func (m *OccupationhistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OccupationhistoryMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._WalletID != nil {
		fields = append(fields, occupationhistory.FieldWalletID)
	}
	if m._OccupationName != nil {
		fields = append(fields, occupationhistory.FieldOccupationName)
	}
	if m._RankOccupation != nil {
		fields = append(fields, occupationhistory.FieldRankOccupation)
	}
	if m._DateCalRank != nil {
		fields = append(fields, occupationhistory.FieldDateCalRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OccupationhistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case occupationhistory.FieldWalletID:
		return m.WalletID()
	case occupationhistory.FieldOccupationName:
		return m.OccupationName()
	case occupationhistory.FieldRankOccupation:
		return m.RankOccupation()
	case occupationhistory.FieldDateCalRank:
		return m.DateCalRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OccupationhistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case occupationhistory.FieldWalletID:
		return m.OldWalletID(ctx)
	case occupationhistory.FieldOccupationName:
		return m.OldOccupationName(ctx)
	case occupationhistory.FieldRankOccupation:
		return m.OldRankOccupation(ctx)
	case occupationhistory.FieldDateCalRank:
		return m.OldDateCalRank(ctx)
	}
	return nil, fmt.Errorf("unknown Occupationhistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationhistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case occupationhistory.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case occupationhistory.FieldOccupationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationName(v)
		return nil
	case occupationhistory.FieldRankOccupation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankOccupation(v)
		return nil
	case occupationhistory.FieldDateCalRank:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateCalRank(v)
		return nil
	}
	return fmt.Errorf("unknown Occupationhistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OccupationhistoryMutation) AddedFields() []string {
	var fields []string
	if m.add_RankOccupation != nil {
		fields = append(fields, occupationhistory.FieldRankOccupation)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OccupationhistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case occupationhistory.FieldRankOccupation:
		return m.AddedRankOccupation()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OccupationhistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case occupationhistory.FieldRankOccupation:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRankOccupation(v)
		return nil
	}
	return fmt.Errorf("unknown Occupationhistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OccupationhistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(occupationhistory.FieldOccupationName) {
		fields = append(fields, occupationhistory.FieldOccupationName)
	}
	if m.FieldCleared(occupationhistory.FieldRankOccupation) {
		fields = append(fields, occupationhistory.FieldRankOccupation)
	}
	if m.FieldCleared(occupationhistory.FieldDateCalRank) {
		fields = append(fields, occupationhistory.FieldDateCalRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OccupationhistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OccupationhistoryMutation) ClearField(name string) error {
	switch name {
	case occupationhistory.FieldOccupationName:
		m.ClearOccupationName()
		return nil
	case occupationhistory.FieldRankOccupation:
		m.ClearRankOccupation()
		return nil
	case occupationhistory.FieldDateCalRank:
		m.ClearDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Occupationhistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OccupationhistoryMutation) ResetField(name string) error {
	switch name {
	case occupationhistory.FieldWalletID:
		m.ResetWalletID()
		return nil
	case occupationhistory.FieldOccupationName:
		m.ResetOccupationName()
		return nil
	case occupationhistory.FieldRankOccupation:
		m.ResetRankOccupation()
		return nil
	case occupationhistory.FieldDateCalRank:
		m.ResetDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Occupationhistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OccupationhistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OccupationhistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OccupationhistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OccupationhistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OccupationhistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OccupationhistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OccupationhistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Occupationhistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OccupationhistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Occupationhistory edge %s", name)
}

// PendingkycMutation represents an operation that mutates the Pendingkyc nodes in the graph.
type PendingkycMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_WalletID          *string
	_Name              *string
	_AgentID           *string
	_AgentNameLastname *string
	_KYCDate           *string
	_DateGen           *time.Time
	_StatusGen         *bool
	_Point             *int
	add_Point          *int
	_FileimportID      *int
	add_FileimportID   *int
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*Pendingkyc, error)
	predicates         []predicate.Pendingkyc
}

var _ ent.Mutation = (*PendingkycMutation)(nil)

// pendingkycOption allows management of the mutation configuration using functional options.
type pendingkycOption func(*PendingkycMutation)

// newPendingkycMutation creates new mutation for the Pendingkyc entity.
func newPendingkycMutation(c config, op Op, opts ...pendingkycOption) *PendingkycMutation {
	m := &PendingkycMutation{
		config:        c,
		op:            op,
		typ:           TypePendingkyc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingkycID sets the ID field of the mutation.
func withPendingkycID(id int) pendingkycOption {
	return func(m *PendingkycMutation) {
		var (
			err   error
			once  sync.Once
			value *Pendingkyc
		)
		m.oldValue = func(ctx context.Context) (*Pendingkyc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pendingkyc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingkyc sets the old Pendingkyc of the mutation.
func withPendingkyc(node *Pendingkyc) pendingkycOption {
	return func(m *PendingkycMutation) {
		m.oldValue = func(context.Context) (*Pendingkyc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingkycMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingkycMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pendingkyc entities.
func (m *PendingkycMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PendingkycMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *PendingkycMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PendingkycMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PendingkycMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pendingkyc.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PendingkycMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PendingkycMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pendingkyc.FieldWalletID)
}

// SetName sets the "Name" field.
func (m *PendingkycMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *PendingkycMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *PendingkycMutation) ClearName() {
	m._Name = nil
	m.clearedFields[pendingkyc.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *PendingkycMutation) NameCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *PendingkycMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, pendingkyc.FieldName)
}

// SetAgentID sets the "AgentID" field.
func (m *PendingkycMutation) SetAgentID(s string) {
	m._AgentID = &s
}

// AgentID returns the value of the "AgentID" field in the mutation.
func (m *PendingkycMutation) AgentID() (r string, exists bool) {
	v := m._AgentID
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentID returns the old "AgentID" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldAgentID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentID: %w", err)
	}
	return oldValue.AgentID, nil
}

// ClearAgentID clears the value of the "AgentID" field.
func (m *PendingkycMutation) ClearAgentID() {
	m._AgentID = nil
	m.clearedFields[pendingkyc.FieldAgentID] = struct{}{}
}

// AgentIDCleared returns if the "AgentID" field was cleared in this mutation.
func (m *PendingkycMutation) AgentIDCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldAgentID]
	return ok
}

// ResetAgentID resets all changes to the "AgentID" field.
func (m *PendingkycMutation) ResetAgentID() {
	m._AgentID = nil
	delete(m.clearedFields, pendingkyc.FieldAgentID)
}

// SetAgentNameLastname sets the "AgentNameLastname" field.
func (m *PendingkycMutation) SetAgentNameLastname(s string) {
	m._AgentNameLastname = &s
}

// AgentNameLastname returns the value of the "AgentNameLastname" field in the mutation.
func (m *PendingkycMutation) AgentNameLastname() (r string, exists bool) {
	v := m._AgentNameLastname
	if v == nil {
		return
	}
	return *v, true
}

// OldAgentNameLastname returns the old "AgentNameLastname" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldAgentNameLastname(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAgentNameLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAgentNameLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgentNameLastname: %w", err)
	}
	return oldValue.AgentNameLastname, nil
}

// ClearAgentNameLastname clears the value of the "AgentNameLastname" field.
func (m *PendingkycMutation) ClearAgentNameLastname() {
	m._AgentNameLastname = nil
	m.clearedFields[pendingkyc.FieldAgentNameLastname] = struct{}{}
}

// AgentNameLastnameCleared returns if the "AgentNameLastname" field was cleared in this mutation.
func (m *PendingkycMutation) AgentNameLastnameCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldAgentNameLastname]
	return ok
}

// ResetAgentNameLastname resets all changes to the "AgentNameLastname" field.
func (m *PendingkycMutation) ResetAgentNameLastname() {
	m._AgentNameLastname = nil
	delete(m.clearedFields, pendingkyc.FieldAgentNameLastname)
}

// SetKYCDate sets the "KYCDate" field.
func (m *PendingkycMutation) SetKYCDate(s string) {
	m._KYCDate = &s
}

// KYCDate returns the value of the "KYCDate" field in the mutation.
func (m *PendingkycMutation) KYCDate() (r string, exists bool) {
	v := m._KYCDate
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYCDate" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldKYCDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYCDate" field.
func (m *PendingkycMutation) ClearKYCDate() {
	m._KYCDate = nil
	m.clearedFields[pendingkyc.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYCDate" field was cleared in this mutation.
func (m *PendingkycMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYCDate" field.
func (m *PendingkycMutation) ResetKYCDate() {
	m._KYCDate = nil
	delete(m.clearedFields, pendingkyc.FieldKYCDate)
}

// SetDateGen sets the "DateGen" field.
func (m *PendingkycMutation) SetDateGen(t time.Time) {
	m._DateGen = &t
}

// DateGen returns the value of the "DateGen" field in the mutation.
func (m *PendingkycMutation) DateGen() (r time.Time, exists bool) {
	v := m._DateGen
	if v == nil {
		return
	}
	return *v, true
}

// OldDateGen returns the old "DateGen" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldDateGen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateGen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateGen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateGen: %w", err)
	}
	return oldValue.DateGen, nil
}

// ClearDateGen clears the value of the "DateGen" field.
func (m *PendingkycMutation) ClearDateGen() {
	m._DateGen = nil
	m.clearedFields[pendingkyc.FieldDateGen] = struct{}{}
}

// DateGenCleared returns if the "DateGen" field was cleared in this mutation.
func (m *PendingkycMutation) DateGenCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldDateGen]
	return ok
}

// ResetDateGen resets all changes to the "DateGen" field.
func (m *PendingkycMutation) ResetDateGen() {
	m._DateGen = nil
	delete(m.clearedFields, pendingkyc.FieldDateGen)
}

// SetStatusGen sets the "StatusGen" field.
func (m *PendingkycMutation) SetStatusGen(b bool) {
	m._StatusGen = &b
}

// StatusGen returns the value of the "StatusGen" field in the mutation.
func (m *PendingkycMutation) StatusGen() (r bool, exists bool) {
	v := m._StatusGen
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusGen returns the old "StatusGen" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldStatusGen(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusGen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusGen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusGen: %w", err)
	}
	return oldValue.StatusGen, nil
}

// ClearStatusGen clears the value of the "StatusGen" field.
func (m *PendingkycMutation) ClearStatusGen() {
	m._StatusGen = nil
	m.clearedFields[pendingkyc.FieldStatusGen] = struct{}{}
}

// StatusGenCleared returns if the "StatusGen" field was cleared in this mutation.
func (m *PendingkycMutation) StatusGenCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldStatusGen]
	return ok
}

// ResetStatusGen resets all changes to the "StatusGen" field.
func (m *PendingkycMutation) ResetStatusGen() {
	m._StatusGen = nil
	delete(m.clearedFields, pendingkyc.FieldStatusGen)
}

// SetPoint sets the "Point" field.
func (m *PendingkycMutation) SetPoint(i int) {
	m._Point = &i
	m.add_Point = nil
}

// Point returns the value of the "Point" field in the mutation.
func (m *PendingkycMutation) Point() (r int, exists bool) {
	v := m._Point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "Point" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "Point" field.
func (m *PendingkycMutation) AddPoint(i int) {
	if m.add_Point != nil {
		*m.add_Point += i
	} else {
		m.add_Point = &i
	}
}

// AddedPoint returns the value that was added to the "Point" field in this mutation.
func (m *PendingkycMutation) AddedPoint() (r int, exists bool) {
	v := m.add_Point
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoint clears the value of the "Point" field.
func (m *PendingkycMutation) ClearPoint() {
	m._Point = nil
	m.add_Point = nil
	m.clearedFields[pendingkyc.FieldPoint] = struct{}{}
}

// PointCleared returns if the "Point" field was cleared in this mutation.
func (m *PendingkycMutation) PointCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldPoint]
	return ok
}

// ResetPoint resets all changes to the "Point" field.
func (m *PendingkycMutation) ResetPoint() {
	m._Point = nil
	m.add_Point = nil
	delete(m.clearedFields, pendingkyc.FieldPoint)
}

// SetFileimportID sets the "FileimportID" field.
func (m *PendingkycMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *PendingkycMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Pendingkyc entity.
// If the Pendingkyc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingkycMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *PendingkycMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *PendingkycMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *PendingkycMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[pendingkyc.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *PendingkycMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[pendingkyc.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *PendingkycMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, pendingkyc.FieldFileimportID)
}

// Op returns the operation name.
func (m *PendingkycMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pendingkyc).
func (m *PendingkycMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingkycMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._WalletID != nil {
		fields = append(fields, pendingkyc.FieldWalletID)
	}
	if m._Name != nil {
		fields = append(fields, pendingkyc.FieldName)
	}
	if m._AgentID != nil {
		fields = append(fields, pendingkyc.FieldAgentID)
	}
	if m._AgentNameLastname != nil {
		fields = append(fields, pendingkyc.FieldAgentNameLastname)
	}
	if m._KYCDate != nil {
		fields = append(fields, pendingkyc.FieldKYCDate)
	}
	if m._DateGen != nil {
		fields = append(fields, pendingkyc.FieldDateGen)
	}
	if m._StatusGen != nil {
		fields = append(fields, pendingkyc.FieldStatusGen)
	}
	if m._Point != nil {
		fields = append(fields, pendingkyc.FieldPoint)
	}
	if m._FileimportID != nil {
		fields = append(fields, pendingkyc.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingkycMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingkyc.FieldWalletID:
		return m.WalletID()
	case pendingkyc.FieldName:
		return m.Name()
	case pendingkyc.FieldAgentID:
		return m.AgentID()
	case pendingkyc.FieldAgentNameLastname:
		return m.AgentNameLastname()
	case pendingkyc.FieldKYCDate:
		return m.KYCDate()
	case pendingkyc.FieldDateGen:
		return m.DateGen()
	case pendingkyc.FieldStatusGen:
		return m.StatusGen()
	case pendingkyc.FieldPoint:
		return m.Point()
	case pendingkyc.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingkycMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingkyc.FieldWalletID:
		return m.OldWalletID(ctx)
	case pendingkyc.FieldName:
		return m.OldName(ctx)
	case pendingkyc.FieldAgentID:
		return m.OldAgentID(ctx)
	case pendingkyc.FieldAgentNameLastname:
		return m.OldAgentNameLastname(ctx)
	case pendingkyc.FieldKYCDate:
		return m.OldKYCDate(ctx)
	case pendingkyc.FieldDateGen:
		return m.OldDateGen(ctx)
	case pendingkyc.FieldStatusGen:
		return m.OldStatusGen(ctx)
	case pendingkyc.FieldPoint:
		return m.OldPoint(ctx)
	case pendingkyc.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Pendingkyc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingkycMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingkyc.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pendingkyc.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case pendingkyc.FieldAgentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentID(v)
		return nil
	case pendingkyc.FieldAgentNameLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgentNameLastname(v)
		return nil
	case pendingkyc.FieldKYCDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	case pendingkyc.FieldDateGen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateGen(v)
		return nil
	case pendingkyc.FieldStatusGen:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusGen(v)
		return nil
	case pendingkyc.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case pendingkyc.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Pendingkyc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingkycMutation) AddedFields() []string {
	var fields []string
	if m.add_Point != nil {
		fields = append(fields, pendingkyc.FieldPoint)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, pendingkyc.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingkycMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pendingkyc.FieldPoint:
		return m.AddedPoint()
	case pendingkyc.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingkycMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pendingkyc.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case pendingkyc.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Pendingkyc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingkycMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pendingkyc.FieldWalletID) {
		fields = append(fields, pendingkyc.FieldWalletID)
	}
	if m.FieldCleared(pendingkyc.FieldName) {
		fields = append(fields, pendingkyc.FieldName)
	}
	if m.FieldCleared(pendingkyc.FieldAgentID) {
		fields = append(fields, pendingkyc.FieldAgentID)
	}
	if m.FieldCleared(pendingkyc.FieldAgentNameLastname) {
		fields = append(fields, pendingkyc.FieldAgentNameLastname)
	}
	if m.FieldCleared(pendingkyc.FieldKYCDate) {
		fields = append(fields, pendingkyc.FieldKYCDate)
	}
	if m.FieldCleared(pendingkyc.FieldDateGen) {
		fields = append(fields, pendingkyc.FieldDateGen)
	}
	if m.FieldCleared(pendingkyc.FieldStatusGen) {
		fields = append(fields, pendingkyc.FieldStatusGen)
	}
	if m.FieldCleared(pendingkyc.FieldPoint) {
		fields = append(fields, pendingkyc.FieldPoint)
	}
	if m.FieldCleared(pendingkyc.FieldFileimportID) {
		fields = append(fields, pendingkyc.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingkycMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingkycMutation) ClearField(name string) error {
	switch name {
	case pendingkyc.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pendingkyc.FieldName:
		m.ClearName()
		return nil
	case pendingkyc.FieldAgentID:
		m.ClearAgentID()
		return nil
	case pendingkyc.FieldAgentNameLastname:
		m.ClearAgentNameLastname()
		return nil
	case pendingkyc.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	case pendingkyc.FieldDateGen:
		m.ClearDateGen()
		return nil
	case pendingkyc.FieldStatusGen:
		m.ClearStatusGen()
		return nil
	case pendingkyc.FieldPoint:
		m.ClearPoint()
		return nil
	case pendingkyc.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Pendingkyc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingkycMutation) ResetField(name string) error {
	switch name {
	case pendingkyc.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pendingkyc.FieldName:
		m.ResetName()
		return nil
	case pendingkyc.FieldAgentID:
		m.ResetAgentID()
		return nil
	case pendingkyc.FieldAgentNameLastname:
		m.ResetAgentNameLastname()
		return nil
	case pendingkyc.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	case pendingkyc.FieldDateGen:
		m.ResetDateGen()
		return nil
	case pendingkyc.FieldStatusGen:
		m.ResetStatusGen()
		return nil
	case pendingkyc.FieldPoint:
		m.ResetPoint()
		return nil
	case pendingkyc.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Pendingkyc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingkycMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingkycMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingkycMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingkycMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingkycMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingkycMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingkycMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pendingkyc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingkycMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pendingkyc edge %s", name)
}

// PendingloanbindingMutation represents an operation that mutates the Pendingloanbinding nodes in the graph.
type PendingloanbindingMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_WalletID        *string
	_NameLB          *string
	_StatusGenLB     *bool
	_PointLB         *int
	add_PointLB      *int
	_DateTime        *time.Time
	_DateGenLB       *time.Time
	_FileimportID    *int
	add_FileimportID *int
	_CAWalletID      *string
	_CAPort          *string
	_MainBranch      *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Pendingloanbinding, error)
	predicates       []predicate.Pendingloanbinding
}

var _ ent.Mutation = (*PendingloanbindingMutation)(nil)

// pendingloanbindingOption allows management of the mutation configuration using functional options.
type pendingloanbindingOption func(*PendingloanbindingMutation)

// newPendingloanbindingMutation creates new mutation for the Pendingloanbinding entity.
func newPendingloanbindingMutation(c config, op Op, opts ...pendingloanbindingOption) *PendingloanbindingMutation {
	m := &PendingloanbindingMutation{
		config:        c,
		op:            op,
		typ:           TypePendingloanbinding,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPendingloanbindingID sets the ID field of the mutation.
func withPendingloanbindingID(id int) pendingloanbindingOption {
	return func(m *PendingloanbindingMutation) {
		var (
			err   error
			once  sync.Once
			value *Pendingloanbinding
		)
		m.oldValue = func(ctx context.Context) (*Pendingloanbinding, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pendingloanbinding.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPendingloanbinding sets the old Pendingloanbinding of the mutation.
func withPendingloanbinding(node *Pendingloanbinding) pendingloanbindingOption {
	return func(m *PendingloanbindingMutation) {
		m.oldValue = func(context.Context) (*Pendingloanbinding, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PendingloanbindingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PendingloanbindingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pendingloanbinding entities.
func (m *PendingloanbindingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PendingloanbindingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *PendingloanbindingMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PendingloanbindingMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PendingloanbindingMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pendingloanbinding.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PendingloanbindingMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PendingloanbindingMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pendingloanbinding.FieldWalletID)
}

// SetNameLB sets the "NameLB" field.
func (m *PendingloanbindingMutation) SetNameLB(s string) {
	m._NameLB = &s
}

// NameLB returns the value of the "NameLB" field in the mutation.
func (m *PendingloanbindingMutation) NameLB() (r string, exists bool) {
	v := m._NameLB
	if v == nil {
		return
	}
	return *v, true
}

// OldNameLB returns the old "NameLB" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldNameLB(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNameLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNameLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameLB: %w", err)
	}
	return oldValue.NameLB, nil
}

// ClearNameLB clears the value of the "NameLB" field.
func (m *PendingloanbindingMutation) ClearNameLB() {
	m._NameLB = nil
	m.clearedFields[pendingloanbinding.FieldNameLB] = struct{}{}
}

// NameLBCleared returns if the "NameLB" field was cleared in this mutation.
func (m *PendingloanbindingMutation) NameLBCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldNameLB]
	return ok
}

// ResetNameLB resets all changes to the "NameLB" field.
func (m *PendingloanbindingMutation) ResetNameLB() {
	m._NameLB = nil
	delete(m.clearedFields, pendingloanbinding.FieldNameLB)
}

// SetStatusGenLB sets the "StatusGenLB" field.
func (m *PendingloanbindingMutation) SetStatusGenLB(b bool) {
	m._StatusGenLB = &b
}

// StatusGenLB returns the value of the "StatusGenLB" field in the mutation.
func (m *PendingloanbindingMutation) StatusGenLB() (r bool, exists bool) {
	v := m._StatusGenLB
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusGenLB returns the old "StatusGenLB" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldStatusGenLB(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusGenLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusGenLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusGenLB: %w", err)
	}
	return oldValue.StatusGenLB, nil
}

// ClearStatusGenLB clears the value of the "StatusGenLB" field.
func (m *PendingloanbindingMutation) ClearStatusGenLB() {
	m._StatusGenLB = nil
	m.clearedFields[pendingloanbinding.FieldStatusGenLB] = struct{}{}
}

// StatusGenLBCleared returns if the "StatusGenLB" field was cleared in this mutation.
func (m *PendingloanbindingMutation) StatusGenLBCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldStatusGenLB]
	return ok
}

// ResetStatusGenLB resets all changes to the "StatusGenLB" field.
func (m *PendingloanbindingMutation) ResetStatusGenLB() {
	m._StatusGenLB = nil
	delete(m.clearedFields, pendingloanbinding.FieldStatusGenLB)
}

// SetPointLB sets the "PointLB" field.
func (m *PendingloanbindingMutation) SetPointLB(i int) {
	m._PointLB = &i
	m.add_PointLB = nil
}

// PointLB returns the value of the "PointLB" field in the mutation.
func (m *PendingloanbindingMutation) PointLB() (r int, exists bool) {
	v := m._PointLB
	if v == nil {
		return
	}
	return *v, true
}

// OldPointLB returns the old "PointLB" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldPointLB(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPointLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPointLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointLB: %w", err)
	}
	return oldValue.PointLB, nil
}

// AddPointLB adds i to the "PointLB" field.
func (m *PendingloanbindingMutation) AddPointLB(i int) {
	if m.add_PointLB != nil {
		*m.add_PointLB += i
	} else {
		m.add_PointLB = &i
	}
}

// AddedPointLB returns the value that was added to the "PointLB" field in this mutation.
func (m *PendingloanbindingMutation) AddedPointLB() (r int, exists bool) {
	v := m.add_PointLB
	if v == nil {
		return
	}
	return *v, true
}

// ClearPointLB clears the value of the "PointLB" field.
func (m *PendingloanbindingMutation) ClearPointLB() {
	m._PointLB = nil
	m.add_PointLB = nil
	m.clearedFields[pendingloanbinding.FieldPointLB] = struct{}{}
}

// PointLBCleared returns if the "PointLB" field was cleared in this mutation.
func (m *PendingloanbindingMutation) PointLBCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldPointLB]
	return ok
}

// ResetPointLB resets all changes to the "PointLB" field.
func (m *PendingloanbindingMutation) ResetPointLB() {
	m._PointLB = nil
	m.add_PointLB = nil
	delete(m.clearedFields, pendingloanbinding.FieldPointLB)
}

// SetDateTime sets the "DateTime" field.
func (m *PendingloanbindingMutation) SetDateTime(t time.Time) {
	m._DateTime = &t
}

// DateTime returns the value of the "DateTime" field in the mutation.
func (m *PendingloanbindingMutation) DateTime() (r time.Time, exists bool) {
	v := m._DateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "DateTime" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "DateTime" field.
func (m *PendingloanbindingMutation) ClearDateTime() {
	m._DateTime = nil
	m.clearedFields[pendingloanbinding.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "DateTime" field was cleared in this mutation.
func (m *PendingloanbindingMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "DateTime" field.
func (m *PendingloanbindingMutation) ResetDateTime() {
	m._DateTime = nil
	delete(m.clearedFields, pendingloanbinding.FieldDateTime)
}

// SetDateGenLB sets the "DateGenLB" field.
func (m *PendingloanbindingMutation) SetDateGenLB(t time.Time) {
	m._DateGenLB = &t
}

// DateGenLB returns the value of the "DateGenLB" field in the mutation.
func (m *PendingloanbindingMutation) DateGenLB() (r time.Time, exists bool) {
	v := m._DateGenLB
	if v == nil {
		return
	}
	return *v, true
}

// OldDateGenLB returns the old "DateGenLB" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldDateGenLB(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateGenLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateGenLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateGenLB: %w", err)
	}
	return oldValue.DateGenLB, nil
}

// ClearDateGenLB clears the value of the "DateGenLB" field.
func (m *PendingloanbindingMutation) ClearDateGenLB() {
	m._DateGenLB = nil
	m.clearedFields[pendingloanbinding.FieldDateGenLB] = struct{}{}
}

// DateGenLBCleared returns if the "DateGenLB" field was cleared in this mutation.
func (m *PendingloanbindingMutation) DateGenLBCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldDateGenLB]
	return ok
}

// ResetDateGenLB resets all changes to the "DateGenLB" field.
func (m *PendingloanbindingMutation) ResetDateGenLB() {
	m._DateGenLB = nil
	delete(m.clearedFields, pendingloanbinding.FieldDateGenLB)
}

// SetFileimportID sets the "FileimportID" field.
func (m *PendingloanbindingMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *PendingloanbindingMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *PendingloanbindingMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *PendingloanbindingMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *PendingloanbindingMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[pendingloanbinding.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *PendingloanbindingMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *PendingloanbindingMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, pendingloanbinding.FieldFileimportID)
}

// SetCAWalletID sets the "CAWalletID" field.
func (m *PendingloanbindingMutation) SetCAWalletID(s string) {
	m._CAWalletID = &s
}

// CAWalletID returns the value of the "CAWalletID" field in the mutation.
func (m *PendingloanbindingMutation) CAWalletID() (r string, exists bool) {
	v := m._CAWalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldCAWalletID returns the old "CAWalletID" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldCAWalletID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCAWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCAWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAWalletID: %w", err)
	}
	return oldValue.CAWalletID, nil
}

// ClearCAWalletID clears the value of the "CAWalletID" field.
func (m *PendingloanbindingMutation) ClearCAWalletID() {
	m._CAWalletID = nil
	m.clearedFields[pendingloanbinding.FieldCAWalletID] = struct{}{}
}

// CAWalletIDCleared returns if the "CAWalletID" field was cleared in this mutation.
func (m *PendingloanbindingMutation) CAWalletIDCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldCAWalletID]
	return ok
}

// ResetCAWalletID resets all changes to the "CAWalletID" field.
func (m *PendingloanbindingMutation) ResetCAWalletID() {
	m._CAWalletID = nil
	delete(m.clearedFields, pendingloanbinding.FieldCAWalletID)
}

// SetCAPort sets the "CAPort" field.
func (m *PendingloanbindingMutation) SetCAPort(s string) {
	m._CAPort = &s
}

// CAPort returns the value of the "CAPort" field in the mutation.
func (m *PendingloanbindingMutation) CAPort() (r string, exists bool) {
	v := m._CAPort
	if v == nil {
		return
	}
	return *v, true
}

// OldCAPort returns the old "CAPort" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldCAPort(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCAPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCAPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCAPort: %w", err)
	}
	return oldValue.CAPort, nil
}

// ClearCAPort clears the value of the "CAPort" field.
func (m *PendingloanbindingMutation) ClearCAPort() {
	m._CAPort = nil
	m.clearedFields[pendingloanbinding.FieldCAPort] = struct{}{}
}

// CAPortCleared returns if the "CAPort" field was cleared in this mutation.
func (m *PendingloanbindingMutation) CAPortCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldCAPort]
	return ok
}

// ResetCAPort resets all changes to the "CAPort" field.
func (m *PendingloanbindingMutation) ResetCAPort() {
	m._CAPort = nil
	delete(m.clearedFields, pendingloanbinding.FieldCAPort)
}

// SetMainBranch sets the "MainBranch" field.
func (m *PendingloanbindingMutation) SetMainBranch(s string) {
	m._MainBranch = &s
}

// MainBranch returns the value of the "MainBranch" field in the mutation.
func (m *PendingloanbindingMutation) MainBranch() (r string, exists bool) {
	v := m._MainBranch
	if v == nil {
		return
	}
	return *v, true
}

// OldMainBranch returns the old "MainBranch" field's value of the Pendingloanbinding entity.
// If the Pendingloanbinding object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PendingloanbindingMutation) OldMainBranch(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMainBranch is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMainBranch requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMainBranch: %w", err)
	}
	return oldValue.MainBranch, nil
}

// ClearMainBranch clears the value of the "MainBranch" field.
func (m *PendingloanbindingMutation) ClearMainBranch() {
	m._MainBranch = nil
	m.clearedFields[pendingloanbinding.FieldMainBranch] = struct{}{}
}

// MainBranchCleared returns if the "MainBranch" field was cleared in this mutation.
func (m *PendingloanbindingMutation) MainBranchCleared() bool {
	_, ok := m.clearedFields[pendingloanbinding.FieldMainBranch]
	return ok
}

// ResetMainBranch resets all changes to the "MainBranch" field.
func (m *PendingloanbindingMutation) ResetMainBranch() {
	m._MainBranch = nil
	delete(m.clearedFields, pendingloanbinding.FieldMainBranch)
}

// Op returns the operation name.
func (m *PendingloanbindingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pendingloanbinding).
func (m *PendingloanbindingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PendingloanbindingMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m._WalletID != nil {
		fields = append(fields, pendingloanbinding.FieldWalletID)
	}
	if m._NameLB != nil {
		fields = append(fields, pendingloanbinding.FieldNameLB)
	}
	if m._StatusGenLB != nil {
		fields = append(fields, pendingloanbinding.FieldStatusGenLB)
	}
	if m._PointLB != nil {
		fields = append(fields, pendingloanbinding.FieldPointLB)
	}
	if m._DateTime != nil {
		fields = append(fields, pendingloanbinding.FieldDateTime)
	}
	if m._DateGenLB != nil {
		fields = append(fields, pendingloanbinding.FieldDateGenLB)
	}
	if m._FileimportID != nil {
		fields = append(fields, pendingloanbinding.FieldFileimportID)
	}
	if m._CAWalletID != nil {
		fields = append(fields, pendingloanbinding.FieldCAWalletID)
	}
	if m._CAPort != nil {
		fields = append(fields, pendingloanbinding.FieldCAPort)
	}
	if m._MainBranch != nil {
		fields = append(fields, pendingloanbinding.FieldMainBranch)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PendingloanbindingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pendingloanbinding.FieldWalletID:
		return m.WalletID()
	case pendingloanbinding.FieldNameLB:
		return m.NameLB()
	case pendingloanbinding.FieldStatusGenLB:
		return m.StatusGenLB()
	case pendingloanbinding.FieldPointLB:
		return m.PointLB()
	case pendingloanbinding.FieldDateTime:
		return m.DateTime()
	case pendingloanbinding.FieldDateGenLB:
		return m.DateGenLB()
	case pendingloanbinding.FieldFileimportID:
		return m.FileimportID()
	case pendingloanbinding.FieldCAWalletID:
		return m.CAWalletID()
	case pendingloanbinding.FieldCAPort:
		return m.CAPort()
	case pendingloanbinding.FieldMainBranch:
		return m.MainBranch()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PendingloanbindingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pendingloanbinding.FieldWalletID:
		return m.OldWalletID(ctx)
	case pendingloanbinding.FieldNameLB:
		return m.OldNameLB(ctx)
	case pendingloanbinding.FieldStatusGenLB:
		return m.OldStatusGenLB(ctx)
	case pendingloanbinding.FieldPointLB:
		return m.OldPointLB(ctx)
	case pendingloanbinding.FieldDateTime:
		return m.OldDateTime(ctx)
	case pendingloanbinding.FieldDateGenLB:
		return m.OldDateGenLB(ctx)
	case pendingloanbinding.FieldFileimportID:
		return m.OldFileimportID(ctx)
	case pendingloanbinding.FieldCAWalletID:
		return m.OldCAWalletID(ctx)
	case pendingloanbinding.FieldCAPort:
		return m.OldCAPort(ctx)
	case pendingloanbinding.FieldMainBranch:
		return m.OldMainBranch(ctx)
	}
	return nil, fmt.Errorf("unknown Pendingloanbinding field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingloanbindingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pendingloanbinding.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pendingloanbinding.FieldNameLB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameLB(v)
		return nil
	case pendingloanbinding.FieldStatusGenLB:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusGenLB(v)
		return nil
	case pendingloanbinding.FieldPointLB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointLB(v)
		return nil
	case pendingloanbinding.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case pendingloanbinding.FieldDateGenLB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateGenLB(v)
		return nil
	case pendingloanbinding.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	case pendingloanbinding.FieldCAWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAWalletID(v)
		return nil
	case pendingloanbinding.FieldCAPort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCAPort(v)
		return nil
	case pendingloanbinding.FieldMainBranch:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMainBranch(v)
		return nil
	}
	return fmt.Errorf("unknown Pendingloanbinding field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PendingloanbindingMutation) AddedFields() []string {
	var fields []string
	if m.add_PointLB != nil {
		fields = append(fields, pendingloanbinding.FieldPointLB)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, pendingloanbinding.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PendingloanbindingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pendingloanbinding.FieldPointLB:
		return m.AddedPointLB()
	case pendingloanbinding.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PendingloanbindingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pendingloanbinding.FieldPointLB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointLB(v)
		return nil
	case pendingloanbinding.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Pendingloanbinding numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PendingloanbindingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pendingloanbinding.FieldWalletID) {
		fields = append(fields, pendingloanbinding.FieldWalletID)
	}
	if m.FieldCleared(pendingloanbinding.FieldNameLB) {
		fields = append(fields, pendingloanbinding.FieldNameLB)
	}
	if m.FieldCleared(pendingloanbinding.FieldStatusGenLB) {
		fields = append(fields, pendingloanbinding.FieldStatusGenLB)
	}
	if m.FieldCleared(pendingloanbinding.FieldPointLB) {
		fields = append(fields, pendingloanbinding.FieldPointLB)
	}
	if m.FieldCleared(pendingloanbinding.FieldDateTime) {
		fields = append(fields, pendingloanbinding.FieldDateTime)
	}
	if m.FieldCleared(pendingloanbinding.FieldDateGenLB) {
		fields = append(fields, pendingloanbinding.FieldDateGenLB)
	}
	if m.FieldCleared(pendingloanbinding.FieldFileimportID) {
		fields = append(fields, pendingloanbinding.FieldFileimportID)
	}
	if m.FieldCleared(pendingloanbinding.FieldCAWalletID) {
		fields = append(fields, pendingloanbinding.FieldCAWalletID)
	}
	if m.FieldCleared(pendingloanbinding.FieldCAPort) {
		fields = append(fields, pendingloanbinding.FieldCAPort)
	}
	if m.FieldCleared(pendingloanbinding.FieldMainBranch) {
		fields = append(fields, pendingloanbinding.FieldMainBranch)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PendingloanbindingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PendingloanbindingMutation) ClearField(name string) error {
	switch name {
	case pendingloanbinding.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pendingloanbinding.FieldNameLB:
		m.ClearNameLB()
		return nil
	case pendingloanbinding.FieldStatusGenLB:
		m.ClearStatusGenLB()
		return nil
	case pendingloanbinding.FieldPointLB:
		m.ClearPointLB()
		return nil
	case pendingloanbinding.FieldDateTime:
		m.ClearDateTime()
		return nil
	case pendingloanbinding.FieldDateGenLB:
		m.ClearDateGenLB()
		return nil
	case pendingloanbinding.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	case pendingloanbinding.FieldCAWalletID:
		m.ClearCAWalletID()
		return nil
	case pendingloanbinding.FieldCAPort:
		m.ClearCAPort()
		return nil
	case pendingloanbinding.FieldMainBranch:
		m.ClearMainBranch()
		return nil
	}
	return fmt.Errorf("unknown Pendingloanbinding nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PendingloanbindingMutation) ResetField(name string) error {
	switch name {
	case pendingloanbinding.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pendingloanbinding.FieldNameLB:
		m.ResetNameLB()
		return nil
	case pendingloanbinding.FieldStatusGenLB:
		m.ResetStatusGenLB()
		return nil
	case pendingloanbinding.FieldPointLB:
		m.ResetPointLB()
		return nil
	case pendingloanbinding.FieldDateTime:
		m.ResetDateTime()
		return nil
	case pendingloanbinding.FieldDateGenLB:
		m.ResetDateGenLB()
		return nil
	case pendingloanbinding.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	case pendingloanbinding.FieldCAWalletID:
		m.ResetCAWalletID()
		return nil
	case pendingloanbinding.FieldCAPort:
		m.ResetCAPort()
		return nil
	case pendingloanbinding.FieldMainBranch:
		m.ResetMainBranch()
		return nil
	}
	return fmt.Errorf("unknown Pendingloanbinding field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PendingloanbindingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PendingloanbindingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PendingloanbindingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PendingloanbindingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PendingloanbindingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PendingloanbindingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PendingloanbindingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pendingloanbinding unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PendingloanbindingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pendingloanbinding edge %s", name)
}

// PointcsvMutation represents an operation that mutates the Pointcsv nodes in the graph.
type PointcsvMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_WalletID        *string
	_CreateDate      *time.Time
	_Adjustamount    *int
	add_Adjustamount *int
	_Note            *string
	_PointTranDate   *time.Time
	_ActionExport    *int
	add_ActionExport *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Pointcsv, error)
	predicates       []predicate.Pointcsv
}

var _ ent.Mutation = (*PointcsvMutation)(nil)

// pointcsvOption allows management of the mutation configuration using functional options.
type pointcsvOption func(*PointcsvMutation)

// newPointcsvMutation creates new mutation for the Pointcsv entity.
func newPointcsvMutation(c config, op Op, opts ...pointcsvOption) *PointcsvMutation {
	m := &PointcsvMutation{
		config:        c,
		op:            op,
		typ:           TypePointcsv,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointcsvID sets the ID field of the mutation.
func withPointcsvID(id int) pointcsvOption {
	return func(m *PointcsvMutation) {
		var (
			err   error
			once  sync.Once
			value *Pointcsv
		)
		m.oldValue = func(ctx context.Context) (*Pointcsv, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pointcsv.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointcsv sets the old Pointcsv of the mutation.
func withPointcsv(node *Pointcsv) pointcsvOption {
	return func(m *PointcsvMutation) {
		m.oldValue = func(context.Context) (*Pointcsv, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointcsvMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointcsvMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pointcsv entities.
func (m *PointcsvMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PointcsvMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *PointcsvMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PointcsvMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PointcsvMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pointcsv.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PointcsvMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PointcsvMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pointcsv.FieldWalletID)
}

// SetCreateDate sets the "CreateDate" field.
func (m *PointcsvMutation) SetCreateDate(t time.Time) {
	m._CreateDate = &t
}

// CreateDate returns the value of the "CreateDate" field in the mutation.
func (m *PointcsvMutation) CreateDate() (r time.Time, exists bool) {
	v := m._CreateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateDate returns the old "CreateDate" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldCreateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateDate: %w", err)
	}
	return oldValue.CreateDate, nil
}

// ClearCreateDate clears the value of the "CreateDate" field.
func (m *PointcsvMutation) ClearCreateDate() {
	m._CreateDate = nil
	m.clearedFields[pointcsv.FieldCreateDate] = struct{}{}
}

// CreateDateCleared returns if the "CreateDate" field was cleared in this mutation.
func (m *PointcsvMutation) CreateDateCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldCreateDate]
	return ok
}

// ResetCreateDate resets all changes to the "CreateDate" field.
func (m *PointcsvMutation) ResetCreateDate() {
	m._CreateDate = nil
	delete(m.clearedFields, pointcsv.FieldCreateDate)
}

// SetAdjustamount sets the "Adjustamount" field.
func (m *PointcsvMutation) SetAdjustamount(i int) {
	m._Adjustamount = &i
	m.add_Adjustamount = nil
}

// Adjustamount returns the value of the "Adjustamount" field in the mutation.
func (m *PointcsvMutation) Adjustamount() (r int, exists bool) {
	v := m._Adjustamount
	if v == nil {
		return
	}
	return *v, true
}

// OldAdjustamount returns the old "Adjustamount" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldAdjustamount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdjustamount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdjustamount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdjustamount: %w", err)
	}
	return oldValue.Adjustamount, nil
}

// AddAdjustamount adds i to the "Adjustamount" field.
func (m *PointcsvMutation) AddAdjustamount(i int) {
	if m.add_Adjustamount != nil {
		*m.add_Adjustamount += i
	} else {
		m.add_Adjustamount = &i
	}
}

// AddedAdjustamount returns the value that was added to the "Adjustamount" field in this mutation.
func (m *PointcsvMutation) AddedAdjustamount() (r int, exists bool) {
	v := m.add_Adjustamount
	if v == nil {
		return
	}
	return *v, true
}

// ClearAdjustamount clears the value of the "Adjustamount" field.
func (m *PointcsvMutation) ClearAdjustamount() {
	m._Adjustamount = nil
	m.add_Adjustamount = nil
	m.clearedFields[pointcsv.FieldAdjustamount] = struct{}{}
}

// AdjustamountCleared returns if the "Adjustamount" field was cleared in this mutation.
func (m *PointcsvMutation) AdjustamountCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldAdjustamount]
	return ok
}

// ResetAdjustamount resets all changes to the "Adjustamount" field.
func (m *PointcsvMutation) ResetAdjustamount() {
	m._Adjustamount = nil
	m.add_Adjustamount = nil
	delete(m.clearedFields, pointcsv.FieldAdjustamount)
}

// SetNote sets the "Note" field.
func (m *PointcsvMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *PointcsvMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *PointcsvMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[pointcsv.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *PointcsvMutation) NoteCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *PointcsvMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, pointcsv.FieldNote)
}

// SetPointTranDate sets the "PointTranDate" field.
func (m *PointcsvMutation) SetPointTranDate(t time.Time) {
	m._PointTranDate = &t
}

// PointTranDate returns the value of the "PointTranDate" field in the mutation.
func (m *PointcsvMutation) PointTranDate() (r time.Time, exists bool) {
	v := m._PointTranDate
	if v == nil {
		return
	}
	return *v, true
}

// OldPointTranDate returns the old "PointTranDate" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldPointTranDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPointTranDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPointTranDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointTranDate: %w", err)
	}
	return oldValue.PointTranDate, nil
}

// ClearPointTranDate clears the value of the "PointTranDate" field.
func (m *PointcsvMutation) ClearPointTranDate() {
	m._PointTranDate = nil
	m.clearedFields[pointcsv.FieldPointTranDate] = struct{}{}
}

// PointTranDateCleared returns if the "PointTranDate" field was cleared in this mutation.
func (m *PointcsvMutation) PointTranDateCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldPointTranDate]
	return ok
}

// ResetPointTranDate resets all changes to the "PointTranDate" field.
func (m *PointcsvMutation) ResetPointTranDate() {
	m._PointTranDate = nil
	delete(m.clearedFields, pointcsv.FieldPointTranDate)
}

// SetActionExport sets the "ActionExport" field.
func (m *PointcsvMutation) SetActionExport(i int) {
	m._ActionExport = &i
	m.add_ActionExport = nil
}

// ActionExport returns the value of the "ActionExport" field in the mutation.
func (m *PointcsvMutation) ActionExport() (r int, exists bool) {
	v := m._ActionExport
	if v == nil {
		return
	}
	return *v, true
}

// OldActionExport returns the old "ActionExport" field's value of the Pointcsv entity.
// If the Pointcsv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointcsvMutation) OldActionExport(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActionExport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActionExport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActionExport: %w", err)
	}
	return oldValue.ActionExport, nil
}

// AddActionExport adds i to the "ActionExport" field.
func (m *PointcsvMutation) AddActionExport(i int) {
	if m.add_ActionExport != nil {
		*m.add_ActionExport += i
	} else {
		m.add_ActionExport = &i
	}
}

// AddedActionExport returns the value that was added to the "ActionExport" field in this mutation.
func (m *PointcsvMutation) AddedActionExport() (r int, exists bool) {
	v := m.add_ActionExport
	if v == nil {
		return
	}
	return *v, true
}

// ClearActionExport clears the value of the "ActionExport" field.
func (m *PointcsvMutation) ClearActionExport() {
	m._ActionExport = nil
	m.add_ActionExport = nil
	m.clearedFields[pointcsv.FieldActionExport] = struct{}{}
}

// ActionExportCleared returns if the "ActionExport" field was cleared in this mutation.
func (m *PointcsvMutation) ActionExportCleared() bool {
	_, ok := m.clearedFields[pointcsv.FieldActionExport]
	return ok
}

// ResetActionExport resets all changes to the "ActionExport" field.
func (m *PointcsvMutation) ResetActionExport() {
	m._ActionExport = nil
	m.add_ActionExport = nil
	delete(m.clearedFields, pointcsv.FieldActionExport)
}

// Op returns the operation name.
func (m *PointcsvMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pointcsv).
func (m *PointcsvMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointcsvMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._WalletID != nil {
		fields = append(fields, pointcsv.FieldWalletID)
	}
	if m._CreateDate != nil {
		fields = append(fields, pointcsv.FieldCreateDate)
	}
	if m._Adjustamount != nil {
		fields = append(fields, pointcsv.FieldAdjustamount)
	}
	if m._Note != nil {
		fields = append(fields, pointcsv.FieldNote)
	}
	if m._PointTranDate != nil {
		fields = append(fields, pointcsv.FieldPointTranDate)
	}
	if m._ActionExport != nil {
		fields = append(fields, pointcsv.FieldActionExport)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointcsvMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointcsv.FieldWalletID:
		return m.WalletID()
	case pointcsv.FieldCreateDate:
		return m.CreateDate()
	case pointcsv.FieldAdjustamount:
		return m.Adjustamount()
	case pointcsv.FieldNote:
		return m.Note()
	case pointcsv.FieldPointTranDate:
		return m.PointTranDate()
	case pointcsv.FieldActionExport:
		return m.ActionExport()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointcsvMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointcsv.FieldWalletID:
		return m.OldWalletID(ctx)
	case pointcsv.FieldCreateDate:
		return m.OldCreateDate(ctx)
	case pointcsv.FieldAdjustamount:
		return m.OldAdjustamount(ctx)
	case pointcsv.FieldNote:
		return m.OldNote(ctx)
	case pointcsv.FieldPointTranDate:
		return m.OldPointTranDate(ctx)
	case pointcsv.FieldActionExport:
		return m.OldActionExport(ctx)
	}
	return nil, fmt.Errorf("unknown Pointcsv field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointcsvMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointcsv.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pointcsv.FieldCreateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateDate(v)
		return nil
	case pointcsv.FieldAdjustamount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdjustamount(v)
		return nil
	case pointcsv.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case pointcsv.FieldPointTranDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointTranDate(v)
		return nil
	case pointcsv.FieldActionExport:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActionExport(v)
		return nil
	}
	return fmt.Errorf("unknown Pointcsv field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointcsvMutation) AddedFields() []string {
	var fields []string
	if m.add_Adjustamount != nil {
		fields = append(fields, pointcsv.FieldAdjustamount)
	}
	if m.add_ActionExport != nil {
		fields = append(fields, pointcsv.FieldActionExport)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointcsvMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointcsv.FieldAdjustamount:
		return m.AddedAdjustamount()
	case pointcsv.FieldActionExport:
		return m.AddedActionExport()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointcsvMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointcsv.FieldAdjustamount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdjustamount(v)
		return nil
	case pointcsv.FieldActionExport:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddActionExport(v)
		return nil
	}
	return fmt.Errorf("unknown Pointcsv numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointcsvMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointcsv.FieldWalletID) {
		fields = append(fields, pointcsv.FieldWalletID)
	}
	if m.FieldCleared(pointcsv.FieldCreateDate) {
		fields = append(fields, pointcsv.FieldCreateDate)
	}
	if m.FieldCleared(pointcsv.FieldAdjustamount) {
		fields = append(fields, pointcsv.FieldAdjustamount)
	}
	if m.FieldCleared(pointcsv.FieldNote) {
		fields = append(fields, pointcsv.FieldNote)
	}
	if m.FieldCleared(pointcsv.FieldPointTranDate) {
		fields = append(fields, pointcsv.FieldPointTranDate)
	}
	if m.FieldCleared(pointcsv.FieldActionExport) {
		fields = append(fields, pointcsv.FieldActionExport)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointcsvMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointcsvMutation) ClearField(name string) error {
	switch name {
	case pointcsv.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pointcsv.FieldCreateDate:
		m.ClearCreateDate()
		return nil
	case pointcsv.FieldAdjustamount:
		m.ClearAdjustamount()
		return nil
	case pointcsv.FieldNote:
		m.ClearNote()
		return nil
	case pointcsv.FieldPointTranDate:
		m.ClearPointTranDate()
		return nil
	case pointcsv.FieldActionExport:
		m.ClearActionExport()
		return nil
	}
	return fmt.Errorf("unknown Pointcsv nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointcsvMutation) ResetField(name string) error {
	switch name {
	case pointcsv.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pointcsv.FieldCreateDate:
		m.ResetCreateDate()
		return nil
	case pointcsv.FieldAdjustamount:
		m.ResetAdjustamount()
		return nil
	case pointcsv.FieldNote:
		m.ResetNote()
		return nil
	case pointcsv.FieldPointTranDate:
		m.ResetPointTranDate()
		return nil
	case pointcsv.FieldActionExport:
		m.ResetActionExport()
		return nil
	}
	return fmt.Errorf("unknown Pointcsv field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointcsvMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointcsvMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointcsvMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointcsvMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointcsvMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointcsvMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointcsvMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pointcsv unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointcsvMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pointcsv edge %s", name)
}

// PointkycrvMutation represents an operation that mutates the Pointkycrv nodes in the graph.
type PointkycrvMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_DateTimeGen     *time.Time
	_WalletID        *string
	_StatusGen       *string
	_KYCDate         *time.Time
	_RVDate          *time.Time
	_Type            *string
	_Point           *int
	add_Point        *int
	_FileimportID    *int
	add_FileimportID *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Pointkycrv, error)
	predicates       []predicate.Pointkycrv
}

var _ ent.Mutation = (*PointkycrvMutation)(nil)

// pointkycrvOption allows management of the mutation configuration using functional options.
type pointkycrvOption func(*PointkycrvMutation)

// newPointkycrvMutation creates new mutation for the Pointkycrv entity.
func newPointkycrvMutation(c config, op Op, opts ...pointkycrvOption) *PointkycrvMutation {
	m := &PointkycrvMutation{
		config:        c,
		op:            op,
		typ:           TypePointkycrv,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointkycrvID sets the ID field of the mutation.
func withPointkycrvID(id int) pointkycrvOption {
	return func(m *PointkycrvMutation) {
		var (
			err   error
			once  sync.Once
			value *Pointkycrv
		)
		m.oldValue = func(ctx context.Context) (*Pointkycrv, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pointkycrv.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointkycrv sets the old Pointkycrv of the mutation.
func withPointkycrv(node *Pointkycrv) pointkycrvOption {
	return func(m *PointkycrvMutation) {
		m.oldValue = func(context.Context) (*Pointkycrv, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointkycrvMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointkycrvMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pointkycrv entities.
func (m *PointkycrvMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PointkycrvMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDateTimeGen sets the "DateTimeGen" field.
func (m *PointkycrvMutation) SetDateTimeGen(t time.Time) {
	m._DateTimeGen = &t
}

// DateTimeGen returns the value of the "DateTimeGen" field in the mutation.
func (m *PointkycrvMutation) DateTimeGen() (r time.Time, exists bool) {
	v := m._DateTimeGen
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTimeGen returns the old "DateTimeGen" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldDateTimeGen(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTimeGen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTimeGen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTimeGen: %w", err)
	}
	return oldValue.DateTimeGen, nil
}

// ClearDateTimeGen clears the value of the "DateTimeGen" field.
func (m *PointkycrvMutation) ClearDateTimeGen() {
	m._DateTimeGen = nil
	m.clearedFields[pointkycrv.FieldDateTimeGen] = struct{}{}
}

// DateTimeGenCleared returns if the "DateTimeGen" field was cleared in this mutation.
func (m *PointkycrvMutation) DateTimeGenCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldDateTimeGen]
	return ok
}

// ResetDateTimeGen resets all changes to the "DateTimeGen" field.
func (m *PointkycrvMutation) ResetDateTimeGen() {
	m._DateTimeGen = nil
	delete(m.clearedFields, pointkycrv.FieldDateTimeGen)
}

// SetWalletID sets the "WalletID" field.
func (m *PointkycrvMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PointkycrvMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PointkycrvMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pointkycrv.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PointkycrvMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PointkycrvMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pointkycrv.FieldWalletID)
}

// SetStatusGen sets the "StatusGen" field.
func (m *PointkycrvMutation) SetStatusGen(s string) {
	m._StatusGen = &s
}

// StatusGen returns the value of the "StatusGen" field in the mutation.
func (m *PointkycrvMutation) StatusGen() (r string, exists bool) {
	v := m._StatusGen
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusGen returns the old "StatusGen" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldStatusGen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusGen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusGen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusGen: %w", err)
	}
	return oldValue.StatusGen, nil
}

// ClearStatusGen clears the value of the "StatusGen" field.
func (m *PointkycrvMutation) ClearStatusGen() {
	m._StatusGen = nil
	m.clearedFields[pointkycrv.FieldStatusGen] = struct{}{}
}

// StatusGenCleared returns if the "StatusGen" field was cleared in this mutation.
func (m *PointkycrvMutation) StatusGenCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldStatusGen]
	return ok
}

// ResetStatusGen resets all changes to the "StatusGen" field.
func (m *PointkycrvMutation) ResetStatusGen() {
	m._StatusGen = nil
	delete(m.clearedFields, pointkycrv.FieldStatusGen)
}

// SetKYCDate sets the "KYCDate" field.
func (m *PointkycrvMutation) SetKYCDate(t time.Time) {
	m._KYCDate = &t
}

// KYCDate returns the value of the "KYCDate" field in the mutation.
func (m *PointkycrvMutation) KYCDate() (r time.Time, exists bool) {
	v := m._KYCDate
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYCDate" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldKYCDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYCDate" field.
func (m *PointkycrvMutation) ClearKYCDate() {
	m._KYCDate = nil
	m.clearedFields[pointkycrv.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYCDate" field was cleared in this mutation.
func (m *PointkycrvMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYCDate" field.
func (m *PointkycrvMutation) ResetKYCDate() {
	m._KYCDate = nil
	delete(m.clearedFields, pointkycrv.FieldKYCDate)
}

// SetRVDate sets the "RVDate" field.
func (m *PointkycrvMutation) SetRVDate(t time.Time) {
	m._RVDate = &t
}

// RVDate returns the value of the "RVDate" field in the mutation.
func (m *PointkycrvMutation) RVDate() (r time.Time, exists bool) {
	v := m._RVDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRVDate returns the old "RVDate" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldRVDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRVDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRVDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRVDate: %w", err)
	}
	return oldValue.RVDate, nil
}

// ClearRVDate clears the value of the "RVDate" field.
func (m *PointkycrvMutation) ClearRVDate() {
	m._RVDate = nil
	m.clearedFields[pointkycrv.FieldRVDate] = struct{}{}
}

// RVDateCleared returns if the "RVDate" field was cleared in this mutation.
func (m *PointkycrvMutation) RVDateCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldRVDate]
	return ok
}

// ResetRVDate resets all changes to the "RVDate" field.
func (m *PointkycrvMutation) ResetRVDate() {
	m._RVDate = nil
	delete(m.clearedFields, pointkycrv.FieldRVDate)
}

// SetType sets the "Type" field.
func (m *PointkycrvMutation) SetType(s string) {
	m._Type = &s
}

// GetType returns the value of the "Type" field in the mutation.
func (m *PointkycrvMutation) GetType() (r string, exists bool) {
	v := m._Type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "Type" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "Type" field.
func (m *PointkycrvMutation) ClearType() {
	m._Type = nil
	m.clearedFields[pointkycrv.FieldType] = struct{}{}
}

// TypeCleared returns if the "Type" field was cleared in this mutation.
func (m *PointkycrvMutation) TypeCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldType]
	return ok
}

// ResetType resets all changes to the "Type" field.
func (m *PointkycrvMutation) ResetType() {
	m._Type = nil
	delete(m.clearedFields, pointkycrv.FieldType)
}

// SetPoint sets the "Point" field.
func (m *PointkycrvMutation) SetPoint(i int) {
	m._Point = &i
	m.add_Point = nil
}

// Point returns the value of the "Point" field in the mutation.
func (m *PointkycrvMutation) Point() (r int, exists bool) {
	v := m._Point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "Point" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "Point" field.
func (m *PointkycrvMutation) AddPoint(i int) {
	if m.add_Point != nil {
		*m.add_Point += i
	} else {
		m.add_Point = &i
	}
}

// AddedPoint returns the value that was added to the "Point" field in this mutation.
func (m *PointkycrvMutation) AddedPoint() (r int, exists bool) {
	v := m.add_Point
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoint clears the value of the "Point" field.
func (m *PointkycrvMutation) ClearPoint() {
	m._Point = nil
	m.add_Point = nil
	m.clearedFields[pointkycrv.FieldPoint] = struct{}{}
}

// PointCleared returns if the "Point" field was cleared in this mutation.
func (m *PointkycrvMutation) PointCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldPoint]
	return ok
}

// ResetPoint resets all changes to the "Point" field.
func (m *PointkycrvMutation) ResetPoint() {
	m._Point = nil
	m.add_Point = nil
	delete(m.clearedFields, pointkycrv.FieldPoint)
}

// SetFileimportID sets the "FileimportID" field.
func (m *PointkycrvMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *PointkycrvMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Pointkycrv entity.
// If the Pointkycrv object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointkycrvMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *PointkycrvMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *PointkycrvMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *PointkycrvMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[pointkycrv.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *PointkycrvMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[pointkycrv.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *PointkycrvMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, pointkycrv.FieldFileimportID)
}

// Op returns the operation name.
func (m *PointkycrvMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pointkycrv).
func (m *PointkycrvMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointkycrvMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._DateTimeGen != nil {
		fields = append(fields, pointkycrv.FieldDateTimeGen)
	}
	if m._WalletID != nil {
		fields = append(fields, pointkycrv.FieldWalletID)
	}
	if m._StatusGen != nil {
		fields = append(fields, pointkycrv.FieldStatusGen)
	}
	if m._KYCDate != nil {
		fields = append(fields, pointkycrv.FieldKYCDate)
	}
	if m._RVDate != nil {
		fields = append(fields, pointkycrv.FieldRVDate)
	}
	if m._Type != nil {
		fields = append(fields, pointkycrv.FieldType)
	}
	if m._Point != nil {
		fields = append(fields, pointkycrv.FieldPoint)
	}
	if m._FileimportID != nil {
		fields = append(fields, pointkycrv.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointkycrvMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointkycrv.FieldDateTimeGen:
		return m.DateTimeGen()
	case pointkycrv.FieldWalletID:
		return m.WalletID()
	case pointkycrv.FieldStatusGen:
		return m.StatusGen()
	case pointkycrv.FieldKYCDate:
		return m.KYCDate()
	case pointkycrv.FieldRVDate:
		return m.RVDate()
	case pointkycrv.FieldType:
		return m.GetType()
	case pointkycrv.FieldPoint:
		return m.Point()
	case pointkycrv.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointkycrvMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointkycrv.FieldDateTimeGen:
		return m.OldDateTimeGen(ctx)
	case pointkycrv.FieldWalletID:
		return m.OldWalletID(ctx)
	case pointkycrv.FieldStatusGen:
		return m.OldStatusGen(ctx)
	case pointkycrv.FieldKYCDate:
		return m.OldKYCDate(ctx)
	case pointkycrv.FieldRVDate:
		return m.OldRVDate(ctx)
	case pointkycrv.FieldType:
		return m.OldType(ctx)
	case pointkycrv.FieldPoint:
		return m.OldPoint(ctx)
	case pointkycrv.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Pointkycrv field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointkycrvMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointkycrv.FieldDateTimeGen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTimeGen(v)
		return nil
	case pointkycrv.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pointkycrv.FieldStatusGen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusGen(v)
		return nil
	case pointkycrv.FieldKYCDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	case pointkycrv.FieldRVDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRVDate(v)
		return nil
	case pointkycrv.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case pointkycrv.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case pointkycrv.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Pointkycrv field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointkycrvMutation) AddedFields() []string {
	var fields []string
	if m.add_Point != nil {
		fields = append(fields, pointkycrv.FieldPoint)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, pointkycrv.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointkycrvMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointkycrv.FieldPoint:
		return m.AddedPoint()
	case pointkycrv.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointkycrvMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointkycrv.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	case pointkycrv.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Pointkycrv numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointkycrvMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointkycrv.FieldDateTimeGen) {
		fields = append(fields, pointkycrv.FieldDateTimeGen)
	}
	if m.FieldCleared(pointkycrv.FieldWalletID) {
		fields = append(fields, pointkycrv.FieldWalletID)
	}
	if m.FieldCleared(pointkycrv.FieldStatusGen) {
		fields = append(fields, pointkycrv.FieldStatusGen)
	}
	if m.FieldCleared(pointkycrv.FieldKYCDate) {
		fields = append(fields, pointkycrv.FieldKYCDate)
	}
	if m.FieldCleared(pointkycrv.FieldRVDate) {
		fields = append(fields, pointkycrv.FieldRVDate)
	}
	if m.FieldCleared(pointkycrv.FieldType) {
		fields = append(fields, pointkycrv.FieldType)
	}
	if m.FieldCleared(pointkycrv.FieldPoint) {
		fields = append(fields, pointkycrv.FieldPoint)
	}
	if m.FieldCleared(pointkycrv.FieldFileimportID) {
		fields = append(fields, pointkycrv.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointkycrvMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointkycrvMutation) ClearField(name string) error {
	switch name {
	case pointkycrv.FieldDateTimeGen:
		m.ClearDateTimeGen()
		return nil
	case pointkycrv.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pointkycrv.FieldStatusGen:
		m.ClearStatusGen()
		return nil
	case pointkycrv.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	case pointkycrv.FieldRVDate:
		m.ClearRVDate()
		return nil
	case pointkycrv.FieldType:
		m.ClearType()
		return nil
	case pointkycrv.FieldPoint:
		m.ClearPoint()
		return nil
	case pointkycrv.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Pointkycrv nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointkycrvMutation) ResetField(name string) error {
	switch name {
	case pointkycrv.FieldDateTimeGen:
		m.ResetDateTimeGen()
		return nil
	case pointkycrv.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pointkycrv.FieldStatusGen:
		m.ResetStatusGen()
		return nil
	case pointkycrv.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	case pointkycrv.FieldRVDate:
		m.ResetRVDate()
		return nil
	case pointkycrv.FieldType:
		m.ResetType()
		return nil
	case pointkycrv.FieldPoint:
		m.ResetPoint()
		return nil
	case pointkycrv.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Pointkycrv field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointkycrvMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointkycrvMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointkycrvMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointkycrvMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointkycrvMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointkycrvMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointkycrvMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pointkycrv unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointkycrvMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pointkycrv edge %s", name)
}

// PointpendingkyctransactionMutation represents an operation that mutates the Pointpendingkyctransaction nodes in the graph.
type PointpendingkyctransactionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_WalletId     *string
	_Point        *int
	add_Point     *int
	_DateExport   *time.Time
	_DateGen      *time.Time
	_Note         *string
	_StatusExport *bool
	_KYCDate      *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Pointpendingkyctransaction, error)
	predicates    []predicate.Pointpendingkyctransaction
}

var _ ent.Mutation = (*PointpendingkyctransactionMutation)(nil)

// pointpendingkyctransactionOption allows management of the mutation configuration using functional options.
type pointpendingkyctransactionOption func(*PointpendingkyctransactionMutation)

// newPointpendingkyctransactionMutation creates new mutation for the Pointpendingkyctransaction entity.
func newPointpendingkyctransactionMutation(c config, op Op, opts ...pointpendingkyctransactionOption) *PointpendingkyctransactionMutation {
	m := &PointpendingkyctransactionMutation{
		config:        c,
		op:            op,
		typ:           TypePointpendingkyctransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointpendingkyctransactionID sets the ID field of the mutation.
func withPointpendingkyctransactionID(id int) pointpendingkyctransactionOption {
	return func(m *PointpendingkyctransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Pointpendingkyctransaction
		)
		m.oldValue = func(ctx context.Context) (*Pointpendingkyctransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pointpendingkyctransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointpendingkyctransaction sets the old Pointpendingkyctransaction of the mutation.
func withPointpendingkyctransaction(node *Pointpendingkyctransaction) pointpendingkyctransactionOption {
	return func(m *PointpendingkyctransactionMutation) {
		m.oldValue = func(context.Context) (*Pointpendingkyctransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointpendingkyctransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointpendingkyctransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pointpendingkyctransaction entities.
func (m *PointpendingkyctransactionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PointpendingkyctransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletId sets the "WalletId" field.
func (m *PointpendingkyctransactionMutation) SetWalletId(s string) {
	m._WalletId = &s
}

// WalletId returns the value of the "WalletId" field in the mutation.
func (m *PointpendingkyctransactionMutation) WalletId() (r string, exists bool) {
	v := m._WalletId
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletId returns the old "WalletId" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldWalletId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletId: %w", err)
	}
	return oldValue.WalletId, nil
}

// ClearWalletId clears the value of the "WalletId" field.
func (m *PointpendingkyctransactionMutation) ClearWalletId() {
	m._WalletId = nil
	m.clearedFields[pointpendingkyctransaction.FieldWalletId] = struct{}{}
}

// WalletIdCleared returns if the "WalletId" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) WalletIdCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldWalletId]
	return ok
}

// ResetWalletId resets all changes to the "WalletId" field.
func (m *PointpendingkyctransactionMutation) ResetWalletId() {
	m._WalletId = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldWalletId)
}

// SetPoint sets the "Point" field.
func (m *PointpendingkyctransactionMutation) SetPoint(i int) {
	m._Point = &i
	m.add_Point = nil
}

// Point returns the value of the "Point" field in the mutation.
func (m *PointpendingkyctransactionMutation) Point() (r int, exists bool) {
	v := m._Point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "Point" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldPoint(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "Point" field.
func (m *PointpendingkyctransactionMutation) AddPoint(i int) {
	if m.add_Point != nil {
		*m.add_Point += i
	} else {
		m.add_Point = &i
	}
}

// AddedPoint returns the value that was added to the "Point" field in this mutation.
func (m *PointpendingkyctransactionMutation) AddedPoint() (r int, exists bool) {
	v := m.add_Point
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoint clears the value of the "Point" field.
func (m *PointpendingkyctransactionMutation) ClearPoint() {
	m._Point = nil
	m.add_Point = nil
	m.clearedFields[pointpendingkyctransaction.FieldPoint] = struct{}{}
}

// PointCleared returns if the "Point" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) PointCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldPoint]
	return ok
}

// ResetPoint resets all changes to the "Point" field.
func (m *PointpendingkyctransactionMutation) ResetPoint() {
	m._Point = nil
	m.add_Point = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldPoint)
}

// SetDateExport sets the "DateExport" field.
func (m *PointpendingkyctransactionMutation) SetDateExport(t time.Time) {
	m._DateExport = &t
}

// DateExport returns the value of the "DateExport" field in the mutation.
func (m *PointpendingkyctransactionMutation) DateExport() (r time.Time, exists bool) {
	v := m._DateExport
	if v == nil {
		return
	}
	return *v, true
}

// OldDateExport returns the old "DateExport" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldDateExport(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateExport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateExport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateExport: %w", err)
	}
	return oldValue.DateExport, nil
}

// ClearDateExport clears the value of the "DateExport" field.
func (m *PointpendingkyctransactionMutation) ClearDateExport() {
	m._DateExport = nil
	m.clearedFields[pointpendingkyctransaction.FieldDateExport] = struct{}{}
}

// DateExportCleared returns if the "DateExport" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) DateExportCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldDateExport]
	return ok
}

// ResetDateExport resets all changes to the "DateExport" field.
func (m *PointpendingkyctransactionMutation) ResetDateExport() {
	m._DateExport = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldDateExport)
}

// SetDateGen sets the "DateGen" field.
func (m *PointpendingkyctransactionMutation) SetDateGen(t time.Time) {
	m._DateGen = &t
}

// DateGen returns the value of the "DateGen" field in the mutation.
func (m *PointpendingkyctransactionMutation) DateGen() (r time.Time, exists bool) {
	v := m._DateGen
	if v == nil {
		return
	}
	return *v, true
}

// OldDateGen returns the old "DateGen" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldDateGen(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateGen is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateGen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateGen: %w", err)
	}
	return oldValue.DateGen, nil
}

// ClearDateGen clears the value of the "DateGen" field.
func (m *PointpendingkyctransactionMutation) ClearDateGen() {
	m._DateGen = nil
	m.clearedFields[pointpendingkyctransaction.FieldDateGen] = struct{}{}
}

// DateGenCleared returns if the "DateGen" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) DateGenCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldDateGen]
	return ok
}

// ResetDateGen resets all changes to the "DateGen" field.
func (m *PointpendingkyctransactionMutation) ResetDateGen() {
	m._DateGen = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldDateGen)
}

// SetNote sets the "Note" field.
func (m *PointpendingkyctransactionMutation) SetNote(s string) {
	m._Note = &s
}

// Note returns the value of the "Note" field in the mutation.
func (m *PointpendingkyctransactionMutation) Note() (r string, exists bool) {
	v := m._Note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "Note" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldNote(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "Note" field.
func (m *PointpendingkyctransactionMutation) ClearNote() {
	m._Note = nil
	m.clearedFields[pointpendingkyctransaction.FieldNote] = struct{}{}
}

// NoteCleared returns if the "Note" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) NoteCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldNote]
	return ok
}

// ResetNote resets all changes to the "Note" field.
func (m *PointpendingkyctransactionMutation) ResetNote() {
	m._Note = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldNote)
}

// SetStatusExport sets the "StatusExport" field.
func (m *PointpendingkyctransactionMutation) SetStatusExport(b bool) {
	m._StatusExport = &b
}

// StatusExport returns the value of the "StatusExport" field in the mutation.
func (m *PointpendingkyctransactionMutation) StatusExport() (r bool, exists bool) {
	v := m._StatusExport
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusExport returns the old "StatusExport" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldStatusExport(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusExport is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusExport requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusExport: %w", err)
	}
	return oldValue.StatusExport, nil
}

// ClearStatusExport clears the value of the "StatusExport" field.
func (m *PointpendingkyctransactionMutation) ClearStatusExport() {
	m._StatusExport = nil
	m.clearedFields[pointpendingkyctransaction.FieldStatusExport] = struct{}{}
}

// StatusExportCleared returns if the "StatusExport" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) StatusExportCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldStatusExport]
	return ok
}

// ResetStatusExport resets all changes to the "StatusExport" field.
func (m *PointpendingkyctransactionMutation) ResetStatusExport() {
	m._StatusExport = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldStatusExport)
}

// SetKYCDate sets the "KYCDate" field.
func (m *PointpendingkyctransactionMutation) SetKYCDate(s string) {
	m._KYCDate = &s
}

// KYCDate returns the value of the "KYCDate" field in the mutation.
func (m *PointpendingkyctransactionMutation) KYCDate() (r string, exists bool) {
	v := m._KYCDate
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYCDate" field's value of the Pointpendingkyctransaction entity.
// If the Pointpendingkyctransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendingkyctransactionMutation) OldKYCDate(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYCDate" field.
func (m *PointpendingkyctransactionMutation) ClearKYCDate() {
	m._KYCDate = nil
	m.clearedFields[pointpendingkyctransaction.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYCDate" field was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[pointpendingkyctransaction.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYCDate" field.
func (m *PointpendingkyctransactionMutation) ResetKYCDate() {
	m._KYCDate = nil
	delete(m.clearedFields, pointpendingkyctransaction.FieldKYCDate)
}

// Op returns the operation name.
func (m *PointpendingkyctransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pointpendingkyctransaction).
func (m *PointpendingkyctransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointpendingkyctransactionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._WalletId != nil {
		fields = append(fields, pointpendingkyctransaction.FieldWalletId)
	}
	if m._Point != nil {
		fields = append(fields, pointpendingkyctransaction.FieldPoint)
	}
	if m._DateExport != nil {
		fields = append(fields, pointpendingkyctransaction.FieldDateExport)
	}
	if m._DateGen != nil {
		fields = append(fields, pointpendingkyctransaction.FieldDateGen)
	}
	if m._Note != nil {
		fields = append(fields, pointpendingkyctransaction.FieldNote)
	}
	if m._StatusExport != nil {
		fields = append(fields, pointpendingkyctransaction.FieldStatusExport)
	}
	if m._KYCDate != nil {
		fields = append(fields, pointpendingkyctransaction.FieldKYCDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointpendingkyctransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointpendingkyctransaction.FieldWalletId:
		return m.WalletId()
	case pointpendingkyctransaction.FieldPoint:
		return m.Point()
	case pointpendingkyctransaction.FieldDateExport:
		return m.DateExport()
	case pointpendingkyctransaction.FieldDateGen:
		return m.DateGen()
	case pointpendingkyctransaction.FieldNote:
		return m.Note()
	case pointpendingkyctransaction.FieldStatusExport:
		return m.StatusExport()
	case pointpendingkyctransaction.FieldKYCDate:
		return m.KYCDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointpendingkyctransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointpendingkyctransaction.FieldWalletId:
		return m.OldWalletId(ctx)
	case pointpendingkyctransaction.FieldPoint:
		return m.OldPoint(ctx)
	case pointpendingkyctransaction.FieldDateExport:
		return m.OldDateExport(ctx)
	case pointpendingkyctransaction.FieldDateGen:
		return m.OldDateGen(ctx)
	case pointpendingkyctransaction.FieldNote:
		return m.OldNote(ctx)
	case pointpendingkyctransaction.FieldStatusExport:
		return m.OldStatusExport(ctx)
	case pointpendingkyctransaction.FieldKYCDate:
		return m.OldKYCDate(ctx)
	}
	return nil, fmt.Errorf("unknown Pointpendingkyctransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointpendingkyctransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointpendingkyctransaction.FieldWalletId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletId(v)
		return nil
	case pointpendingkyctransaction.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case pointpendingkyctransaction.FieldDateExport:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateExport(v)
		return nil
	case pointpendingkyctransaction.FieldDateGen:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateGen(v)
		return nil
	case pointpendingkyctransaction.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case pointpendingkyctransaction.FieldStatusExport:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusExport(v)
		return nil
	case pointpendingkyctransaction.FieldKYCDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	}
	return fmt.Errorf("unknown Pointpendingkyctransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointpendingkyctransactionMutation) AddedFields() []string {
	var fields []string
	if m.add_Point != nil {
		fields = append(fields, pointpendingkyctransaction.FieldPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointpendingkyctransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointpendingkyctransaction.FieldPoint:
		return m.AddedPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointpendingkyctransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointpendingkyctransaction.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Pointpendingkyctransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointpendingkyctransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointpendingkyctransaction.FieldWalletId) {
		fields = append(fields, pointpendingkyctransaction.FieldWalletId)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldPoint) {
		fields = append(fields, pointpendingkyctransaction.FieldPoint)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldDateExport) {
		fields = append(fields, pointpendingkyctransaction.FieldDateExport)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldDateGen) {
		fields = append(fields, pointpendingkyctransaction.FieldDateGen)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldNote) {
		fields = append(fields, pointpendingkyctransaction.FieldNote)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldStatusExport) {
		fields = append(fields, pointpendingkyctransaction.FieldStatusExport)
	}
	if m.FieldCleared(pointpendingkyctransaction.FieldKYCDate) {
		fields = append(fields, pointpendingkyctransaction.FieldKYCDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointpendingkyctransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointpendingkyctransactionMutation) ClearField(name string) error {
	switch name {
	case pointpendingkyctransaction.FieldWalletId:
		m.ClearWalletId()
		return nil
	case pointpendingkyctransaction.FieldPoint:
		m.ClearPoint()
		return nil
	case pointpendingkyctransaction.FieldDateExport:
		m.ClearDateExport()
		return nil
	case pointpendingkyctransaction.FieldDateGen:
		m.ClearDateGen()
		return nil
	case pointpendingkyctransaction.FieldNote:
		m.ClearNote()
		return nil
	case pointpendingkyctransaction.FieldStatusExport:
		m.ClearStatusExport()
		return nil
	case pointpendingkyctransaction.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	}
	return fmt.Errorf("unknown Pointpendingkyctransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointpendingkyctransactionMutation) ResetField(name string) error {
	switch name {
	case pointpendingkyctransaction.FieldWalletId:
		m.ResetWalletId()
		return nil
	case pointpendingkyctransaction.FieldPoint:
		m.ResetPoint()
		return nil
	case pointpendingkyctransaction.FieldDateExport:
		m.ResetDateExport()
		return nil
	case pointpendingkyctransaction.FieldDateGen:
		m.ResetDateGen()
		return nil
	case pointpendingkyctransaction.FieldNote:
		m.ResetNote()
		return nil
	case pointpendingkyctransaction.FieldStatusExport:
		m.ResetStatusExport()
		return nil
	case pointpendingkyctransaction.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	}
	return fmt.Errorf("unknown Pointpendingkyctransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointpendingkyctransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointpendingkyctransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointpendingkyctransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointpendingkyctransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointpendingkyctransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointpendingkyctransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointpendingkyctransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pointpendingkyctransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointpendingkyctransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pointpendingkyctransaction edge %s", name)
}

// PointpendinglbtransactionMutation represents an operation that mutates the Pointpendinglbtransaction nodes in the graph.
type PointpendinglbtransactionMutation struct {
	config
	op              Op
	typ             string
	id              *int
	_WalletID       *string
	_PointLB        *int
	add_PointLB     *int
	_DateExportLB   *time.Time
	_DateGenLB      *time.Time
	_NoteLB         *string
	_StatusExportLB *bool
	_LBDate         *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Pointpendinglbtransaction, error)
	predicates      []predicate.Pointpendinglbtransaction
}

var _ ent.Mutation = (*PointpendinglbtransactionMutation)(nil)

// pointpendinglbtransactionOption allows management of the mutation configuration using functional options.
type pointpendinglbtransactionOption func(*PointpendinglbtransactionMutation)

// newPointpendinglbtransactionMutation creates new mutation for the Pointpendinglbtransaction entity.
func newPointpendinglbtransactionMutation(c config, op Op, opts ...pointpendinglbtransactionOption) *PointpendinglbtransactionMutation {
	m := &PointpendinglbtransactionMutation{
		config:        c,
		op:            op,
		typ:           TypePointpendinglbtransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointpendinglbtransactionID sets the ID field of the mutation.
func withPointpendinglbtransactionID(id int) pointpendinglbtransactionOption {
	return func(m *PointpendinglbtransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Pointpendinglbtransaction
		)
		m.oldValue = func(ctx context.Context) (*Pointpendinglbtransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pointpendinglbtransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointpendinglbtransaction sets the old Pointpendinglbtransaction of the mutation.
func withPointpendinglbtransaction(node *Pointpendinglbtransaction) pointpendinglbtransactionOption {
	return func(m *PointpendinglbtransactionMutation) {
		m.oldValue = func(context.Context) (*Pointpendinglbtransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointpendinglbtransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointpendinglbtransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pointpendinglbtransaction entities.
func (m *PointpendinglbtransactionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PointpendinglbtransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *PointpendinglbtransactionMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PointpendinglbtransactionMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PointpendinglbtransactionMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pointpendinglbtransaction.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PointpendinglbtransactionMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldWalletID)
}

// SetPointLB sets the "PointLB" field.
func (m *PointpendinglbtransactionMutation) SetPointLB(i int) {
	m._PointLB = &i
	m.add_PointLB = nil
}

// PointLB returns the value of the "PointLB" field in the mutation.
func (m *PointpendinglbtransactionMutation) PointLB() (r int, exists bool) {
	v := m._PointLB
	if v == nil {
		return
	}
	return *v, true
}

// OldPointLB returns the old "PointLB" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldPointLB(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPointLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPointLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointLB: %w", err)
	}
	return oldValue.PointLB, nil
}

// AddPointLB adds i to the "PointLB" field.
func (m *PointpendinglbtransactionMutation) AddPointLB(i int) {
	if m.add_PointLB != nil {
		*m.add_PointLB += i
	} else {
		m.add_PointLB = &i
	}
}

// AddedPointLB returns the value that was added to the "PointLB" field in this mutation.
func (m *PointpendinglbtransactionMutation) AddedPointLB() (r int, exists bool) {
	v := m.add_PointLB
	if v == nil {
		return
	}
	return *v, true
}

// ClearPointLB clears the value of the "PointLB" field.
func (m *PointpendinglbtransactionMutation) ClearPointLB() {
	m._PointLB = nil
	m.add_PointLB = nil
	m.clearedFields[pointpendinglbtransaction.FieldPointLB] = struct{}{}
}

// PointLBCleared returns if the "PointLB" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) PointLBCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldPointLB]
	return ok
}

// ResetPointLB resets all changes to the "PointLB" field.
func (m *PointpendinglbtransactionMutation) ResetPointLB() {
	m._PointLB = nil
	m.add_PointLB = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldPointLB)
}

// SetDateExportLB sets the "DateExportLB" field.
func (m *PointpendinglbtransactionMutation) SetDateExportLB(t time.Time) {
	m._DateExportLB = &t
}

// DateExportLB returns the value of the "DateExportLB" field in the mutation.
func (m *PointpendinglbtransactionMutation) DateExportLB() (r time.Time, exists bool) {
	v := m._DateExportLB
	if v == nil {
		return
	}
	return *v, true
}

// OldDateExportLB returns the old "DateExportLB" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldDateExportLB(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateExportLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateExportLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateExportLB: %w", err)
	}
	return oldValue.DateExportLB, nil
}

// ClearDateExportLB clears the value of the "DateExportLB" field.
func (m *PointpendinglbtransactionMutation) ClearDateExportLB() {
	m._DateExportLB = nil
	m.clearedFields[pointpendinglbtransaction.FieldDateExportLB] = struct{}{}
}

// DateExportLBCleared returns if the "DateExportLB" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) DateExportLBCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldDateExportLB]
	return ok
}

// ResetDateExportLB resets all changes to the "DateExportLB" field.
func (m *PointpendinglbtransactionMutation) ResetDateExportLB() {
	m._DateExportLB = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldDateExportLB)
}

// SetDateGenLB sets the "DateGenLB" field.
func (m *PointpendinglbtransactionMutation) SetDateGenLB(t time.Time) {
	m._DateGenLB = &t
}

// DateGenLB returns the value of the "DateGenLB" field in the mutation.
func (m *PointpendinglbtransactionMutation) DateGenLB() (r time.Time, exists bool) {
	v := m._DateGenLB
	if v == nil {
		return
	}
	return *v, true
}

// OldDateGenLB returns the old "DateGenLB" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldDateGenLB(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateGenLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateGenLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateGenLB: %w", err)
	}
	return oldValue.DateGenLB, nil
}

// ClearDateGenLB clears the value of the "DateGenLB" field.
func (m *PointpendinglbtransactionMutation) ClearDateGenLB() {
	m._DateGenLB = nil
	m.clearedFields[pointpendinglbtransaction.FieldDateGenLB] = struct{}{}
}

// DateGenLBCleared returns if the "DateGenLB" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) DateGenLBCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldDateGenLB]
	return ok
}

// ResetDateGenLB resets all changes to the "DateGenLB" field.
func (m *PointpendinglbtransactionMutation) ResetDateGenLB() {
	m._DateGenLB = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldDateGenLB)
}

// SetNoteLB sets the "NoteLB" field.
func (m *PointpendinglbtransactionMutation) SetNoteLB(s string) {
	m._NoteLB = &s
}

// NoteLB returns the value of the "NoteLB" field in the mutation.
func (m *PointpendinglbtransactionMutation) NoteLB() (r string, exists bool) {
	v := m._NoteLB
	if v == nil {
		return
	}
	return *v, true
}

// OldNoteLB returns the old "NoteLB" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldNoteLB(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNoteLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNoteLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoteLB: %w", err)
	}
	return oldValue.NoteLB, nil
}

// ClearNoteLB clears the value of the "NoteLB" field.
func (m *PointpendinglbtransactionMutation) ClearNoteLB() {
	m._NoteLB = nil
	m.clearedFields[pointpendinglbtransaction.FieldNoteLB] = struct{}{}
}

// NoteLBCleared returns if the "NoteLB" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) NoteLBCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldNoteLB]
	return ok
}

// ResetNoteLB resets all changes to the "NoteLB" field.
func (m *PointpendinglbtransactionMutation) ResetNoteLB() {
	m._NoteLB = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldNoteLB)
}

// SetStatusExportLB sets the "StatusExportLB" field.
func (m *PointpendinglbtransactionMutation) SetStatusExportLB(b bool) {
	m._StatusExportLB = &b
}

// StatusExportLB returns the value of the "StatusExportLB" field in the mutation.
func (m *PointpendinglbtransactionMutation) StatusExportLB() (r bool, exists bool) {
	v := m._StatusExportLB
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusExportLB returns the old "StatusExportLB" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldStatusExportLB(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusExportLB is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusExportLB requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusExportLB: %w", err)
	}
	return oldValue.StatusExportLB, nil
}

// ClearStatusExportLB clears the value of the "StatusExportLB" field.
func (m *PointpendinglbtransactionMutation) ClearStatusExportLB() {
	m._StatusExportLB = nil
	m.clearedFields[pointpendinglbtransaction.FieldStatusExportLB] = struct{}{}
}

// StatusExportLBCleared returns if the "StatusExportLB" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) StatusExportLBCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldStatusExportLB]
	return ok
}

// ResetStatusExportLB resets all changes to the "StatusExportLB" field.
func (m *PointpendinglbtransactionMutation) ResetStatusExportLB() {
	m._StatusExportLB = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldStatusExportLB)
}

// SetLBDate sets the "LBDate" field.
func (m *PointpendinglbtransactionMutation) SetLBDate(t time.Time) {
	m._LBDate = &t
}

// LBDate returns the value of the "LBDate" field in the mutation.
func (m *PointpendinglbtransactionMutation) LBDate() (r time.Time, exists bool) {
	v := m._LBDate
	if v == nil {
		return
	}
	return *v, true
}

// OldLBDate returns the old "LBDate" field's value of the Pointpendinglbtransaction entity.
// If the Pointpendinglbtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointpendinglbtransactionMutation) OldLBDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLBDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLBDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLBDate: %w", err)
	}
	return oldValue.LBDate, nil
}

// ClearLBDate clears the value of the "LBDate" field.
func (m *PointpendinglbtransactionMutation) ClearLBDate() {
	m._LBDate = nil
	m.clearedFields[pointpendinglbtransaction.FieldLBDate] = struct{}{}
}

// LBDateCleared returns if the "LBDate" field was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) LBDateCleared() bool {
	_, ok := m.clearedFields[pointpendinglbtransaction.FieldLBDate]
	return ok
}

// ResetLBDate resets all changes to the "LBDate" field.
func (m *PointpendinglbtransactionMutation) ResetLBDate() {
	m._LBDate = nil
	delete(m.clearedFields, pointpendinglbtransaction.FieldLBDate)
}

// Op returns the operation name.
func (m *PointpendinglbtransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pointpendinglbtransaction).
func (m *PointpendinglbtransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointpendinglbtransactionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._WalletID != nil {
		fields = append(fields, pointpendinglbtransaction.FieldWalletID)
	}
	if m._PointLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldPointLB)
	}
	if m._DateExportLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldDateExportLB)
	}
	if m._DateGenLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldDateGenLB)
	}
	if m._NoteLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldNoteLB)
	}
	if m._StatusExportLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldStatusExportLB)
	}
	if m._LBDate != nil {
		fields = append(fields, pointpendinglbtransaction.FieldLBDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointpendinglbtransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointpendinglbtransaction.FieldWalletID:
		return m.WalletID()
	case pointpendinglbtransaction.FieldPointLB:
		return m.PointLB()
	case pointpendinglbtransaction.FieldDateExportLB:
		return m.DateExportLB()
	case pointpendinglbtransaction.FieldDateGenLB:
		return m.DateGenLB()
	case pointpendinglbtransaction.FieldNoteLB:
		return m.NoteLB()
	case pointpendinglbtransaction.FieldStatusExportLB:
		return m.StatusExportLB()
	case pointpendinglbtransaction.FieldLBDate:
		return m.LBDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointpendinglbtransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointpendinglbtransaction.FieldWalletID:
		return m.OldWalletID(ctx)
	case pointpendinglbtransaction.FieldPointLB:
		return m.OldPointLB(ctx)
	case pointpendinglbtransaction.FieldDateExportLB:
		return m.OldDateExportLB(ctx)
	case pointpendinglbtransaction.FieldDateGenLB:
		return m.OldDateGenLB(ctx)
	case pointpendinglbtransaction.FieldNoteLB:
		return m.OldNoteLB(ctx)
	case pointpendinglbtransaction.FieldStatusExportLB:
		return m.OldStatusExportLB(ctx)
	case pointpendinglbtransaction.FieldLBDate:
		return m.OldLBDate(ctx)
	}
	return nil, fmt.Errorf("unknown Pointpendinglbtransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointpendinglbtransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointpendinglbtransaction.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pointpendinglbtransaction.FieldPointLB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointLB(v)
		return nil
	case pointpendinglbtransaction.FieldDateExportLB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateExportLB(v)
		return nil
	case pointpendinglbtransaction.FieldDateGenLB:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateGenLB(v)
		return nil
	case pointpendinglbtransaction.FieldNoteLB:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoteLB(v)
		return nil
	case pointpendinglbtransaction.FieldStatusExportLB:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusExportLB(v)
		return nil
	case pointpendinglbtransaction.FieldLBDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLBDate(v)
		return nil
	}
	return fmt.Errorf("unknown Pointpendinglbtransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointpendinglbtransactionMutation) AddedFields() []string {
	var fields []string
	if m.add_PointLB != nil {
		fields = append(fields, pointpendinglbtransaction.FieldPointLB)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointpendinglbtransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointpendinglbtransaction.FieldPointLB:
		return m.AddedPointLB()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointpendinglbtransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointpendinglbtransaction.FieldPointLB:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPointLB(v)
		return nil
	}
	return fmt.Errorf("unknown Pointpendinglbtransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointpendinglbtransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointpendinglbtransaction.FieldWalletID) {
		fields = append(fields, pointpendinglbtransaction.FieldWalletID)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldPointLB) {
		fields = append(fields, pointpendinglbtransaction.FieldPointLB)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldDateExportLB) {
		fields = append(fields, pointpendinglbtransaction.FieldDateExportLB)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldDateGenLB) {
		fields = append(fields, pointpendinglbtransaction.FieldDateGenLB)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldNoteLB) {
		fields = append(fields, pointpendinglbtransaction.FieldNoteLB)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldStatusExportLB) {
		fields = append(fields, pointpendinglbtransaction.FieldStatusExportLB)
	}
	if m.FieldCleared(pointpendinglbtransaction.FieldLBDate) {
		fields = append(fields, pointpendinglbtransaction.FieldLBDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointpendinglbtransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointpendinglbtransactionMutation) ClearField(name string) error {
	switch name {
	case pointpendinglbtransaction.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pointpendinglbtransaction.FieldPointLB:
		m.ClearPointLB()
		return nil
	case pointpendinglbtransaction.FieldDateExportLB:
		m.ClearDateExportLB()
		return nil
	case pointpendinglbtransaction.FieldDateGenLB:
		m.ClearDateGenLB()
		return nil
	case pointpendinglbtransaction.FieldNoteLB:
		m.ClearNoteLB()
		return nil
	case pointpendinglbtransaction.FieldStatusExportLB:
		m.ClearStatusExportLB()
		return nil
	case pointpendinglbtransaction.FieldLBDate:
		m.ClearLBDate()
		return nil
	}
	return fmt.Errorf("unknown Pointpendinglbtransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointpendinglbtransactionMutation) ResetField(name string) error {
	switch name {
	case pointpendinglbtransaction.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pointpendinglbtransaction.FieldPointLB:
		m.ResetPointLB()
		return nil
	case pointpendinglbtransaction.FieldDateExportLB:
		m.ResetDateExportLB()
		return nil
	case pointpendinglbtransaction.FieldDateGenLB:
		m.ResetDateGenLB()
		return nil
	case pointpendinglbtransaction.FieldNoteLB:
		m.ResetNoteLB()
		return nil
	case pointpendinglbtransaction.FieldStatusExportLB:
		m.ResetStatusExportLB()
		return nil
	case pointpendinglbtransaction.FieldLBDate:
		m.ResetLBDate()
		return nil
	}
	return fmt.Errorf("unknown Pointpendinglbtransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointpendinglbtransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointpendinglbtransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointpendinglbtransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointpendinglbtransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointpendinglbtransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointpendinglbtransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointpendinglbtransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pointpendinglbtransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointpendinglbtransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pointpendinglbtransaction edge %s", name)
}

// PointtransactionMutation represents an operation that mutates the Pointtransaction nodes in the graph.
type PointtransactionMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_Date            *time.Time
	_WalletID        *string
	_TransactionName *string
	_Point           *int
	add_Point        *int
	_Reference       *string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Pointtransaction, error)
	predicates       []predicate.Pointtransaction
}

var _ ent.Mutation = (*PointtransactionMutation)(nil)

// pointtransactionOption allows management of the mutation configuration using functional options.
type pointtransactionOption func(*PointtransactionMutation)

// newPointtransactionMutation creates new mutation for the Pointtransaction entity.
func newPointtransactionMutation(c config, op Op, opts ...pointtransactionOption) *PointtransactionMutation {
	m := &PointtransactionMutation{
		config:        c,
		op:            op,
		typ:           TypePointtransaction,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointtransactionID sets the ID field of the mutation.
func withPointtransactionID(id int) pointtransactionOption {
	return func(m *PointtransactionMutation) {
		var (
			err   error
			once  sync.Once
			value *Pointtransaction
		)
		m.oldValue = func(ctx context.Context) (*Pointtransaction, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pointtransaction.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointtransaction sets the old Pointtransaction of the mutation.
func withPointtransaction(node *Pointtransaction) pointtransactionOption {
	return func(m *PointtransactionMutation) {
		m.oldValue = func(context.Context) (*Pointtransaction, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointtransactionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointtransactionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pointtransaction entities.
func (m *PointtransactionMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *PointtransactionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDate sets the "Date" field.
func (m *PointtransactionMutation) SetDate(t time.Time) {
	m._Date = &t
}

// Date returns the value of the "Date" field in the mutation.
func (m *PointtransactionMutation) Date() (r time.Time, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "Date" field's value of the Pointtransaction entity.
// If the Pointtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointtransactionMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "Date" field.
func (m *PointtransactionMutation) ClearDate() {
	m._Date = nil
	m.clearedFields[pointtransaction.FieldDate] = struct{}{}
}

// DateCleared returns if the "Date" field was cleared in this mutation.
func (m *PointtransactionMutation) DateCleared() bool {
	_, ok := m.clearedFields[pointtransaction.FieldDate]
	return ok
}

// ResetDate resets all changes to the "Date" field.
func (m *PointtransactionMutation) ResetDate() {
	m._Date = nil
	delete(m.clearedFields, pointtransaction.FieldDate)
}

// SetWalletID sets the "WalletID" field.
func (m *PointtransactionMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *PointtransactionMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Pointtransaction entity.
// If the Pointtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointtransactionMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ClearWalletID clears the value of the "WalletID" field.
func (m *PointtransactionMutation) ClearWalletID() {
	m._WalletID = nil
	m.clearedFields[pointtransaction.FieldWalletID] = struct{}{}
}

// WalletIDCleared returns if the "WalletID" field was cleared in this mutation.
func (m *PointtransactionMutation) WalletIDCleared() bool {
	_, ok := m.clearedFields[pointtransaction.FieldWalletID]
	return ok
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *PointtransactionMutation) ResetWalletID() {
	m._WalletID = nil
	delete(m.clearedFields, pointtransaction.FieldWalletID)
}

// SetTransactionName sets the "TransactionName" field.
func (m *PointtransactionMutation) SetTransactionName(s string) {
	m._TransactionName = &s
}

// TransactionName returns the value of the "TransactionName" field in the mutation.
func (m *PointtransactionMutation) TransactionName() (r string, exists bool) {
	v := m._TransactionName
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionName returns the old "TransactionName" field's value of the Pointtransaction entity.
// If the Pointtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointtransactionMutation) OldTransactionName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionName: %w", err)
	}
	return oldValue.TransactionName, nil
}

// ClearTransactionName clears the value of the "TransactionName" field.
func (m *PointtransactionMutation) ClearTransactionName() {
	m._TransactionName = nil
	m.clearedFields[pointtransaction.FieldTransactionName] = struct{}{}
}

// TransactionNameCleared returns if the "TransactionName" field was cleared in this mutation.
func (m *PointtransactionMutation) TransactionNameCleared() bool {
	_, ok := m.clearedFields[pointtransaction.FieldTransactionName]
	return ok
}

// ResetTransactionName resets all changes to the "TransactionName" field.
func (m *PointtransactionMutation) ResetTransactionName() {
	m._TransactionName = nil
	delete(m.clearedFields, pointtransaction.FieldTransactionName)
}

// SetPoint sets the "Point" field.
func (m *PointtransactionMutation) SetPoint(i int) {
	m._Point = &i
	m.add_Point = nil
}

// Point returns the value of the "Point" field in the mutation.
func (m *PointtransactionMutation) Point() (r int, exists bool) {
	v := m._Point
	if v == nil {
		return
	}
	return *v, true
}

// OldPoint returns the old "Point" field's value of the Pointtransaction entity.
// If the Pointtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointtransactionMutation) OldPoint(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPoint: %w", err)
	}
	return oldValue.Point, nil
}

// AddPoint adds i to the "Point" field.
func (m *PointtransactionMutation) AddPoint(i int) {
	if m.add_Point != nil {
		*m.add_Point += i
	} else {
		m.add_Point = &i
	}
}

// AddedPoint returns the value that was added to the "Point" field in this mutation.
func (m *PointtransactionMutation) AddedPoint() (r int, exists bool) {
	v := m.add_Point
	if v == nil {
		return
	}
	return *v, true
}

// ClearPoint clears the value of the "Point" field.
func (m *PointtransactionMutation) ClearPoint() {
	m._Point = nil
	m.add_Point = nil
	m.clearedFields[pointtransaction.FieldPoint] = struct{}{}
}

// PointCleared returns if the "Point" field was cleared in this mutation.
func (m *PointtransactionMutation) PointCleared() bool {
	_, ok := m.clearedFields[pointtransaction.FieldPoint]
	return ok
}

// ResetPoint resets all changes to the "Point" field.
func (m *PointtransactionMutation) ResetPoint() {
	m._Point = nil
	m.add_Point = nil
	delete(m.clearedFields, pointtransaction.FieldPoint)
}

// SetReference sets the "Reference" field.
func (m *PointtransactionMutation) SetReference(s string) {
	m._Reference = &s
}

// Reference returns the value of the "Reference" field in the mutation.
func (m *PointtransactionMutation) Reference() (r string, exists bool) {
	v := m._Reference
	if v == nil {
		return
	}
	return *v, true
}

// OldReference returns the old "Reference" field's value of the Pointtransaction entity.
// If the Pointtransaction object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointtransactionMutation) OldReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReference: %w", err)
	}
	return oldValue.Reference, nil
}

// ClearReference clears the value of the "Reference" field.
func (m *PointtransactionMutation) ClearReference() {
	m._Reference = nil
	m.clearedFields[pointtransaction.FieldReference] = struct{}{}
}

// ReferenceCleared returns if the "Reference" field was cleared in this mutation.
func (m *PointtransactionMutation) ReferenceCleared() bool {
	_, ok := m.clearedFields[pointtransaction.FieldReference]
	return ok
}

// ResetReference resets all changes to the "Reference" field.
func (m *PointtransactionMutation) ResetReference() {
	m._Reference = nil
	delete(m.clearedFields, pointtransaction.FieldReference)
}

// Op returns the operation name.
func (m *PointtransactionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Pointtransaction).
func (m *PointtransactionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointtransactionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m._Date != nil {
		fields = append(fields, pointtransaction.FieldDate)
	}
	if m._WalletID != nil {
		fields = append(fields, pointtransaction.FieldWalletID)
	}
	if m._TransactionName != nil {
		fields = append(fields, pointtransaction.FieldTransactionName)
	}
	if m._Point != nil {
		fields = append(fields, pointtransaction.FieldPoint)
	}
	if m._Reference != nil {
		fields = append(fields, pointtransaction.FieldReference)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointtransactionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointtransaction.FieldDate:
		return m.Date()
	case pointtransaction.FieldWalletID:
		return m.WalletID()
	case pointtransaction.FieldTransactionName:
		return m.TransactionName()
	case pointtransaction.FieldPoint:
		return m.Point()
	case pointtransaction.FieldReference:
		return m.Reference()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointtransactionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointtransaction.FieldDate:
		return m.OldDate(ctx)
	case pointtransaction.FieldWalletID:
		return m.OldWalletID(ctx)
	case pointtransaction.FieldTransactionName:
		return m.OldTransactionName(ctx)
	case pointtransaction.FieldPoint:
		return m.OldPoint(ctx)
	case pointtransaction.FieldReference:
		return m.OldReference(ctx)
	}
	return nil, fmt.Errorf("unknown Pointtransaction field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointtransactionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointtransaction.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case pointtransaction.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case pointtransaction.FieldTransactionName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionName(v)
		return nil
	case pointtransaction.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPoint(v)
		return nil
	case pointtransaction.FieldReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReference(v)
		return nil
	}
	return fmt.Errorf("unknown Pointtransaction field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointtransactionMutation) AddedFields() []string {
	var fields []string
	if m.add_Point != nil {
		fields = append(fields, pointtransaction.FieldPoint)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointtransactionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case pointtransaction.FieldPoint:
		return m.AddedPoint()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointtransactionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case pointtransaction.FieldPoint:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPoint(v)
		return nil
	}
	return fmt.Errorf("unknown Pointtransaction numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointtransactionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(pointtransaction.FieldDate) {
		fields = append(fields, pointtransaction.FieldDate)
	}
	if m.FieldCleared(pointtransaction.FieldWalletID) {
		fields = append(fields, pointtransaction.FieldWalletID)
	}
	if m.FieldCleared(pointtransaction.FieldTransactionName) {
		fields = append(fields, pointtransaction.FieldTransactionName)
	}
	if m.FieldCleared(pointtransaction.FieldPoint) {
		fields = append(fields, pointtransaction.FieldPoint)
	}
	if m.FieldCleared(pointtransaction.FieldReference) {
		fields = append(fields, pointtransaction.FieldReference)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointtransactionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointtransactionMutation) ClearField(name string) error {
	switch name {
	case pointtransaction.FieldDate:
		m.ClearDate()
		return nil
	case pointtransaction.FieldWalletID:
		m.ClearWalletID()
		return nil
	case pointtransaction.FieldTransactionName:
		m.ClearTransactionName()
		return nil
	case pointtransaction.FieldPoint:
		m.ClearPoint()
		return nil
	case pointtransaction.FieldReference:
		m.ClearReference()
		return nil
	}
	return fmt.Errorf("unknown Pointtransaction nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointtransactionMutation) ResetField(name string) error {
	switch name {
	case pointtransaction.FieldDate:
		m.ResetDate()
		return nil
	case pointtransaction.FieldWalletID:
		m.ResetWalletID()
		return nil
	case pointtransaction.FieldTransactionName:
		m.ResetTransactionName()
		return nil
	case pointtransaction.FieldPoint:
		m.ResetPoint()
		return nil
	case pointtransaction.FieldReference:
		m.ResetReference()
		return nil
	}
	return fmt.Errorf("unknown Pointtransaction field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointtransactionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointtransactionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointtransactionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointtransactionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointtransactionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointtransactionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointtransactionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Pointtransaction unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointtransactionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Pointtransaction edge %s", name)
}

// RankingMutation represents an operation that mutates the Ranking nodes in the graph.
type RankingMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_WalletID                 *string
	_Name                     *string
	_TaxID                    *string
	_ProvinceNameTH           *string
	_DistrictNameTH           *string
	_DistrictNameEN           *string
	_OccupationName           *string
	_LastRank                 *int
	add_LastRank              *int
	_CurrentRank              *int
	add_CurrentRank           *int
	_StatusRanking            *string
	_LastDateCalRank          *string
	_NextDateCalRank          *string
	_StateCal                 *int
	add_StateCal              *int
	_ZipCode                  *string
	_TransactionFactorRank    *int
	add_TransactionFactorRank *int
	_RegisDate                *time.Time
	_SubDistrict              *string
	_Phoneno                  *string
	_AddressDetail            *string
	_Street                   *string
	clearedFields             map[string]struct{}
	done                      bool
	oldValue                  func(context.Context) (*Ranking, error)
	predicates                []predicate.Ranking
}

var _ ent.Mutation = (*RankingMutation)(nil)

// rankingOption allows management of the mutation configuration using functional options.
type rankingOption func(*RankingMutation)

// newRankingMutation creates new mutation for the Ranking entity.
func newRankingMutation(c config, op Op, opts ...rankingOption) *RankingMutation {
	m := &RankingMutation{
		config:        c,
		op:            op,
		typ:           TypeRanking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRankingID sets the ID field of the mutation.
func withRankingID(id int) rankingOption {
	return func(m *RankingMutation) {
		var (
			err   error
			once  sync.Once
			value *Ranking
		)
		m.oldValue = func(ctx context.Context) (*Ranking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ranking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRanking sets the old Ranking of the mutation.
func withRanking(node *Ranking) rankingOption {
	return func(m *RankingMutation) {
		m.oldValue = func(context.Context) (*Ranking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RankingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RankingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ranking entities.
func (m *RankingMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *RankingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *RankingMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *RankingMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *RankingMutation) ResetWalletID() {
	m._WalletID = nil
}

// SetName sets the "Name" field.
func (m *RankingMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *RankingMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "Name" field.
func (m *RankingMutation) ClearName() {
	m._Name = nil
	m.clearedFields[ranking.FieldName] = struct{}{}
}

// NameCleared returns if the "Name" field was cleared in this mutation.
func (m *RankingMutation) NameCleared() bool {
	_, ok := m.clearedFields[ranking.FieldName]
	return ok
}

// ResetName resets all changes to the "Name" field.
func (m *RankingMutation) ResetName() {
	m._Name = nil
	delete(m.clearedFields, ranking.FieldName)
}

// SetTaxID sets the "TaxID" field.
func (m *RankingMutation) SetTaxID(s string) {
	m._TaxID = &s
}

// TaxID returns the value of the "TaxID" field in the mutation.
func (m *RankingMutation) TaxID() (r string, exists bool) {
	v := m._TaxID
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "TaxID" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ClearTaxID clears the value of the "TaxID" field.
func (m *RankingMutation) ClearTaxID() {
	m._TaxID = nil
	m.clearedFields[ranking.FieldTaxID] = struct{}{}
}

// TaxIDCleared returns if the "TaxID" field was cleared in this mutation.
func (m *RankingMutation) TaxIDCleared() bool {
	_, ok := m.clearedFields[ranking.FieldTaxID]
	return ok
}

// ResetTaxID resets all changes to the "TaxID" field.
func (m *RankingMutation) ResetTaxID() {
	m._TaxID = nil
	delete(m.clearedFields, ranking.FieldTaxID)
}

// SetProvinceNameTH sets the "ProvinceNameTH" field.
func (m *RankingMutation) SetProvinceNameTH(s string) {
	m._ProvinceNameTH = &s
}

// ProvinceNameTH returns the value of the "ProvinceNameTH" field in the mutation.
func (m *RankingMutation) ProvinceNameTH() (r string, exists bool) {
	v := m._ProvinceNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldProvinceNameTH returns the old "ProvinceNameTH" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldProvinceNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvinceNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvinceNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvinceNameTH: %w", err)
	}
	return oldValue.ProvinceNameTH, nil
}

// ClearProvinceNameTH clears the value of the "ProvinceNameTH" field.
func (m *RankingMutation) ClearProvinceNameTH() {
	m._ProvinceNameTH = nil
	m.clearedFields[ranking.FieldProvinceNameTH] = struct{}{}
}

// ProvinceNameTHCleared returns if the "ProvinceNameTH" field was cleared in this mutation.
func (m *RankingMutation) ProvinceNameTHCleared() bool {
	_, ok := m.clearedFields[ranking.FieldProvinceNameTH]
	return ok
}

// ResetProvinceNameTH resets all changes to the "ProvinceNameTH" field.
func (m *RankingMutation) ResetProvinceNameTH() {
	m._ProvinceNameTH = nil
	delete(m.clearedFields, ranking.FieldProvinceNameTH)
}

// SetDistrictNameTH sets the "DistrictNameTH" field.
func (m *RankingMutation) SetDistrictNameTH(s string) {
	m._DistrictNameTH = &s
}

// DistrictNameTH returns the value of the "DistrictNameTH" field in the mutation.
func (m *RankingMutation) DistrictNameTH() (r string, exists bool) {
	v := m._DistrictNameTH
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictNameTH returns the old "DistrictNameTH" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldDistrictNameTH(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictNameTH is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictNameTH requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictNameTH: %w", err)
	}
	return oldValue.DistrictNameTH, nil
}

// ClearDistrictNameTH clears the value of the "DistrictNameTH" field.
func (m *RankingMutation) ClearDistrictNameTH() {
	m._DistrictNameTH = nil
	m.clearedFields[ranking.FieldDistrictNameTH] = struct{}{}
}

// DistrictNameTHCleared returns if the "DistrictNameTH" field was cleared in this mutation.
func (m *RankingMutation) DistrictNameTHCleared() bool {
	_, ok := m.clearedFields[ranking.FieldDistrictNameTH]
	return ok
}

// ResetDistrictNameTH resets all changes to the "DistrictNameTH" field.
func (m *RankingMutation) ResetDistrictNameTH() {
	m._DistrictNameTH = nil
	delete(m.clearedFields, ranking.FieldDistrictNameTH)
}

// SetDistrictNameEN sets the "DistrictNameEN" field.
func (m *RankingMutation) SetDistrictNameEN(s string) {
	m._DistrictNameEN = &s
}

// DistrictNameEN returns the value of the "DistrictNameEN" field in the mutation.
func (m *RankingMutation) DistrictNameEN() (r string, exists bool) {
	v := m._DistrictNameEN
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrictNameEN returns the old "DistrictNameEN" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldDistrictNameEN(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrictNameEN is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrictNameEN requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrictNameEN: %w", err)
	}
	return oldValue.DistrictNameEN, nil
}

// ClearDistrictNameEN clears the value of the "DistrictNameEN" field.
func (m *RankingMutation) ClearDistrictNameEN() {
	m._DistrictNameEN = nil
	m.clearedFields[ranking.FieldDistrictNameEN] = struct{}{}
}

// DistrictNameENCleared returns if the "DistrictNameEN" field was cleared in this mutation.
func (m *RankingMutation) DistrictNameENCleared() bool {
	_, ok := m.clearedFields[ranking.FieldDistrictNameEN]
	return ok
}

// ResetDistrictNameEN resets all changes to the "DistrictNameEN" field.
func (m *RankingMutation) ResetDistrictNameEN() {
	m._DistrictNameEN = nil
	delete(m.clearedFields, ranking.FieldDistrictNameEN)
}

// SetOccupationName sets the "OccupationName" field.
func (m *RankingMutation) SetOccupationName(s string) {
	m._OccupationName = &s
}

// OccupationName returns the value of the "OccupationName" field in the mutation.
func (m *RankingMutation) OccupationName() (r string, exists bool) {
	v := m._OccupationName
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationName returns the old "OccupationName" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldOccupationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationName: %w", err)
	}
	return oldValue.OccupationName, nil
}

// ClearOccupationName clears the value of the "OccupationName" field.
func (m *RankingMutation) ClearOccupationName() {
	m._OccupationName = nil
	m.clearedFields[ranking.FieldOccupationName] = struct{}{}
}

// OccupationNameCleared returns if the "OccupationName" field was cleared in this mutation.
func (m *RankingMutation) OccupationNameCleared() bool {
	_, ok := m.clearedFields[ranking.FieldOccupationName]
	return ok
}

// ResetOccupationName resets all changes to the "OccupationName" field.
func (m *RankingMutation) ResetOccupationName() {
	m._OccupationName = nil
	delete(m.clearedFields, ranking.FieldOccupationName)
}

// SetLastRank sets the "LastRank" field.
func (m *RankingMutation) SetLastRank(i int) {
	m._LastRank = &i
	m.add_LastRank = nil
}

// LastRank returns the value of the "LastRank" field in the mutation.
func (m *RankingMutation) LastRank() (r int, exists bool) {
	v := m._LastRank
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRank returns the old "LastRank" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldLastRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRank: %w", err)
	}
	return oldValue.LastRank, nil
}

// AddLastRank adds i to the "LastRank" field.
func (m *RankingMutation) AddLastRank(i int) {
	if m.add_LastRank != nil {
		*m.add_LastRank += i
	} else {
		m.add_LastRank = &i
	}
}

// AddedLastRank returns the value that was added to the "LastRank" field in this mutation.
func (m *RankingMutation) AddedLastRank() (r int, exists bool) {
	v := m.add_LastRank
	if v == nil {
		return
	}
	return *v, true
}

// ClearLastRank clears the value of the "LastRank" field.
func (m *RankingMutation) ClearLastRank() {
	m._LastRank = nil
	m.add_LastRank = nil
	m.clearedFields[ranking.FieldLastRank] = struct{}{}
}

// LastRankCleared returns if the "LastRank" field was cleared in this mutation.
func (m *RankingMutation) LastRankCleared() bool {
	_, ok := m.clearedFields[ranking.FieldLastRank]
	return ok
}

// ResetLastRank resets all changes to the "LastRank" field.
func (m *RankingMutation) ResetLastRank() {
	m._LastRank = nil
	m.add_LastRank = nil
	delete(m.clearedFields, ranking.FieldLastRank)
}

// SetCurrentRank sets the "CurrentRank" field.
func (m *RankingMutation) SetCurrentRank(i int) {
	m._CurrentRank = &i
	m.add_CurrentRank = nil
}

// CurrentRank returns the value of the "CurrentRank" field in the mutation.
func (m *RankingMutation) CurrentRank() (r int, exists bool) {
	v := m._CurrentRank
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrentRank returns the old "CurrentRank" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldCurrentRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCurrentRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCurrentRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrentRank: %w", err)
	}
	return oldValue.CurrentRank, nil
}

// AddCurrentRank adds i to the "CurrentRank" field.
func (m *RankingMutation) AddCurrentRank(i int) {
	if m.add_CurrentRank != nil {
		*m.add_CurrentRank += i
	} else {
		m.add_CurrentRank = &i
	}
}

// AddedCurrentRank returns the value that was added to the "CurrentRank" field in this mutation.
func (m *RankingMutation) AddedCurrentRank() (r int, exists bool) {
	v := m.add_CurrentRank
	if v == nil {
		return
	}
	return *v, true
}

// ClearCurrentRank clears the value of the "CurrentRank" field.
func (m *RankingMutation) ClearCurrentRank() {
	m._CurrentRank = nil
	m.add_CurrentRank = nil
	m.clearedFields[ranking.FieldCurrentRank] = struct{}{}
}

// CurrentRankCleared returns if the "CurrentRank" field was cleared in this mutation.
func (m *RankingMutation) CurrentRankCleared() bool {
	_, ok := m.clearedFields[ranking.FieldCurrentRank]
	return ok
}

// ResetCurrentRank resets all changes to the "CurrentRank" field.
func (m *RankingMutation) ResetCurrentRank() {
	m._CurrentRank = nil
	m.add_CurrentRank = nil
	delete(m.clearedFields, ranking.FieldCurrentRank)
}

// SetStatusRanking sets the "StatusRanking" field.
func (m *RankingMutation) SetStatusRanking(s string) {
	m._StatusRanking = &s
}

// StatusRanking returns the value of the "StatusRanking" field in the mutation.
func (m *RankingMutation) StatusRanking() (r string, exists bool) {
	v := m._StatusRanking
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusRanking returns the old "StatusRanking" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldStatusRanking(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusRanking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusRanking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusRanking: %w", err)
	}
	return oldValue.StatusRanking, nil
}

// ClearStatusRanking clears the value of the "StatusRanking" field.
func (m *RankingMutation) ClearStatusRanking() {
	m._StatusRanking = nil
	m.clearedFields[ranking.FieldStatusRanking] = struct{}{}
}

// StatusRankingCleared returns if the "StatusRanking" field was cleared in this mutation.
func (m *RankingMutation) StatusRankingCleared() bool {
	_, ok := m.clearedFields[ranking.FieldStatusRanking]
	return ok
}

// ResetStatusRanking resets all changes to the "StatusRanking" field.
func (m *RankingMutation) ResetStatusRanking() {
	m._StatusRanking = nil
	delete(m.clearedFields, ranking.FieldStatusRanking)
}

// SetLastDateCalRank sets the "LastDateCalRank" field.
func (m *RankingMutation) SetLastDateCalRank(s string) {
	m._LastDateCalRank = &s
}

// LastDateCalRank returns the value of the "LastDateCalRank" field in the mutation.
func (m *RankingMutation) LastDateCalRank() (r string, exists bool) {
	v := m._LastDateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldLastDateCalRank returns the old "LastDateCalRank" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldLastDateCalRank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastDateCalRank: %w", err)
	}
	return oldValue.LastDateCalRank, nil
}

// ClearLastDateCalRank clears the value of the "LastDateCalRank" field.
func (m *RankingMutation) ClearLastDateCalRank() {
	m._LastDateCalRank = nil
	m.clearedFields[ranking.FieldLastDateCalRank] = struct{}{}
}

// LastDateCalRankCleared returns if the "LastDateCalRank" field was cleared in this mutation.
func (m *RankingMutation) LastDateCalRankCleared() bool {
	_, ok := m.clearedFields[ranking.FieldLastDateCalRank]
	return ok
}

// ResetLastDateCalRank resets all changes to the "LastDateCalRank" field.
func (m *RankingMutation) ResetLastDateCalRank() {
	m._LastDateCalRank = nil
	delete(m.clearedFields, ranking.FieldLastDateCalRank)
}

// SetNextDateCalRank sets the "NextDateCalRank" field.
func (m *RankingMutation) SetNextDateCalRank(s string) {
	m._NextDateCalRank = &s
}

// NextDateCalRank returns the value of the "NextDateCalRank" field in the mutation.
func (m *RankingMutation) NextDateCalRank() (r string, exists bool) {
	v := m._NextDateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldNextDateCalRank returns the old "NextDateCalRank" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldNextDateCalRank(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNextDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNextDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNextDateCalRank: %w", err)
	}
	return oldValue.NextDateCalRank, nil
}

// ClearNextDateCalRank clears the value of the "NextDateCalRank" field.
func (m *RankingMutation) ClearNextDateCalRank() {
	m._NextDateCalRank = nil
	m.clearedFields[ranking.FieldNextDateCalRank] = struct{}{}
}

// NextDateCalRankCleared returns if the "NextDateCalRank" field was cleared in this mutation.
func (m *RankingMutation) NextDateCalRankCleared() bool {
	_, ok := m.clearedFields[ranking.FieldNextDateCalRank]
	return ok
}

// ResetNextDateCalRank resets all changes to the "NextDateCalRank" field.
func (m *RankingMutation) ResetNextDateCalRank() {
	m._NextDateCalRank = nil
	delete(m.clearedFields, ranking.FieldNextDateCalRank)
}

// SetStateCal sets the "StateCal" field.
func (m *RankingMutation) SetStateCal(i int) {
	m._StateCal = &i
	m.add_StateCal = nil
}

// StateCal returns the value of the "StateCal" field in the mutation.
func (m *RankingMutation) StateCal() (r int, exists bool) {
	v := m._StateCal
	if v == nil {
		return
	}
	return *v, true
}

// OldStateCal returns the old "StateCal" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldStateCal(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStateCal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStateCal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateCal: %w", err)
	}
	return oldValue.StateCal, nil
}

// AddStateCal adds i to the "StateCal" field.
func (m *RankingMutation) AddStateCal(i int) {
	if m.add_StateCal != nil {
		*m.add_StateCal += i
	} else {
		m.add_StateCal = &i
	}
}

// AddedStateCal returns the value that was added to the "StateCal" field in this mutation.
func (m *RankingMutation) AddedStateCal() (r int, exists bool) {
	v := m.add_StateCal
	if v == nil {
		return
	}
	return *v, true
}

// ClearStateCal clears the value of the "StateCal" field.
func (m *RankingMutation) ClearStateCal() {
	m._StateCal = nil
	m.add_StateCal = nil
	m.clearedFields[ranking.FieldStateCal] = struct{}{}
}

// StateCalCleared returns if the "StateCal" field was cleared in this mutation.
func (m *RankingMutation) StateCalCleared() bool {
	_, ok := m.clearedFields[ranking.FieldStateCal]
	return ok
}

// ResetStateCal resets all changes to the "StateCal" field.
func (m *RankingMutation) ResetStateCal() {
	m._StateCal = nil
	m.add_StateCal = nil
	delete(m.clearedFields, ranking.FieldStateCal)
}

// SetZipCode sets the "ZipCode" field.
func (m *RankingMutation) SetZipCode(s string) {
	m._ZipCode = &s
}

// ZipCode returns the value of the "ZipCode" field in the mutation.
func (m *RankingMutation) ZipCode() (r string, exists bool) {
	v := m._ZipCode
	if v == nil {
		return
	}
	return *v, true
}

// OldZipCode returns the old "ZipCode" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldZipCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldZipCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldZipCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZipCode: %w", err)
	}
	return oldValue.ZipCode, nil
}

// ClearZipCode clears the value of the "ZipCode" field.
func (m *RankingMutation) ClearZipCode() {
	m._ZipCode = nil
	m.clearedFields[ranking.FieldZipCode] = struct{}{}
}

// ZipCodeCleared returns if the "ZipCode" field was cleared in this mutation.
func (m *RankingMutation) ZipCodeCleared() bool {
	_, ok := m.clearedFields[ranking.FieldZipCode]
	return ok
}

// ResetZipCode resets all changes to the "ZipCode" field.
func (m *RankingMutation) ResetZipCode() {
	m._ZipCode = nil
	delete(m.clearedFields, ranking.FieldZipCode)
}

// SetTransactionFactorRank sets the "TransactionFactorRank" field.
func (m *RankingMutation) SetTransactionFactorRank(i int) {
	m._TransactionFactorRank = &i
	m.add_TransactionFactorRank = nil
}

// TransactionFactorRank returns the value of the "TransactionFactorRank" field in the mutation.
func (m *RankingMutation) TransactionFactorRank() (r int, exists bool) {
	v := m._TransactionFactorRank
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionFactorRank returns the old "TransactionFactorRank" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldTransactionFactorRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionFactorRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionFactorRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionFactorRank: %w", err)
	}
	return oldValue.TransactionFactorRank, nil
}

// AddTransactionFactorRank adds i to the "TransactionFactorRank" field.
func (m *RankingMutation) AddTransactionFactorRank(i int) {
	if m.add_TransactionFactorRank != nil {
		*m.add_TransactionFactorRank += i
	} else {
		m.add_TransactionFactorRank = &i
	}
}

// AddedTransactionFactorRank returns the value that was added to the "TransactionFactorRank" field in this mutation.
func (m *RankingMutation) AddedTransactionFactorRank() (r int, exists bool) {
	v := m.add_TransactionFactorRank
	if v == nil {
		return
	}
	return *v, true
}

// ClearTransactionFactorRank clears the value of the "TransactionFactorRank" field.
func (m *RankingMutation) ClearTransactionFactorRank() {
	m._TransactionFactorRank = nil
	m.add_TransactionFactorRank = nil
	m.clearedFields[ranking.FieldTransactionFactorRank] = struct{}{}
}

// TransactionFactorRankCleared returns if the "TransactionFactorRank" field was cleared in this mutation.
func (m *RankingMutation) TransactionFactorRankCleared() bool {
	_, ok := m.clearedFields[ranking.FieldTransactionFactorRank]
	return ok
}

// ResetTransactionFactorRank resets all changes to the "TransactionFactorRank" field.
func (m *RankingMutation) ResetTransactionFactorRank() {
	m._TransactionFactorRank = nil
	m.add_TransactionFactorRank = nil
	delete(m.clearedFields, ranking.FieldTransactionFactorRank)
}

// SetRegisDate sets the "RegisDate" field.
func (m *RankingMutation) SetRegisDate(t time.Time) {
	m._RegisDate = &t
}

// RegisDate returns the value of the "RegisDate" field in the mutation.
func (m *RankingMutation) RegisDate() (r time.Time, exists bool) {
	v := m._RegisDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisDate returns the old "RegisDate" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldRegisDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisDate: %w", err)
	}
	return oldValue.RegisDate, nil
}

// ClearRegisDate clears the value of the "RegisDate" field.
func (m *RankingMutation) ClearRegisDate() {
	m._RegisDate = nil
	m.clearedFields[ranking.FieldRegisDate] = struct{}{}
}

// RegisDateCleared returns if the "RegisDate" field was cleared in this mutation.
func (m *RankingMutation) RegisDateCleared() bool {
	_, ok := m.clearedFields[ranking.FieldRegisDate]
	return ok
}

// ResetRegisDate resets all changes to the "RegisDate" field.
func (m *RankingMutation) ResetRegisDate() {
	m._RegisDate = nil
	delete(m.clearedFields, ranking.FieldRegisDate)
}

// SetSubDistrict sets the "SubDistrict" field.
func (m *RankingMutation) SetSubDistrict(s string) {
	m._SubDistrict = &s
}

// SubDistrict returns the value of the "SubDistrict" field in the mutation.
func (m *RankingMutation) SubDistrict() (r string, exists bool) {
	v := m._SubDistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrict returns the old "SubDistrict" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldSubDistrict(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrict: %w", err)
	}
	return oldValue.SubDistrict, nil
}

// ClearSubDistrict clears the value of the "SubDistrict" field.
func (m *RankingMutation) ClearSubDistrict() {
	m._SubDistrict = nil
	m.clearedFields[ranking.FieldSubDistrict] = struct{}{}
}

// SubDistrictCleared returns if the "SubDistrict" field was cleared in this mutation.
func (m *RankingMutation) SubDistrictCleared() bool {
	_, ok := m.clearedFields[ranking.FieldSubDistrict]
	return ok
}

// ResetSubDistrict resets all changes to the "SubDistrict" field.
func (m *RankingMutation) ResetSubDistrict() {
	m._SubDistrict = nil
	delete(m.clearedFields, ranking.FieldSubDistrict)
}

// SetPhoneno sets the "Phoneno" field.
func (m *RankingMutation) SetPhoneno(s string) {
	m._Phoneno = &s
}

// Phoneno returns the value of the "Phoneno" field in the mutation.
func (m *RankingMutation) Phoneno() (r string, exists bool) {
	v := m._Phoneno
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneno returns the old "Phoneno" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldPhoneno(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneno is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneno requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneno: %w", err)
	}
	return oldValue.Phoneno, nil
}

// ClearPhoneno clears the value of the "Phoneno" field.
func (m *RankingMutation) ClearPhoneno() {
	m._Phoneno = nil
	m.clearedFields[ranking.FieldPhoneno] = struct{}{}
}

// PhonenoCleared returns if the "Phoneno" field was cleared in this mutation.
func (m *RankingMutation) PhonenoCleared() bool {
	_, ok := m.clearedFields[ranking.FieldPhoneno]
	return ok
}

// ResetPhoneno resets all changes to the "Phoneno" field.
func (m *RankingMutation) ResetPhoneno() {
	m._Phoneno = nil
	delete(m.clearedFields, ranking.FieldPhoneno)
}

// SetAddressDetail sets the "AddressDetail" field.
func (m *RankingMutation) SetAddressDetail(s string) {
	m._AddressDetail = &s
}

// AddressDetail returns the value of the "AddressDetail" field in the mutation.
func (m *RankingMutation) AddressDetail() (r string, exists bool) {
	v := m._AddressDetail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "AddressDetail" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldAddressDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "AddressDetail" field.
func (m *RankingMutation) ClearAddressDetail() {
	m._AddressDetail = nil
	m.clearedFields[ranking.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "AddressDetail" field was cleared in this mutation.
func (m *RankingMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[ranking.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "AddressDetail" field.
func (m *RankingMutation) ResetAddressDetail() {
	m._AddressDetail = nil
	delete(m.clearedFields, ranking.FieldAddressDetail)
}

// SetStreet sets the "Street" field.
func (m *RankingMutation) SetStreet(s string) {
	m._Street = &s
}

// Street returns the value of the "Street" field in the mutation.
func (m *RankingMutation) Street() (r string, exists bool) {
	v := m._Street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "Street" field's value of the Ranking entity.
// If the Ranking object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RankingMutation) OldStreet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "Street" field.
func (m *RankingMutation) ClearStreet() {
	m._Street = nil
	m.clearedFields[ranking.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "Street" field was cleared in this mutation.
func (m *RankingMutation) StreetCleared() bool {
	_, ok := m.clearedFields[ranking.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "Street" field.
func (m *RankingMutation) ResetStreet() {
	m._Street = nil
	delete(m.clearedFields, ranking.FieldStreet)
}

// Op returns the operation name.
func (m *RankingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ranking).
func (m *RankingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RankingMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m._WalletID != nil {
		fields = append(fields, ranking.FieldWalletID)
	}
	if m._Name != nil {
		fields = append(fields, ranking.FieldName)
	}
	if m._TaxID != nil {
		fields = append(fields, ranking.FieldTaxID)
	}
	if m._ProvinceNameTH != nil {
		fields = append(fields, ranking.FieldProvinceNameTH)
	}
	if m._DistrictNameTH != nil {
		fields = append(fields, ranking.FieldDistrictNameTH)
	}
	if m._DistrictNameEN != nil {
		fields = append(fields, ranking.FieldDistrictNameEN)
	}
	if m._OccupationName != nil {
		fields = append(fields, ranking.FieldOccupationName)
	}
	if m._LastRank != nil {
		fields = append(fields, ranking.FieldLastRank)
	}
	if m._CurrentRank != nil {
		fields = append(fields, ranking.FieldCurrentRank)
	}
	if m._StatusRanking != nil {
		fields = append(fields, ranking.FieldStatusRanking)
	}
	if m._LastDateCalRank != nil {
		fields = append(fields, ranking.FieldLastDateCalRank)
	}
	if m._NextDateCalRank != nil {
		fields = append(fields, ranking.FieldNextDateCalRank)
	}
	if m._StateCal != nil {
		fields = append(fields, ranking.FieldStateCal)
	}
	if m._ZipCode != nil {
		fields = append(fields, ranking.FieldZipCode)
	}
	if m._TransactionFactorRank != nil {
		fields = append(fields, ranking.FieldTransactionFactorRank)
	}
	if m._RegisDate != nil {
		fields = append(fields, ranking.FieldRegisDate)
	}
	if m._SubDistrict != nil {
		fields = append(fields, ranking.FieldSubDistrict)
	}
	if m._Phoneno != nil {
		fields = append(fields, ranking.FieldPhoneno)
	}
	if m._AddressDetail != nil {
		fields = append(fields, ranking.FieldAddressDetail)
	}
	if m._Street != nil {
		fields = append(fields, ranking.FieldStreet)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RankingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ranking.FieldWalletID:
		return m.WalletID()
	case ranking.FieldName:
		return m.Name()
	case ranking.FieldTaxID:
		return m.TaxID()
	case ranking.FieldProvinceNameTH:
		return m.ProvinceNameTH()
	case ranking.FieldDistrictNameTH:
		return m.DistrictNameTH()
	case ranking.FieldDistrictNameEN:
		return m.DistrictNameEN()
	case ranking.FieldOccupationName:
		return m.OccupationName()
	case ranking.FieldLastRank:
		return m.LastRank()
	case ranking.FieldCurrentRank:
		return m.CurrentRank()
	case ranking.FieldStatusRanking:
		return m.StatusRanking()
	case ranking.FieldLastDateCalRank:
		return m.LastDateCalRank()
	case ranking.FieldNextDateCalRank:
		return m.NextDateCalRank()
	case ranking.FieldStateCal:
		return m.StateCal()
	case ranking.FieldZipCode:
		return m.ZipCode()
	case ranking.FieldTransactionFactorRank:
		return m.TransactionFactorRank()
	case ranking.FieldRegisDate:
		return m.RegisDate()
	case ranking.FieldSubDistrict:
		return m.SubDistrict()
	case ranking.FieldPhoneno:
		return m.Phoneno()
	case ranking.FieldAddressDetail:
		return m.AddressDetail()
	case ranking.FieldStreet:
		return m.Street()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RankingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ranking.FieldWalletID:
		return m.OldWalletID(ctx)
	case ranking.FieldName:
		return m.OldName(ctx)
	case ranking.FieldTaxID:
		return m.OldTaxID(ctx)
	case ranking.FieldProvinceNameTH:
		return m.OldProvinceNameTH(ctx)
	case ranking.FieldDistrictNameTH:
		return m.OldDistrictNameTH(ctx)
	case ranking.FieldDistrictNameEN:
		return m.OldDistrictNameEN(ctx)
	case ranking.FieldOccupationName:
		return m.OldOccupationName(ctx)
	case ranking.FieldLastRank:
		return m.OldLastRank(ctx)
	case ranking.FieldCurrentRank:
		return m.OldCurrentRank(ctx)
	case ranking.FieldStatusRanking:
		return m.OldStatusRanking(ctx)
	case ranking.FieldLastDateCalRank:
		return m.OldLastDateCalRank(ctx)
	case ranking.FieldNextDateCalRank:
		return m.OldNextDateCalRank(ctx)
	case ranking.FieldStateCal:
		return m.OldStateCal(ctx)
	case ranking.FieldZipCode:
		return m.OldZipCode(ctx)
	case ranking.FieldTransactionFactorRank:
		return m.OldTransactionFactorRank(ctx)
	case ranking.FieldRegisDate:
		return m.OldRegisDate(ctx)
	case ranking.FieldSubDistrict:
		return m.OldSubDistrict(ctx)
	case ranking.FieldPhoneno:
		return m.OldPhoneno(ctx)
	case ranking.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case ranking.FieldStreet:
		return m.OldStreet(ctx)
	}
	return nil, fmt.Errorf("unknown Ranking field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RankingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ranking.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case ranking.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ranking.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case ranking.FieldProvinceNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvinceNameTH(v)
		return nil
	case ranking.FieldDistrictNameTH:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictNameTH(v)
		return nil
	case ranking.FieldDistrictNameEN:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrictNameEN(v)
		return nil
	case ranking.FieldOccupationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationName(v)
		return nil
	case ranking.FieldLastRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRank(v)
		return nil
	case ranking.FieldCurrentRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrentRank(v)
		return nil
	case ranking.FieldStatusRanking:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusRanking(v)
		return nil
	case ranking.FieldLastDateCalRank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastDateCalRank(v)
		return nil
	case ranking.FieldNextDateCalRank:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNextDateCalRank(v)
		return nil
	case ranking.FieldStateCal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateCal(v)
		return nil
	case ranking.FieldZipCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZipCode(v)
		return nil
	case ranking.FieldTransactionFactorRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionFactorRank(v)
		return nil
	case ranking.FieldRegisDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisDate(v)
		return nil
	case ranking.FieldSubDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrict(v)
		return nil
	case ranking.FieldPhoneno:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneno(v)
		return nil
	case ranking.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case ranking.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	}
	return fmt.Errorf("unknown Ranking field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RankingMutation) AddedFields() []string {
	var fields []string
	if m.add_LastRank != nil {
		fields = append(fields, ranking.FieldLastRank)
	}
	if m.add_CurrentRank != nil {
		fields = append(fields, ranking.FieldCurrentRank)
	}
	if m.add_StateCal != nil {
		fields = append(fields, ranking.FieldStateCal)
	}
	if m.add_TransactionFactorRank != nil {
		fields = append(fields, ranking.FieldTransactionFactorRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RankingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case ranking.FieldLastRank:
		return m.AddedLastRank()
	case ranking.FieldCurrentRank:
		return m.AddedCurrentRank()
	case ranking.FieldStateCal:
		return m.AddedStateCal()
	case ranking.FieldTransactionFactorRank:
		return m.AddedTransactionFactorRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RankingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case ranking.FieldLastRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLastRank(v)
		return nil
	case ranking.FieldCurrentRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCurrentRank(v)
		return nil
	case ranking.FieldStateCal:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStateCal(v)
		return nil
	case ranking.FieldTransactionFactorRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionFactorRank(v)
		return nil
	}
	return fmt.Errorf("unknown Ranking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RankingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ranking.FieldName) {
		fields = append(fields, ranking.FieldName)
	}
	if m.FieldCleared(ranking.FieldTaxID) {
		fields = append(fields, ranking.FieldTaxID)
	}
	if m.FieldCleared(ranking.FieldProvinceNameTH) {
		fields = append(fields, ranking.FieldProvinceNameTH)
	}
	if m.FieldCleared(ranking.FieldDistrictNameTH) {
		fields = append(fields, ranking.FieldDistrictNameTH)
	}
	if m.FieldCleared(ranking.FieldDistrictNameEN) {
		fields = append(fields, ranking.FieldDistrictNameEN)
	}
	if m.FieldCleared(ranking.FieldOccupationName) {
		fields = append(fields, ranking.FieldOccupationName)
	}
	if m.FieldCleared(ranking.FieldLastRank) {
		fields = append(fields, ranking.FieldLastRank)
	}
	if m.FieldCleared(ranking.FieldCurrentRank) {
		fields = append(fields, ranking.FieldCurrentRank)
	}
	if m.FieldCleared(ranking.FieldStatusRanking) {
		fields = append(fields, ranking.FieldStatusRanking)
	}
	if m.FieldCleared(ranking.FieldLastDateCalRank) {
		fields = append(fields, ranking.FieldLastDateCalRank)
	}
	if m.FieldCleared(ranking.FieldNextDateCalRank) {
		fields = append(fields, ranking.FieldNextDateCalRank)
	}
	if m.FieldCleared(ranking.FieldStateCal) {
		fields = append(fields, ranking.FieldStateCal)
	}
	if m.FieldCleared(ranking.FieldZipCode) {
		fields = append(fields, ranking.FieldZipCode)
	}
	if m.FieldCleared(ranking.FieldTransactionFactorRank) {
		fields = append(fields, ranking.FieldTransactionFactorRank)
	}
	if m.FieldCleared(ranking.FieldRegisDate) {
		fields = append(fields, ranking.FieldRegisDate)
	}
	if m.FieldCleared(ranking.FieldSubDistrict) {
		fields = append(fields, ranking.FieldSubDistrict)
	}
	if m.FieldCleared(ranking.FieldPhoneno) {
		fields = append(fields, ranking.FieldPhoneno)
	}
	if m.FieldCleared(ranking.FieldAddressDetail) {
		fields = append(fields, ranking.FieldAddressDetail)
	}
	if m.FieldCleared(ranking.FieldStreet) {
		fields = append(fields, ranking.FieldStreet)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RankingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RankingMutation) ClearField(name string) error {
	switch name {
	case ranking.FieldName:
		m.ClearName()
		return nil
	case ranking.FieldTaxID:
		m.ClearTaxID()
		return nil
	case ranking.FieldProvinceNameTH:
		m.ClearProvinceNameTH()
		return nil
	case ranking.FieldDistrictNameTH:
		m.ClearDistrictNameTH()
		return nil
	case ranking.FieldDistrictNameEN:
		m.ClearDistrictNameEN()
		return nil
	case ranking.FieldOccupationName:
		m.ClearOccupationName()
		return nil
	case ranking.FieldLastRank:
		m.ClearLastRank()
		return nil
	case ranking.FieldCurrentRank:
		m.ClearCurrentRank()
		return nil
	case ranking.FieldStatusRanking:
		m.ClearStatusRanking()
		return nil
	case ranking.FieldLastDateCalRank:
		m.ClearLastDateCalRank()
		return nil
	case ranking.FieldNextDateCalRank:
		m.ClearNextDateCalRank()
		return nil
	case ranking.FieldStateCal:
		m.ClearStateCal()
		return nil
	case ranking.FieldZipCode:
		m.ClearZipCode()
		return nil
	case ranking.FieldTransactionFactorRank:
		m.ClearTransactionFactorRank()
		return nil
	case ranking.FieldRegisDate:
		m.ClearRegisDate()
		return nil
	case ranking.FieldSubDistrict:
		m.ClearSubDistrict()
		return nil
	case ranking.FieldPhoneno:
		m.ClearPhoneno()
		return nil
	case ranking.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case ranking.FieldStreet:
		m.ClearStreet()
		return nil
	}
	return fmt.Errorf("unknown Ranking nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RankingMutation) ResetField(name string) error {
	switch name {
	case ranking.FieldWalletID:
		m.ResetWalletID()
		return nil
	case ranking.FieldName:
		m.ResetName()
		return nil
	case ranking.FieldTaxID:
		m.ResetTaxID()
		return nil
	case ranking.FieldProvinceNameTH:
		m.ResetProvinceNameTH()
		return nil
	case ranking.FieldDistrictNameTH:
		m.ResetDistrictNameTH()
		return nil
	case ranking.FieldDistrictNameEN:
		m.ResetDistrictNameEN()
		return nil
	case ranking.FieldOccupationName:
		m.ResetOccupationName()
		return nil
	case ranking.FieldLastRank:
		m.ResetLastRank()
		return nil
	case ranking.FieldCurrentRank:
		m.ResetCurrentRank()
		return nil
	case ranking.FieldStatusRanking:
		m.ResetStatusRanking()
		return nil
	case ranking.FieldLastDateCalRank:
		m.ResetLastDateCalRank()
		return nil
	case ranking.FieldNextDateCalRank:
		m.ResetNextDateCalRank()
		return nil
	case ranking.FieldStateCal:
		m.ResetStateCal()
		return nil
	case ranking.FieldZipCode:
		m.ResetZipCode()
		return nil
	case ranking.FieldTransactionFactorRank:
		m.ResetTransactionFactorRank()
		return nil
	case ranking.FieldRegisDate:
		m.ResetRegisDate()
		return nil
	case ranking.FieldSubDistrict:
		m.ResetSubDistrict()
		return nil
	case ranking.FieldPhoneno:
		m.ResetPhoneno()
		return nil
	case ranking.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case ranking.FieldStreet:
		m.ResetStreet()
		return nil
	}
	return fmt.Errorf("unknown Ranking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RankingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RankingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RankingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RankingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RankingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RankingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RankingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Ranking unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RankingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Ranking edge %s", name)
}

// ReportWalletMutation represents an operation that mutates the ReportWallet nodes in the graph.
type ReportWalletMutation struct {
	config
	op                Op
	typ               string
	id                *int
	walletid          *string
	_WalletTypeName   *string
	_WalletPhoneno    *string
	_WalletName       *string
	_CitizenId        *string
	_Status           *string
	dateTime          *time.Time
	_Balance          *float64
	add_Balance       *float64
	_Email            *string
	_IsForgetPin      *string
	_ATMCard          *string
	_AccountNo        *string
	_AddressDetail    *string
	_Street           *string
	_District         *string
	_SubDistrict      *string
	_Province         *string
	_PostalCode       *string
	_RegisterDateTime *time.Time
	_FileimportID     *int
	add_FileimportID  *int
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*ReportWallet, error)
	predicates        []predicate.ReportWallet
}

var _ ent.Mutation = (*ReportWalletMutation)(nil)

// reportwalletOption allows management of the mutation configuration using functional options.
type reportwalletOption func(*ReportWalletMutation)

// newReportWalletMutation creates new mutation for the ReportWallet entity.
func newReportWalletMutation(c config, op Op, opts ...reportwalletOption) *ReportWalletMutation {
	m := &ReportWalletMutation{
		config:        c,
		op:            op,
		typ:           TypeReportWallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportWalletID sets the ID field of the mutation.
func withReportWalletID(id int) reportwalletOption {
	return func(m *ReportWalletMutation) {
		var (
			err   error
			once  sync.Once
			value *ReportWallet
		)
		m.oldValue = func(ctx context.Context) (*ReportWallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReportWallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportWallet sets the old ReportWallet of the mutation.
func withReportWallet(node *ReportWallet) reportwalletOption {
	return func(m *ReportWalletMutation) {
		m.oldValue = func(context.Context) (*ReportWallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportWalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportWalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReportWallet entities.
func (m *ReportWalletMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ReportWalletMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletid sets the "walletid" field.
func (m *ReportWalletMutation) SetWalletid(s string) {
	m.walletid = &s
}

// Walletid returns the value of the "walletid" field in the mutation.
func (m *ReportWalletMutation) Walletid() (r string, exists bool) {
	v := m.walletid
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletid returns the old "walletid" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldWalletid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletid: %w", err)
	}
	return oldValue.Walletid, nil
}

// ResetWalletid resets all changes to the "walletid" field.
func (m *ReportWalletMutation) ResetWalletid() {
	m.walletid = nil
}

// SetWalletTypeName sets the "WalletTypeName" field.
func (m *ReportWalletMutation) SetWalletTypeName(s string) {
	m._WalletTypeName = &s
}

// WalletTypeName returns the value of the "WalletTypeName" field in the mutation.
func (m *ReportWalletMutation) WalletTypeName() (r string, exists bool) {
	v := m._WalletTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletTypeName returns the old "WalletTypeName" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldWalletTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletTypeName: %w", err)
	}
	return oldValue.WalletTypeName, nil
}

// ClearWalletTypeName clears the value of the "WalletTypeName" field.
func (m *ReportWalletMutation) ClearWalletTypeName() {
	m._WalletTypeName = nil
	m.clearedFields[reportwallet.FieldWalletTypeName] = struct{}{}
}

// WalletTypeNameCleared returns if the "WalletTypeName" field was cleared in this mutation.
func (m *ReportWalletMutation) WalletTypeNameCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldWalletTypeName]
	return ok
}

// ResetWalletTypeName resets all changes to the "WalletTypeName" field.
func (m *ReportWalletMutation) ResetWalletTypeName() {
	m._WalletTypeName = nil
	delete(m.clearedFields, reportwallet.FieldWalletTypeName)
}

// SetWalletPhoneno sets the "WalletPhoneno" field.
func (m *ReportWalletMutation) SetWalletPhoneno(s string) {
	m._WalletPhoneno = &s
}

// WalletPhoneno returns the value of the "WalletPhoneno" field in the mutation.
func (m *ReportWalletMutation) WalletPhoneno() (r string, exists bool) {
	v := m._WalletPhoneno
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletPhoneno returns the old "WalletPhoneno" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldWalletPhoneno(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletPhoneno is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletPhoneno requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletPhoneno: %w", err)
	}
	return oldValue.WalletPhoneno, nil
}

// ClearWalletPhoneno clears the value of the "WalletPhoneno" field.
func (m *ReportWalletMutation) ClearWalletPhoneno() {
	m._WalletPhoneno = nil
	m.clearedFields[reportwallet.FieldWalletPhoneno] = struct{}{}
}

// WalletPhonenoCleared returns if the "WalletPhoneno" field was cleared in this mutation.
func (m *ReportWalletMutation) WalletPhonenoCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldWalletPhoneno]
	return ok
}

// ResetWalletPhoneno resets all changes to the "WalletPhoneno" field.
func (m *ReportWalletMutation) ResetWalletPhoneno() {
	m._WalletPhoneno = nil
	delete(m.clearedFields, reportwallet.FieldWalletPhoneno)
}

// SetWalletName sets the "WalletName" field.
func (m *ReportWalletMutation) SetWalletName(s string) {
	m._WalletName = &s
}

// WalletName returns the value of the "WalletName" field in the mutation.
func (m *ReportWalletMutation) WalletName() (r string, exists bool) {
	v := m._WalletName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletName returns the old "WalletName" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldWalletName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletName: %w", err)
	}
	return oldValue.WalletName, nil
}

// ClearWalletName clears the value of the "WalletName" field.
func (m *ReportWalletMutation) ClearWalletName() {
	m._WalletName = nil
	m.clearedFields[reportwallet.FieldWalletName] = struct{}{}
}

// WalletNameCleared returns if the "WalletName" field was cleared in this mutation.
func (m *ReportWalletMutation) WalletNameCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldWalletName]
	return ok
}

// ResetWalletName resets all changes to the "WalletName" field.
func (m *ReportWalletMutation) ResetWalletName() {
	m._WalletName = nil
	delete(m.clearedFields, reportwallet.FieldWalletName)
}

// SetCitizenId sets the "CitizenId" field.
func (m *ReportWalletMutation) SetCitizenId(s string) {
	m._CitizenId = &s
}

// CitizenId returns the value of the "CitizenId" field in the mutation.
func (m *ReportWalletMutation) CitizenId() (r string, exists bool) {
	v := m._CitizenId
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenId returns the old "CitizenId" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldCitizenId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCitizenId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCitizenId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenId: %w", err)
	}
	return oldValue.CitizenId, nil
}

// ClearCitizenId clears the value of the "CitizenId" field.
func (m *ReportWalletMutation) ClearCitizenId() {
	m._CitizenId = nil
	m.clearedFields[reportwallet.FieldCitizenId] = struct{}{}
}

// CitizenIdCleared returns if the "CitizenId" field was cleared in this mutation.
func (m *ReportWalletMutation) CitizenIdCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldCitizenId]
	return ok
}

// ResetCitizenId resets all changes to the "CitizenId" field.
func (m *ReportWalletMutation) ResetCitizenId() {
	m._CitizenId = nil
	delete(m.clearedFields, reportwallet.FieldCitizenId)
}

// SetStatus sets the "Status" field.
func (m *ReportWalletMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *ReportWalletMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *ReportWalletMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[reportwallet.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *ReportWalletMutation) StatusCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *ReportWalletMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, reportwallet.FieldStatus)
}

// SetDateTime sets the "dateTime" field.
func (m *ReportWalletMutation) SetDateTime(t time.Time) {
	m.dateTime = &t
}

// DateTime returns the value of the "dateTime" field in the mutation.
func (m *ReportWalletMutation) DateTime() (r time.Time, exists bool) {
	v := m.dateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldDateTime returns the old "dateTime" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateTime: %w", err)
	}
	return oldValue.DateTime, nil
}

// ClearDateTime clears the value of the "dateTime" field.
func (m *ReportWalletMutation) ClearDateTime() {
	m.dateTime = nil
	m.clearedFields[reportwallet.FieldDateTime] = struct{}{}
}

// DateTimeCleared returns if the "dateTime" field was cleared in this mutation.
func (m *ReportWalletMutation) DateTimeCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldDateTime]
	return ok
}

// ResetDateTime resets all changes to the "dateTime" field.
func (m *ReportWalletMutation) ResetDateTime() {
	m.dateTime = nil
	delete(m.clearedFields, reportwallet.FieldDateTime)
}

// SetBalance sets the "Balance" field.
func (m *ReportWalletMutation) SetBalance(f float64) {
	m._Balance = &f
	m.add_Balance = nil
}

// Balance returns the value of the "Balance" field in the mutation.
func (m *ReportWalletMutation) Balance() (r float64, exists bool) {
	v := m._Balance
	if v == nil {
		return
	}
	return *v, true
}

// OldBalance returns the old "Balance" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldBalance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBalance: %w", err)
	}
	return oldValue.Balance, nil
}

// AddBalance adds f to the "Balance" field.
func (m *ReportWalletMutation) AddBalance(f float64) {
	if m.add_Balance != nil {
		*m.add_Balance += f
	} else {
		m.add_Balance = &f
	}
}

// AddedBalance returns the value that was added to the "Balance" field in this mutation.
func (m *ReportWalletMutation) AddedBalance() (r float64, exists bool) {
	v := m.add_Balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearBalance clears the value of the "Balance" field.
func (m *ReportWalletMutation) ClearBalance() {
	m._Balance = nil
	m.add_Balance = nil
	m.clearedFields[reportwallet.FieldBalance] = struct{}{}
}

// BalanceCleared returns if the "Balance" field was cleared in this mutation.
func (m *ReportWalletMutation) BalanceCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldBalance]
	return ok
}

// ResetBalance resets all changes to the "Balance" field.
func (m *ReportWalletMutation) ResetBalance() {
	m._Balance = nil
	m.add_Balance = nil
	delete(m.clearedFields, reportwallet.FieldBalance)
}

// SetEmail sets the "Email" field.
func (m *ReportWalletMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *ReportWalletMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldEmail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *ReportWalletMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[reportwallet.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *ReportWalletMutation) EmailCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *ReportWalletMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, reportwallet.FieldEmail)
}

// SetIsForgetPin sets the "IsForgetPin" field.
func (m *ReportWalletMutation) SetIsForgetPin(s string) {
	m._IsForgetPin = &s
}

// IsForgetPin returns the value of the "IsForgetPin" field in the mutation.
func (m *ReportWalletMutation) IsForgetPin() (r string, exists bool) {
	v := m._IsForgetPin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsForgetPin returns the old "IsForgetPin" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldIsForgetPin(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsForgetPin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsForgetPin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsForgetPin: %w", err)
	}
	return oldValue.IsForgetPin, nil
}

// ClearIsForgetPin clears the value of the "IsForgetPin" field.
func (m *ReportWalletMutation) ClearIsForgetPin() {
	m._IsForgetPin = nil
	m.clearedFields[reportwallet.FieldIsForgetPin] = struct{}{}
}

// IsForgetPinCleared returns if the "IsForgetPin" field was cleared in this mutation.
func (m *ReportWalletMutation) IsForgetPinCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldIsForgetPin]
	return ok
}

// ResetIsForgetPin resets all changes to the "IsForgetPin" field.
func (m *ReportWalletMutation) ResetIsForgetPin() {
	m._IsForgetPin = nil
	delete(m.clearedFields, reportwallet.FieldIsForgetPin)
}

// SetATMCard sets the "ATMCard" field.
func (m *ReportWalletMutation) SetATMCard(s string) {
	m._ATMCard = &s
}

// ATMCard returns the value of the "ATMCard" field in the mutation.
func (m *ReportWalletMutation) ATMCard() (r string, exists bool) {
	v := m._ATMCard
	if v == nil {
		return
	}
	return *v, true
}

// OldATMCard returns the old "ATMCard" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldATMCard(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldATMCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldATMCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldATMCard: %w", err)
	}
	return oldValue.ATMCard, nil
}

// ClearATMCard clears the value of the "ATMCard" field.
func (m *ReportWalletMutation) ClearATMCard() {
	m._ATMCard = nil
	m.clearedFields[reportwallet.FieldATMCard] = struct{}{}
}

// ATMCardCleared returns if the "ATMCard" field was cleared in this mutation.
func (m *ReportWalletMutation) ATMCardCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldATMCard]
	return ok
}

// ResetATMCard resets all changes to the "ATMCard" field.
func (m *ReportWalletMutation) ResetATMCard() {
	m._ATMCard = nil
	delete(m.clearedFields, reportwallet.FieldATMCard)
}

// SetAccountNo sets the "AccountNo" field.
func (m *ReportWalletMutation) SetAccountNo(s string) {
	m._AccountNo = &s
}

// AccountNo returns the value of the "AccountNo" field in the mutation.
func (m *ReportWalletMutation) AccountNo() (r string, exists bool) {
	v := m._AccountNo
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNo returns the old "AccountNo" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldAccountNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNo: %w", err)
	}
	return oldValue.AccountNo, nil
}

// ClearAccountNo clears the value of the "AccountNo" field.
func (m *ReportWalletMutation) ClearAccountNo() {
	m._AccountNo = nil
	m.clearedFields[reportwallet.FieldAccountNo] = struct{}{}
}

// AccountNoCleared returns if the "AccountNo" field was cleared in this mutation.
func (m *ReportWalletMutation) AccountNoCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldAccountNo]
	return ok
}

// ResetAccountNo resets all changes to the "AccountNo" field.
func (m *ReportWalletMutation) ResetAccountNo() {
	m._AccountNo = nil
	delete(m.clearedFields, reportwallet.FieldAccountNo)
}

// SetAddressDetail sets the "AddressDetail" field.
func (m *ReportWalletMutation) SetAddressDetail(s string) {
	m._AddressDetail = &s
}

// AddressDetail returns the value of the "AddressDetail" field in the mutation.
func (m *ReportWalletMutation) AddressDetail() (r string, exists bool) {
	v := m._AddressDetail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "AddressDetail" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldAddressDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "AddressDetail" field.
func (m *ReportWalletMutation) ClearAddressDetail() {
	m._AddressDetail = nil
	m.clearedFields[reportwallet.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "AddressDetail" field was cleared in this mutation.
func (m *ReportWalletMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "AddressDetail" field.
func (m *ReportWalletMutation) ResetAddressDetail() {
	m._AddressDetail = nil
	delete(m.clearedFields, reportwallet.FieldAddressDetail)
}

// SetStreet sets the "Street" field.
func (m *ReportWalletMutation) SetStreet(s string) {
	m._Street = &s
}

// Street returns the value of the "Street" field in the mutation.
func (m *ReportWalletMutation) Street() (r string, exists bool) {
	v := m._Street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "Street" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldStreet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "Street" field.
func (m *ReportWalletMutation) ClearStreet() {
	m._Street = nil
	m.clearedFields[reportwallet.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "Street" field was cleared in this mutation.
func (m *ReportWalletMutation) StreetCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "Street" field.
func (m *ReportWalletMutation) ResetStreet() {
	m._Street = nil
	delete(m.clearedFields, reportwallet.FieldStreet)
}

// SetDistrict sets the "District" field.
func (m *ReportWalletMutation) SetDistrict(s string) {
	m._District = &s
}

// District returns the value of the "District" field in the mutation.
func (m *ReportWalletMutation) District() (r string, exists bool) {
	v := m._District
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "District" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "District" field.
func (m *ReportWalletMutation) ClearDistrict() {
	m._District = nil
	m.clearedFields[reportwallet.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "District" field was cleared in this mutation.
func (m *ReportWalletMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "District" field.
func (m *ReportWalletMutation) ResetDistrict() {
	m._District = nil
	delete(m.clearedFields, reportwallet.FieldDistrict)
}

// SetSubDistrict sets the "SubDistrict" field.
func (m *ReportWalletMutation) SetSubDistrict(s string) {
	m._SubDistrict = &s
}

// SubDistrict returns the value of the "SubDistrict" field in the mutation.
func (m *ReportWalletMutation) SubDistrict() (r string, exists bool) {
	v := m._SubDistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrict returns the old "SubDistrict" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldSubDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrict: %w", err)
	}
	return oldValue.SubDistrict, nil
}

// ClearSubDistrict clears the value of the "SubDistrict" field.
func (m *ReportWalletMutation) ClearSubDistrict() {
	m._SubDistrict = nil
	m.clearedFields[reportwallet.FieldSubDistrict] = struct{}{}
}

// SubDistrictCleared returns if the "SubDistrict" field was cleared in this mutation.
func (m *ReportWalletMutation) SubDistrictCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldSubDistrict]
	return ok
}

// ResetSubDistrict resets all changes to the "SubDistrict" field.
func (m *ReportWalletMutation) ResetSubDistrict() {
	m._SubDistrict = nil
	delete(m.clearedFields, reportwallet.FieldSubDistrict)
}

// SetProvince sets the "Province" field.
func (m *ReportWalletMutation) SetProvince(s string) {
	m._Province = &s
}

// Province returns the value of the "Province" field in the mutation.
func (m *ReportWalletMutation) Province() (r string, exists bool) {
	v := m._Province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "Province" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldProvince(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "Province" field.
func (m *ReportWalletMutation) ClearProvince() {
	m._Province = nil
	m.clearedFields[reportwallet.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "Province" field was cleared in this mutation.
func (m *ReportWalletMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "Province" field.
func (m *ReportWalletMutation) ResetProvince() {
	m._Province = nil
	delete(m.clearedFields, reportwallet.FieldProvince)
}

// SetPostalCode sets the "PostalCode" field.
func (m *ReportWalletMutation) SetPostalCode(s string) {
	m._PostalCode = &s
}

// PostalCode returns the value of the "PostalCode" field in the mutation.
func (m *ReportWalletMutation) PostalCode() (r string, exists bool) {
	v := m._PostalCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "PostalCode" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "PostalCode" field.
func (m *ReportWalletMutation) ClearPostalCode() {
	m._PostalCode = nil
	m.clearedFields[reportwallet.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "PostalCode" field was cleared in this mutation.
func (m *ReportWalletMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "PostalCode" field.
func (m *ReportWalletMutation) ResetPostalCode() {
	m._PostalCode = nil
	delete(m.clearedFields, reportwallet.FieldPostalCode)
}

// SetRegisterDateTime sets the "RegisterDateTime" field.
func (m *ReportWalletMutation) SetRegisterDateTime(t time.Time) {
	m._RegisterDateTime = &t
}

// RegisterDateTime returns the value of the "RegisterDateTime" field in the mutation.
func (m *ReportWalletMutation) RegisterDateTime() (r time.Time, exists bool) {
	v := m._RegisterDateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterDateTime returns the old "RegisterDateTime" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldRegisterDateTime(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisterDateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisterDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterDateTime: %w", err)
	}
	return oldValue.RegisterDateTime, nil
}

// ClearRegisterDateTime clears the value of the "RegisterDateTime" field.
func (m *ReportWalletMutation) ClearRegisterDateTime() {
	m._RegisterDateTime = nil
	m.clearedFields[reportwallet.FieldRegisterDateTime] = struct{}{}
}

// RegisterDateTimeCleared returns if the "RegisterDateTime" field was cleared in this mutation.
func (m *ReportWalletMutation) RegisterDateTimeCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldRegisterDateTime]
	return ok
}

// ResetRegisterDateTime resets all changes to the "RegisterDateTime" field.
func (m *ReportWalletMutation) ResetRegisterDateTime() {
	m._RegisterDateTime = nil
	delete(m.clearedFields, reportwallet.FieldRegisterDateTime)
}

// SetFileimportID sets the "FileimportID" field.
func (m *ReportWalletMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *ReportWalletMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the ReportWallet entity.
// If the ReportWallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportWalletMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *ReportWalletMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *ReportWalletMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *ReportWalletMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[reportwallet.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *ReportWalletMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[reportwallet.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *ReportWalletMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, reportwallet.FieldFileimportID)
}

// Op returns the operation name.
func (m *ReportWalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ReportWallet).
func (m *ReportWalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportWalletMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.walletid != nil {
		fields = append(fields, reportwallet.FieldWalletid)
	}
	if m._WalletTypeName != nil {
		fields = append(fields, reportwallet.FieldWalletTypeName)
	}
	if m._WalletPhoneno != nil {
		fields = append(fields, reportwallet.FieldWalletPhoneno)
	}
	if m._WalletName != nil {
		fields = append(fields, reportwallet.FieldWalletName)
	}
	if m._CitizenId != nil {
		fields = append(fields, reportwallet.FieldCitizenId)
	}
	if m._Status != nil {
		fields = append(fields, reportwallet.FieldStatus)
	}
	if m.dateTime != nil {
		fields = append(fields, reportwallet.FieldDateTime)
	}
	if m._Balance != nil {
		fields = append(fields, reportwallet.FieldBalance)
	}
	if m._Email != nil {
		fields = append(fields, reportwallet.FieldEmail)
	}
	if m._IsForgetPin != nil {
		fields = append(fields, reportwallet.FieldIsForgetPin)
	}
	if m._ATMCard != nil {
		fields = append(fields, reportwallet.FieldATMCard)
	}
	if m._AccountNo != nil {
		fields = append(fields, reportwallet.FieldAccountNo)
	}
	if m._AddressDetail != nil {
		fields = append(fields, reportwallet.FieldAddressDetail)
	}
	if m._Street != nil {
		fields = append(fields, reportwallet.FieldStreet)
	}
	if m._District != nil {
		fields = append(fields, reportwallet.FieldDistrict)
	}
	if m._SubDistrict != nil {
		fields = append(fields, reportwallet.FieldSubDistrict)
	}
	if m._Province != nil {
		fields = append(fields, reportwallet.FieldProvince)
	}
	if m._PostalCode != nil {
		fields = append(fields, reportwallet.FieldPostalCode)
	}
	if m._RegisterDateTime != nil {
		fields = append(fields, reportwallet.FieldRegisterDateTime)
	}
	if m._FileimportID != nil {
		fields = append(fields, reportwallet.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportWalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportwallet.FieldWalletid:
		return m.Walletid()
	case reportwallet.FieldWalletTypeName:
		return m.WalletTypeName()
	case reportwallet.FieldWalletPhoneno:
		return m.WalletPhoneno()
	case reportwallet.FieldWalletName:
		return m.WalletName()
	case reportwallet.FieldCitizenId:
		return m.CitizenId()
	case reportwallet.FieldStatus:
		return m.Status()
	case reportwallet.FieldDateTime:
		return m.DateTime()
	case reportwallet.FieldBalance:
		return m.Balance()
	case reportwallet.FieldEmail:
		return m.Email()
	case reportwallet.FieldIsForgetPin:
		return m.IsForgetPin()
	case reportwallet.FieldATMCard:
		return m.ATMCard()
	case reportwallet.FieldAccountNo:
		return m.AccountNo()
	case reportwallet.FieldAddressDetail:
		return m.AddressDetail()
	case reportwallet.FieldStreet:
		return m.Street()
	case reportwallet.FieldDistrict:
		return m.District()
	case reportwallet.FieldSubDistrict:
		return m.SubDistrict()
	case reportwallet.FieldProvince:
		return m.Province()
	case reportwallet.FieldPostalCode:
		return m.PostalCode()
	case reportwallet.FieldRegisterDateTime:
		return m.RegisterDateTime()
	case reportwallet.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportWalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportwallet.FieldWalletid:
		return m.OldWalletid(ctx)
	case reportwallet.FieldWalletTypeName:
		return m.OldWalletTypeName(ctx)
	case reportwallet.FieldWalletPhoneno:
		return m.OldWalletPhoneno(ctx)
	case reportwallet.FieldWalletName:
		return m.OldWalletName(ctx)
	case reportwallet.FieldCitizenId:
		return m.OldCitizenId(ctx)
	case reportwallet.FieldStatus:
		return m.OldStatus(ctx)
	case reportwallet.FieldDateTime:
		return m.OldDateTime(ctx)
	case reportwallet.FieldBalance:
		return m.OldBalance(ctx)
	case reportwallet.FieldEmail:
		return m.OldEmail(ctx)
	case reportwallet.FieldIsForgetPin:
		return m.OldIsForgetPin(ctx)
	case reportwallet.FieldATMCard:
		return m.OldATMCard(ctx)
	case reportwallet.FieldAccountNo:
		return m.OldAccountNo(ctx)
	case reportwallet.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case reportwallet.FieldStreet:
		return m.OldStreet(ctx)
	case reportwallet.FieldDistrict:
		return m.OldDistrict(ctx)
	case reportwallet.FieldSubDistrict:
		return m.OldSubDistrict(ctx)
	case reportwallet.FieldProvince:
		return m.OldProvince(ctx)
	case reportwallet.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case reportwallet.FieldRegisterDateTime:
		return m.OldRegisterDateTime(ctx)
	case reportwallet.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown ReportWallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportWalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportwallet.FieldWalletid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletid(v)
		return nil
	case reportwallet.FieldWalletTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletTypeName(v)
		return nil
	case reportwallet.FieldWalletPhoneno:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletPhoneno(v)
		return nil
	case reportwallet.FieldWalletName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletName(v)
		return nil
	case reportwallet.FieldCitizenId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenId(v)
		return nil
	case reportwallet.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reportwallet.FieldDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateTime(v)
		return nil
	case reportwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBalance(v)
		return nil
	case reportwallet.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case reportwallet.FieldIsForgetPin:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsForgetPin(v)
		return nil
	case reportwallet.FieldATMCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetATMCard(v)
		return nil
	case reportwallet.FieldAccountNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNo(v)
		return nil
	case reportwallet.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case reportwallet.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case reportwallet.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case reportwallet.FieldSubDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrict(v)
		return nil
	case reportwallet.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case reportwallet.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case reportwallet.FieldRegisterDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterDateTime(v)
		return nil
	case reportwallet.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown ReportWallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportWalletMutation) AddedFields() []string {
	var fields []string
	if m.add_Balance != nil {
		fields = append(fields, reportwallet.FieldBalance)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, reportwallet.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportWalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reportwallet.FieldBalance:
		return m.AddedBalance()
	case reportwallet.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportWalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reportwallet.FieldBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBalance(v)
		return nil
	case reportwallet.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown ReportWallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportWalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reportwallet.FieldWalletTypeName) {
		fields = append(fields, reportwallet.FieldWalletTypeName)
	}
	if m.FieldCleared(reportwallet.FieldWalletPhoneno) {
		fields = append(fields, reportwallet.FieldWalletPhoneno)
	}
	if m.FieldCleared(reportwallet.FieldWalletName) {
		fields = append(fields, reportwallet.FieldWalletName)
	}
	if m.FieldCleared(reportwallet.FieldCitizenId) {
		fields = append(fields, reportwallet.FieldCitizenId)
	}
	if m.FieldCleared(reportwallet.FieldStatus) {
		fields = append(fields, reportwallet.FieldStatus)
	}
	if m.FieldCleared(reportwallet.FieldDateTime) {
		fields = append(fields, reportwallet.FieldDateTime)
	}
	if m.FieldCleared(reportwallet.FieldBalance) {
		fields = append(fields, reportwallet.FieldBalance)
	}
	if m.FieldCleared(reportwallet.FieldEmail) {
		fields = append(fields, reportwallet.FieldEmail)
	}
	if m.FieldCleared(reportwallet.FieldIsForgetPin) {
		fields = append(fields, reportwallet.FieldIsForgetPin)
	}
	if m.FieldCleared(reportwallet.FieldATMCard) {
		fields = append(fields, reportwallet.FieldATMCard)
	}
	if m.FieldCleared(reportwallet.FieldAccountNo) {
		fields = append(fields, reportwallet.FieldAccountNo)
	}
	if m.FieldCleared(reportwallet.FieldAddressDetail) {
		fields = append(fields, reportwallet.FieldAddressDetail)
	}
	if m.FieldCleared(reportwallet.FieldStreet) {
		fields = append(fields, reportwallet.FieldStreet)
	}
	if m.FieldCleared(reportwallet.FieldDistrict) {
		fields = append(fields, reportwallet.FieldDistrict)
	}
	if m.FieldCleared(reportwallet.FieldSubDistrict) {
		fields = append(fields, reportwallet.FieldSubDistrict)
	}
	if m.FieldCleared(reportwallet.FieldProvince) {
		fields = append(fields, reportwallet.FieldProvince)
	}
	if m.FieldCleared(reportwallet.FieldPostalCode) {
		fields = append(fields, reportwallet.FieldPostalCode)
	}
	if m.FieldCleared(reportwallet.FieldRegisterDateTime) {
		fields = append(fields, reportwallet.FieldRegisterDateTime)
	}
	if m.FieldCleared(reportwallet.FieldFileimportID) {
		fields = append(fields, reportwallet.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportWalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportWalletMutation) ClearField(name string) error {
	switch name {
	case reportwallet.FieldWalletTypeName:
		m.ClearWalletTypeName()
		return nil
	case reportwallet.FieldWalletPhoneno:
		m.ClearWalletPhoneno()
		return nil
	case reportwallet.FieldWalletName:
		m.ClearWalletName()
		return nil
	case reportwallet.FieldCitizenId:
		m.ClearCitizenId()
		return nil
	case reportwallet.FieldStatus:
		m.ClearStatus()
		return nil
	case reportwallet.FieldDateTime:
		m.ClearDateTime()
		return nil
	case reportwallet.FieldBalance:
		m.ClearBalance()
		return nil
	case reportwallet.FieldEmail:
		m.ClearEmail()
		return nil
	case reportwallet.FieldIsForgetPin:
		m.ClearIsForgetPin()
		return nil
	case reportwallet.FieldATMCard:
		m.ClearATMCard()
		return nil
	case reportwallet.FieldAccountNo:
		m.ClearAccountNo()
		return nil
	case reportwallet.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case reportwallet.FieldStreet:
		m.ClearStreet()
		return nil
	case reportwallet.FieldDistrict:
		m.ClearDistrict()
		return nil
	case reportwallet.FieldSubDistrict:
		m.ClearSubDistrict()
		return nil
	case reportwallet.FieldProvince:
		m.ClearProvince()
		return nil
	case reportwallet.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case reportwallet.FieldRegisterDateTime:
		m.ClearRegisterDateTime()
		return nil
	case reportwallet.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown ReportWallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportWalletMutation) ResetField(name string) error {
	switch name {
	case reportwallet.FieldWalletid:
		m.ResetWalletid()
		return nil
	case reportwallet.FieldWalletTypeName:
		m.ResetWalletTypeName()
		return nil
	case reportwallet.FieldWalletPhoneno:
		m.ResetWalletPhoneno()
		return nil
	case reportwallet.FieldWalletName:
		m.ResetWalletName()
		return nil
	case reportwallet.FieldCitizenId:
		m.ResetCitizenId()
		return nil
	case reportwallet.FieldStatus:
		m.ResetStatus()
		return nil
	case reportwallet.FieldDateTime:
		m.ResetDateTime()
		return nil
	case reportwallet.FieldBalance:
		m.ResetBalance()
		return nil
	case reportwallet.FieldEmail:
		m.ResetEmail()
		return nil
	case reportwallet.FieldIsForgetPin:
		m.ResetIsForgetPin()
		return nil
	case reportwallet.FieldATMCard:
		m.ResetATMCard()
		return nil
	case reportwallet.FieldAccountNo:
		m.ResetAccountNo()
		return nil
	case reportwallet.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case reportwallet.FieldStreet:
		m.ResetStreet()
		return nil
	case reportwallet.FieldDistrict:
		m.ResetDistrict()
		return nil
	case reportwallet.FieldSubDistrict:
		m.ResetSubDistrict()
		return nil
	case reportwallet.FieldProvince:
		m.ResetProvince()
		return nil
	case reportwallet.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case reportwallet.FieldRegisterDateTime:
		m.ResetRegisterDateTime()
		return nil
	case reportwallet.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown ReportWallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportWalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportWalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportWalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportWalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportWalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportWalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportWalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ReportWallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportWalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ReportWallet edge %s", name)
}

// ReportwallettbMutation represents an operation that mutates the Reportwallettb nodes in the graph.
type ReportwallettbMutation struct {
	config
	op              Op
	typ             string
	id              *int
	walletid        *string
	_WalletTypeName *string
	_WalletPhoneno  *string
	_WalletName     *string
	_CitizenId      *string
	_Status         *string
	_RegisterDate   *time.Time
	_GroupUser      *int
	add_GroupUser   *int
	_UserAgent      *string
	_KYC_Date       *time.Time
	_ATMCard        *string
	_AccountNo      *string
	_AddressDetail  *string
	_Street         *string
	_District       *string
	_SubDistrict    *string
	_Province       *string
	_PostalCode     *string
	isKYC           *string
	_UpdateDate     *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*Reportwallettb, error)
	predicates      []predicate.Reportwallettb
}

var _ ent.Mutation = (*ReportwallettbMutation)(nil)

// reportwallettbOption allows management of the mutation configuration using functional options.
type reportwallettbOption func(*ReportwallettbMutation)

// newReportwallettbMutation creates new mutation for the Reportwallettb entity.
func newReportwallettbMutation(c config, op Op, opts ...reportwallettbOption) *ReportwallettbMutation {
	m := &ReportwallettbMutation{
		config:        c,
		op:            op,
		typ:           TypeReportwallettb,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReportwallettbID sets the ID field of the mutation.
func withReportwallettbID(id int) reportwallettbOption {
	return func(m *ReportwallettbMutation) {
		var (
			err   error
			once  sync.Once
			value *Reportwallettb
		)
		m.oldValue = func(ctx context.Context) (*Reportwallettb, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Reportwallettb.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReportwallettb sets the old Reportwallettb of the mutation.
func withReportwallettb(node *Reportwallettb) reportwallettbOption {
	return func(m *ReportwallettbMutation) {
		m.oldValue = func(context.Context) (*Reportwallettb, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReportwallettbMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReportwallettbMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Reportwallettb entities.
func (m *ReportwallettbMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *ReportwallettbMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletid sets the "walletid" field.
func (m *ReportwallettbMutation) SetWalletid(s string) {
	m.walletid = &s
}

// Walletid returns the value of the "walletid" field in the mutation.
func (m *ReportwallettbMutation) Walletid() (r string, exists bool) {
	v := m.walletid
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletid returns the old "walletid" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldWalletid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletid: %w", err)
	}
	return oldValue.Walletid, nil
}

// ResetWalletid resets all changes to the "walletid" field.
func (m *ReportwallettbMutation) ResetWalletid() {
	m.walletid = nil
}

// SetWalletTypeName sets the "WalletTypeName" field.
func (m *ReportwallettbMutation) SetWalletTypeName(s string) {
	m._WalletTypeName = &s
}

// WalletTypeName returns the value of the "WalletTypeName" field in the mutation.
func (m *ReportwallettbMutation) WalletTypeName() (r string, exists bool) {
	v := m._WalletTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletTypeName returns the old "WalletTypeName" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldWalletTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletTypeName: %w", err)
	}
	return oldValue.WalletTypeName, nil
}

// ClearWalletTypeName clears the value of the "WalletTypeName" field.
func (m *ReportwallettbMutation) ClearWalletTypeName() {
	m._WalletTypeName = nil
	m.clearedFields[reportwallettb.FieldWalletTypeName] = struct{}{}
}

// WalletTypeNameCleared returns if the "WalletTypeName" field was cleared in this mutation.
func (m *ReportwallettbMutation) WalletTypeNameCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldWalletTypeName]
	return ok
}

// ResetWalletTypeName resets all changes to the "WalletTypeName" field.
func (m *ReportwallettbMutation) ResetWalletTypeName() {
	m._WalletTypeName = nil
	delete(m.clearedFields, reportwallettb.FieldWalletTypeName)
}

// SetWalletPhoneno sets the "WalletPhoneno" field.
func (m *ReportwallettbMutation) SetWalletPhoneno(s string) {
	m._WalletPhoneno = &s
}

// WalletPhoneno returns the value of the "WalletPhoneno" field in the mutation.
func (m *ReportwallettbMutation) WalletPhoneno() (r string, exists bool) {
	v := m._WalletPhoneno
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletPhoneno returns the old "WalletPhoneno" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldWalletPhoneno(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletPhoneno is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletPhoneno requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletPhoneno: %w", err)
	}
	return oldValue.WalletPhoneno, nil
}

// ClearWalletPhoneno clears the value of the "WalletPhoneno" field.
func (m *ReportwallettbMutation) ClearWalletPhoneno() {
	m._WalletPhoneno = nil
	m.clearedFields[reportwallettb.FieldWalletPhoneno] = struct{}{}
}

// WalletPhonenoCleared returns if the "WalletPhoneno" field was cleared in this mutation.
func (m *ReportwallettbMutation) WalletPhonenoCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldWalletPhoneno]
	return ok
}

// ResetWalletPhoneno resets all changes to the "WalletPhoneno" field.
func (m *ReportwallettbMutation) ResetWalletPhoneno() {
	m._WalletPhoneno = nil
	delete(m.clearedFields, reportwallettb.FieldWalletPhoneno)
}

// SetWalletName sets the "WalletName" field.
func (m *ReportwallettbMutation) SetWalletName(s string) {
	m._WalletName = &s
}

// WalletName returns the value of the "WalletName" field in the mutation.
func (m *ReportwallettbMutation) WalletName() (r string, exists bool) {
	v := m._WalletName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletName returns the old "WalletName" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldWalletName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletName: %w", err)
	}
	return oldValue.WalletName, nil
}

// ClearWalletName clears the value of the "WalletName" field.
func (m *ReportwallettbMutation) ClearWalletName() {
	m._WalletName = nil
	m.clearedFields[reportwallettb.FieldWalletName] = struct{}{}
}

// WalletNameCleared returns if the "WalletName" field was cleared in this mutation.
func (m *ReportwallettbMutation) WalletNameCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldWalletName]
	return ok
}

// ResetWalletName resets all changes to the "WalletName" field.
func (m *ReportwallettbMutation) ResetWalletName() {
	m._WalletName = nil
	delete(m.clearedFields, reportwallettb.FieldWalletName)
}

// SetCitizenId sets the "CitizenId" field.
func (m *ReportwallettbMutation) SetCitizenId(s string) {
	m._CitizenId = &s
}

// CitizenId returns the value of the "CitizenId" field in the mutation.
func (m *ReportwallettbMutation) CitizenId() (r string, exists bool) {
	v := m._CitizenId
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenId returns the old "CitizenId" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldCitizenId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCitizenId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCitizenId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenId: %w", err)
	}
	return oldValue.CitizenId, nil
}

// ClearCitizenId clears the value of the "CitizenId" field.
func (m *ReportwallettbMutation) ClearCitizenId() {
	m._CitizenId = nil
	m.clearedFields[reportwallettb.FieldCitizenId] = struct{}{}
}

// CitizenIdCleared returns if the "CitizenId" field was cleared in this mutation.
func (m *ReportwallettbMutation) CitizenIdCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldCitizenId]
	return ok
}

// ResetCitizenId resets all changes to the "CitizenId" field.
func (m *ReportwallettbMutation) ResetCitizenId() {
	m._CitizenId = nil
	delete(m.clearedFields, reportwallettb.FieldCitizenId)
}

// SetStatus sets the "Status" field.
func (m *ReportwallettbMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *ReportwallettbMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *ReportwallettbMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[reportwallettb.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *ReportwallettbMutation) StatusCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *ReportwallettbMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, reportwallettb.FieldStatus)
}

// SetRegisterDate sets the "RegisterDate" field.
func (m *ReportwallettbMutation) SetRegisterDate(t time.Time) {
	m._RegisterDate = &t
}

// RegisterDate returns the value of the "RegisterDate" field in the mutation.
func (m *ReportwallettbMutation) RegisterDate() (r time.Time, exists bool) {
	v := m._RegisterDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterDate returns the old "RegisterDate" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldRegisterDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterDate: %w", err)
	}
	return oldValue.RegisterDate, nil
}

// ClearRegisterDate clears the value of the "RegisterDate" field.
func (m *ReportwallettbMutation) ClearRegisterDate() {
	m._RegisterDate = nil
	m.clearedFields[reportwallettb.FieldRegisterDate] = struct{}{}
}

// RegisterDateCleared returns if the "RegisterDate" field was cleared in this mutation.
func (m *ReportwallettbMutation) RegisterDateCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldRegisterDate]
	return ok
}

// ResetRegisterDate resets all changes to the "RegisterDate" field.
func (m *ReportwallettbMutation) ResetRegisterDate() {
	m._RegisterDate = nil
	delete(m.clearedFields, reportwallettb.FieldRegisterDate)
}

// SetGroupUser sets the "GroupUser" field.
func (m *ReportwallettbMutation) SetGroupUser(i int) {
	m._GroupUser = &i
	m.add_GroupUser = nil
}

// GroupUser returns the value of the "GroupUser" field in the mutation.
func (m *ReportwallettbMutation) GroupUser() (r int, exists bool) {
	v := m._GroupUser
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupUser returns the old "GroupUser" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldGroupUser(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupUser: %w", err)
	}
	return oldValue.GroupUser, nil
}

// AddGroupUser adds i to the "GroupUser" field.
func (m *ReportwallettbMutation) AddGroupUser(i int) {
	if m.add_GroupUser != nil {
		*m.add_GroupUser += i
	} else {
		m.add_GroupUser = &i
	}
}

// AddedGroupUser returns the value that was added to the "GroupUser" field in this mutation.
func (m *ReportwallettbMutation) AddedGroupUser() (r int, exists bool) {
	v := m.add_GroupUser
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupUser clears the value of the "GroupUser" field.
func (m *ReportwallettbMutation) ClearGroupUser() {
	m._GroupUser = nil
	m.add_GroupUser = nil
	m.clearedFields[reportwallettb.FieldGroupUser] = struct{}{}
}

// GroupUserCleared returns if the "GroupUser" field was cleared in this mutation.
func (m *ReportwallettbMutation) GroupUserCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldGroupUser]
	return ok
}

// ResetGroupUser resets all changes to the "GroupUser" field.
func (m *ReportwallettbMutation) ResetGroupUser() {
	m._GroupUser = nil
	m.add_GroupUser = nil
	delete(m.clearedFields, reportwallettb.FieldGroupUser)
}

// SetUserAgent sets the "UserAgent" field.
func (m *ReportwallettbMutation) SetUserAgent(s string) {
	m._UserAgent = &s
}

// UserAgent returns the value of the "UserAgent" field in the mutation.
func (m *ReportwallettbMutation) UserAgent() (r string, exists bool) {
	v := m._UserAgent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "UserAgent" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "UserAgent" field.
func (m *ReportwallettbMutation) ClearUserAgent() {
	m._UserAgent = nil
	m.clearedFields[reportwallettb.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "UserAgent" field was cleared in this mutation.
func (m *ReportwallettbMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "UserAgent" field.
func (m *ReportwallettbMutation) ResetUserAgent() {
	m._UserAgent = nil
	delete(m.clearedFields, reportwallettb.FieldUserAgent)
}

// SetKYCDate sets the "KYC_Date" field.
func (m *ReportwallettbMutation) SetKYCDate(t time.Time) {
	m._KYC_Date = &t
}

// KYCDate returns the value of the "KYC_Date" field in the mutation.
func (m *ReportwallettbMutation) KYCDate() (r time.Time, exists bool) {
	v := m._KYC_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYC_Date" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldKYCDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYC_Date" field.
func (m *ReportwallettbMutation) ClearKYCDate() {
	m._KYC_Date = nil
	m.clearedFields[reportwallettb.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYC_Date" field was cleared in this mutation.
func (m *ReportwallettbMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYC_Date" field.
func (m *ReportwallettbMutation) ResetKYCDate() {
	m._KYC_Date = nil
	delete(m.clearedFields, reportwallettb.FieldKYCDate)
}

// SetATMCard sets the "ATMCard" field.
func (m *ReportwallettbMutation) SetATMCard(s string) {
	m._ATMCard = &s
}

// ATMCard returns the value of the "ATMCard" field in the mutation.
func (m *ReportwallettbMutation) ATMCard() (r string, exists bool) {
	v := m._ATMCard
	if v == nil {
		return
	}
	return *v, true
}

// OldATMCard returns the old "ATMCard" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldATMCard(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldATMCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldATMCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldATMCard: %w", err)
	}
	return oldValue.ATMCard, nil
}

// ClearATMCard clears the value of the "ATMCard" field.
func (m *ReportwallettbMutation) ClearATMCard() {
	m._ATMCard = nil
	m.clearedFields[reportwallettb.FieldATMCard] = struct{}{}
}

// ATMCardCleared returns if the "ATMCard" field was cleared in this mutation.
func (m *ReportwallettbMutation) ATMCardCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldATMCard]
	return ok
}

// ResetATMCard resets all changes to the "ATMCard" field.
func (m *ReportwallettbMutation) ResetATMCard() {
	m._ATMCard = nil
	delete(m.clearedFields, reportwallettb.FieldATMCard)
}

// SetAccountNo sets the "AccountNo" field.
func (m *ReportwallettbMutation) SetAccountNo(s string) {
	m._AccountNo = &s
}

// AccountNo returns the value of the "AccountNo" field in the mutation.
func (m *ReportwallettbMutation) AccountNo() (r string, exists bool) {
	v := m._AccountNo
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNo returns the old "AccountNo" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldAccountNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNo: %w", err)
	}
	return oldValue.AccountNo, nil
}

// ClearAccountNo clears the value of the "AccountNo" field.
func (m *ReportwallettbMutation) ClearAccountNo() {
	m._AccountNo = nil
	m.clearedFields[reportwallettb.FieldAccountNo] = struct{}{}
}

// AccountNoCleared returns if the "AccountNo" field was cleared in this mutation.
func (m *ReportwallettbMutation) AccountNoCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldAccountNo]
	return ok
}

// ResetAccountNo resets all changes to the "AccountNo" field.
func (m *ReportwallettbMutation) ResetAccountNo() {
	m._AccountNo = nil
	delete(m.clearedFields, reportwallettb.FieldAccountNo)
}

// SetAddressDetail sets the "AddressDetail" field.
func (m *ReportwallettbMutation) SetAddressDetail(s string) {
	m._AddressDetail = &s
}

// AddressDetail returns the value of the "AddressDetail" field in the mutation.
func (m *ReportwallettbMutation) AddressDetail() (r string, exists bool) {
	v := m._AddressDetail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "AddressDetail" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldAddressDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "AddressDetail" field.
func (m *ReportwallettbMutation) ClearAddressDetail() {
	m._AddressDetail = nil
	m.clearedFields[reportwallettb.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "AddressDetail" field was cleared in this mutation.
func (m *ReportwallettbMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "AddressDetail" field.
func (m *ReportwallettbMutation) ResetAddressDetail() {
	m._AddressDetail = nil
	delete(m.clearedFields, reportwallettb.FieldAddressDetail)
}

// SetStreet sets the "Street" field.
func (m *ReportwallettbMutation) SetStreet(s string) {
	m._Street = &s
}

// Street returns the value of the "Street" field in the mutation.
func (m *ReportwallettbMutation) Street() (r string, exists bool) {
	v := m._Street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "Street" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldStreet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "Street" field.
func (m *ReportwallettbMutation) ClearStreet() {
	m._Street = nil
	m.clearedFields[reportwallettb.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "Street" field was cleared in this mutation.
func (m *ReportwallettbMutation) StreetCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "Street" field.
func (m *ReportwallettbMutation) ResetStreet() {
	m._Street = nil
	delete(m.clearedFields, reportwallettb.FieldStreet)
}

// SetDistrict sets the "District" field.
func (m *ReportwallettbMutation) SetDistrict(s string) {
	m._District = &s
}

// District returns the value of the "District" field in the mutation.
func (m *ReportwallettbMutation) District() (r string, exists bool) {
	v := m._District
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "District" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "District" field.
func (m *ReportwallettbMutation) ClearDistrict() {
	m._District = nil
	m.clearedFields[reportwallettb.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "District" field was cleared in this mutation.
func (m *ReportwallettbMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "District" field.
func (m *ReportwallettbMutation) ResetDistrict() {
	m._District = nil
	delete(m.clearedFields, reportwallettb.FieldDistrict)
}

// SetSubDistrict sets the "SubDistrict" field.
func (m *ReportwallettbMutation) SetSubDistrict(s string) {
	m._SubDistrict = &s
}

// SubDistrict returns the value of the "SubDistrict" field in the mutation.
func (m *ReportwallettbMutation) SubDistrict() (r string, exists bool) {
	v := m._SubDistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrict returns the old "SubDistrict" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldSubDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrict: %w", err)
	}
	return oldValue.SubDistrict, nil
}

// ClearSubDistrict clears the value of the "SubDistrict" field.
func (m *ReportwallettbMutation) ClearSubDistrict() {
	m._SubDistrict = nil
	m.clearedFields[reportwallettb.FieldSubDistrict] = struct{}{}
}

// SubDistrictCleared returns if the "SubDistrict" field was cleared in this mutation.
func (m *ReportwallettbMutation) SubDistrictCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldSubDistrict]
	return ok
}

// ResetSubDistrict resets all changes to the "SubDistrict" field.
func (m *ReportwallettbMutation) ResetSubDistrict() {
	m._SubDistrict = nil
	delete(m.clearedFields, reportwallettb.FieldSubDistrict)
}

// SetProvince sets the "Province" field.
func (m *ReportwallettbMutation) SetProvince(s string) {
	m._Province = &s
}

// Province returns the value of the "Province" field in the mutation.
func (m *ReportwallettbMutation) Province() (r string, exists bool) {
	v := m._Province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "Province" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldProvince(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "Province" field.
func (m *ReportwallettbMutation) ClearProvince() {
	m._Province = nil
	m.clearedFields[reportwallettb.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "Province" field was cleared in this mutation.
func (m *ReportwallettbMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "Province" field.
func (m *ReportwallettbMutation) ResetProvince() {
	m._Province = nil
	delete(m.clearedFields, reportwallettb.FieldProvince)
}

// SetPostalCode sets the "PostalCode" field.
func (m *ReportwallettbMutation) SetPostalCode(s string) {
	m._PostalCode = &s
}

// PostalCode returns the value of the "PostalCode" field in the mutation.
func (m *ReportwallettbMutation) PostalCode() (r string, exists bool) {
	v := m._PostalCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "PostalCode" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "PostalCode" field.
func (m *ReportwallettbMutation) ClearPostalCode() {
	m._PostalCode = nil
	m.clearedFields[reportwallettb.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "PostalCode" field was cleared in this mutation.
func (m *ReportwallettbMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "PostalCode" field.
func (m *ReportwallettbMutation) ResetPostalCode() {
	m._PostalCode = nil
	delete(m.clearedFields, reportwallettb.FieldPostalCode)
}

// SetIsKYC sets the "isKYC" field.
func (m *ReportwallettbMutation) SetIsKYC(s string) {
	m.isKYC = &s
}

// IsKYC returns the value of the "isKYC" field in the mutation.
func (m *ReportwallettbMutation) IsKYC() (r string, exists bool) {
	v := m.isKYC
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKYC returns the old "isKYC" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldIsKYC(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsKYC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsKYC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKYC: %w", err)
	}
	return oldValue.IsKYC, nil
}

// ClearIsKYC clears the value of the "isKYC" field.
func (m *ReportwallettbMutation) ClearIsKYC() {
	m.isKYC = nil
	m.clearedFields[reportwallettb.FieldIsKYC] = struct{}{}
}

// IsKYCCleared returns if the "isKYC" field was cleared in this mutation.
func (m *ReportwallettbMutation) IsKYCCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldIsKYC]
	return ok
}

// ResetIsKYC resets all changes to the "isKYC" field.
func (m *ReportwallettbMutation) ResetIsKYC() {
	m.isKYC = nil
	delete(m.clearedFields, reportwallettb.FieldIsKYC)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *ReportwallettbMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *ReportwallettbMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Reportwallettb entity.
// If the Reportwallettb object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReportwallettbMutation) OldUpdateDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *ReportwallettbMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[reportwallettb.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *ReportwallettbMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[reportwallettb.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *ReportwallettbMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, reportwallettb.FieldUpdateDate)
}

// Op returns the operation name.
func (m *ReportwallettbMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Reportwallettb).
func (m *ReportwallettbMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReportwallettbMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.walletid != nil {
		fields = append(fields, reportwallettb.FieldWalletid)
	}
	if m._WalletTypeName != nil {
		fields = append(fields, reportwallettb.FieldWalletTypeName)
	}
	if m._WalletPhoneno != nil {
		fields = append(fields, reportwallettb.FieldWalletPhoneno)
	}
	if m._WalletName != nil {
		fields = append(fields, reportwallettb.FieldWalletName)
	}
	if m._CitizenId != nil {
		fields = append(fields, reportwallettb.FieldCitizenId)
	}
	if m._Status != nil {
		fields = append(fields, reportwallettb.FieldStatus)
	}
	if m._RegisterDate != nil {
		fields = append(fields, reportwallettb.FieldRegisterDate)
	}
	if m._GroupUser != nil {
		fields = append(fields, reportwallettb.FieldGroupUser)
	}
	if m._UserAgent != nil {
		fields = append(fields, reportwallettb.FieldUserAgent)
	}
	if m._KYC_Date != nil {
		fields = append(fields, reportwallettb.FieldKYCDate)
	}
	if m._ATMCard != nil {
		fields = append(fields, reportwallettb.FieldATMCard)
	}
	if m._AccountNo != nil {
		fields = append(fields, reportwallettb.FieldAccountNo)
	}
	if m._AddressDetail != nil {
		fields = append(fields, reportwallettb.FieldAddressDetail)
	}
	if m._Street != nil {
		fields = append(fields, reportwallettb.FieldStreet)
	}
	if m._District != nil {
		fields = append(fields, reportwallettb.FieldDistrict)
	}
	if m._SubDistrict != nil {
		fields = append(fields, reportwallettb.FieldSubDistrict)
	}
	if m._Province != nil {
		fields = append(fields, reportwallettb.FieldProvince)
	}
	if m._PostalCode != nil {
		fields = append(fields, reportwallettb.FieldPostalCode)
	}
	if m.isKYC != nil {
		fields = append(fields, reportwallettb.FieldIsKYC)
	}
	if m._UpdateDate != nil {
		fields = append(fields, reportwallettb.FieldUpdateDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReportwallettbMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case reportwallettb.FieldWalletid:
		return m.Walletid()
	case reportwallettb.FieldWalletTypeName:
		return m.WalletTypeName()
	case reportwallettb.FieldWalletPhoneno:
		return m.WalletPhoneno()
	case reportwallettb.FieldWalletName:
		return m.WalletName()
	case reportwallettb.FieldCitizenId:
		return m.CitizenId()
	case reportwallettb.FieldStatus:
		return m.Status()
	case reportwallettb.FieldRegisterDate:
		return m.RegisterDate()
	case reportwallettb.FieldGroupUser:
		return m.GroupUser()
	case reportwallettb.FieldUserAgent:
		return m.UserAgent()
	case reportwallettb.FieldKYCDate:
		return m.KYCDate()
	case reportwallettb.FieldATMCard:
		return m.ATMCard()
	case reportwallettb.FieldAccountNo:
		return m.AccountNo()
	case reportwallettb.FieldAddressDetail:
		return m.AddressDetail()
	case reportwallettb.FieldStreet:
		return m.Street()
	case reportwallettb.FieldDistrict:
		return m.District()
	case reportwallettb.FieldSubDistrict:
		return m.SubDistrict()
	case reportwallettb.FieldProvince:
		return m.Province()
	case reportwallettb.FieldPostalCode:
		return m.PostalCode()
	case reportwallettb.FieldIsKYC:
		return m.IsKYC()
	case reportwallettb.FieldUpdateDate:
		return m.UpdateDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReportwallettbMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case reportwallettb.FieldWalletid:
		return m.OldWalletid(ctx)
	case reportwallettb.FieldWalletTypeName:
		return m.OldWalletTypeName(ctx)
	case reportwallettb.FieldWalletPhoneno:
		return m.OldWalletPhoneno(ctx)
	case reportwallettb.FieldWalletName:
		return m.OldWalletName(ctx)
	case reportwallettb.FieldCitizenId:
		return m.OldCitizenId(ctx)
	case reportwallettb.FieldStatus:
		return m.OldStatus(ctx)
	case reportwallettb.FieldRegisterDate:
		return m.OldRegisterDate(ctx)
	case reportwallettb.FieldGroupUser:
		return m.OldGroupUser(ctx)
	case reportwallettb.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case reportwallettb.FieldKYCDate:
		return m.OldKYCDate(ctx)
	case reportwallettb.FieldATMCard:
		return m.OldATMCard(ctx)
	case reportwallettb.FieldAccountNo:
		return m.OldAccountNo(ctx)
	case reportwallettb.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case reportwallettb.FieldStreet:
		return m.OldStreet(ctx)
	case reportwallettb.FieldDistrict:
		return m.OldDistrict(ctx)
	case reportwallettb.FieldSubDistrict:
		return m.OldSubDistrict(ctx)
	case reportwallettb.FieldProvince:
		return m.OldProvince(ctx)
	case reportwallettb.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case reportwallettb.FieldIsKYC:
		return m.OldIsKYC(ctx)
	case reportwallettb.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	}
	return nil, fmt.Errorf("unknown Reportwallettb field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportwallettbMutation) SetField(name string, value ent.Value) error {
	switch name {
	case reportwallettb.FieldWalletid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletid(v)
		return nil
	case reportwallettb.FieldWalletTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletTypeName(v)
		return nil
	case reportwallettb.FieldWalletPhoneno:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletPhoneno(v)
		return nil
	case reportwallettb.FieldWalletName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletName(v)
		return nil
	case reportwallettb.FieldCitizenId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenId(v)
		return nil
	case reportwallettb.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case reportwallettb.FieldRegisterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterDate(v)
		return nil
	case reportwallettb.FieldGroupUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupUser(v)
		return nil
	case reportwallettb.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case reportwallettb.FieldKYCDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	case reportwallettb.FieldATMCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetATMCard(v)
		return nil
	case reportwallettb.FieldAccountNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNo(v)
		return nil
	case reportwallettb.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case reportwallettb.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case reportwallettb.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case reportwallettb.FieldSubDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrict(v)
		return nil
	case reportwallettb.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case reportwallettb.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case reportwallettb.FieldIsKYC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKYC(v)
		return nil
	case reportwallettb.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	}
	return fmt.Errorf("unknown Reportwallettb field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReportwallettbMutation) AddedFields() []string {
	var fields []string
	if m.add_GroupUser != nil {
		fields = append(fields, reportwallettb.FieldGroupUser)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReportwallettbMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case reportwallettb.FieldGroupUser:
		return m.AddedGroupUser()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReportwallettbMutation) AddField(name string, value ent.Value) error {
	switch name {
	case reportwallettb.FieldGroupUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupUser(v)
		return nil
	}
	return fmt.Errorf("unknown Reportwallettb numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReportwallettbMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(reportwallettb.FieldWalletTypeName) {
		fields = append(fields, reportwallettb.FieldWalletTypeName)
	}
	if m.FieldCleared(reportwallettb.FieldWalletPhoneno) {
		fields = append(fields, reportwallettb.FieldWalletPhoneno)
	}
	if m.FieldCleared(reportwallettb.FieldWalletName) {
		fields = append(fields, reportwallettb.FieldWalletName)
	}
	if m.FieldCleared(reportwallettb.FieldCitizenId) {
		fields = append(fields, reportwallettb.FieldCitizenId)
	}
	if m.FieldCleared(reportwallettb.FieldStatus) {
		fields = append(fields, reportwallettb.FieldStatus)
	}
	if m.FieldCleared(reportwallettb.FieldRegisterDate) {
		fields = append(fields, reportwallettb.FieldRegisterDate)
	}
	if m.FieldCleared(reportwallettb.FieldGroupUser) {
		fields = append(fields, reportwallettb.FieldGroupUser)
	}
	if m.FieldCleared(reportwallettb.FieldUserAgent) {
		fields = append(fields, reportwallettb.FieldUserAgent)
	}
	if m.FieldCleared(reportwallettb.FieldKYCDate) {
		fields = append(fields, reportwallettb.FieldKYCDate)
	}
	if m.FieldCleared(reportwallettb.FieldATMCard) {
		fields = append(fields, reportwallettb.FieldATMCard)
	}
	if m.FieldCleared(reportwallettb.FieldAccountNo) {
		fields = append(fields, reportwallettb.FieldAccountNo)
	}
	if m.FieldCleared(reportwallettb.FieldAddressDetail) {
		fields = append(fields, reportwallettb.FieldAddressDetail)
	}
	if m.FieldCleared(reportwallettb.FieldStreet) {
		fields = append(fields, reportwallettb.FieldStreet)
	}
	if m.FieldCleared(reportwallettb.FieldDistrict) {
		fields = append(fields, reportwallettb.FieldDistrict)
	}
	if m.FieldCleared(reportwallettb.FieldSubDistrict) {
		fields = append(fields, reportwallettb.FieldSubDistrict)
	}
	if m.FieldCleared(reportwallettb.FieldProvince) {
		fields = append(fields, reportwallettb.FieldProvince)
	}
	if m.FieldCleared(reportwallettb.FieldPostalCode) {
		fields = append(fields, reportwallettb.FieldPostalCode)
	}
	if m.FieldCleared(reportwallettb.FieldIsKYC) {
		fields = append(fields, reportwallettb.FieldIsKYC)
	}
	if m.FieldCleared(reportwallettb.FieldUpdateDate) {
		fields = append(fields, reportwallettb.FieldUpdateDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReportwallettbMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReportwallettbMutation) ClearField(name string) error {
	switch name {
	case reportwallettb.FieldWalletTypeName:
		m.ClearWalletTypeName()
		return nil
	case reportwallettb.FieldWalletPhoneno:
		m.ClearWalletPhoneno()
		return nil
	case reportwallettb.FieldWalletName:
		m.ClearWalletName()
		return nil
	case reportwallettb.FieldCitizenId:
		m.ClearCitizenId()
		return nil
	case reportwallettb.FieldStatus:
		m.ClearStatus()
		return nil
	case reportwallettb.FieldRegisterDate:
		m.ClearRegisterDate()
		return nil
	case reportwallettb.FieldGroupUser:
		m.ClearGroupUser()
		return nil
	case reportwallettb.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case reportwallettb.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	case reportwallettb.FieldATMCard:
		m.ClearATMCard()
		return nil
	case reportwallettb.FieldAccountNo:
		m.ClearAccountNo()
		return nil
	case reportwallettb.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case reportwallettb.FieldStreet:
		m.ClearStreet()
		return nil
	case reportwallettb.FieldDistrict:
		m.ClearDistrict()
		return nil
	case reportwallettb.FieldSubDistrict:
		m.ClearSubDistrict()
		return nil
	case reportwallettb.FieldProvince:
		m.ClearProvince()
		return nil
	case reportwallettb.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case reportwallettb.FieldIsKYC:
		m.ClearIsKYC()
		return nil
	case reportwallettb.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Reportwallettb nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReportwallettbMutation) ResetField(name string) error {
	switch name {
	case reportwallettb.FieldWalletid:
		m.ResetWalletid()
		return nil
	case reportwallettb.FieldWalletTypeName:
		m.ResetWalletTypeName()
		return nil
	case reportwallettb.FieldWalletPhoneno:
		m.ResetWalletPhoneno()
		return nil
	case reportwallettb.FieldWalletName:
		m.ResetWalletName()
		return nil
	case reportwallettb.FieldCitizenId:
		m.ResetCitizenId()
		return nil
	case reportwallettb.FieldStatus:
		m.ResetStatus()
		return nil
	case reportwallettb.FieldRegisterDate:
		m.ResetRegisterDate()
		return nil
	case reportwallettb.FieldGroupUser:
		m.ResetGroupUser()
		return nil
	case reportwallettb.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case reportwallettb.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	case reportwallettb.FieldATMCard:
		m.ResetATMCard()
		return nil
	case reportwallettb.FieldAccountNo:
		m.ResetAccountNo()
		return nil
	case reportwallettb.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case reportwallettb.FieldStreet:
		m.ResetStreet()
		return nil
	case reportwallettb.FieldDistrict:
		m.ResetDistrict()
		return nil
	case reportwallettb.FieldSubDistrict:
		m.ResetSubDistrict()
		return nil
	case reportwallettb.FieldProvince:
		m.ResetProvince()
		return nil
	case reportwallettb.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case reportwallettb.FieldIsKYC:
		m.ResetIsKYC()
		return nil
	case reportwallettb.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	}
	return fmt.Errorf("unknown Reportwallettb field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReportwallettbMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReportwallettbMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReportwallettbMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReportwallettbMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReportwallettbMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReportwallettbMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReportwallettbMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Reportwallettb unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReportwallettbMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Reportwallettb edge %s", name)
}

// StatementEndingBalancMutation represents an operation that mutates the StatementEndingBalanc nodes in the graph.
type StatementEndingBalancMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	_Statement_Balance    *float64
	add_Statement_Balance *float64
	_Statement_Date       *time.Time
	clearedFields         map[string]struct{}
	bank                  *int
	clearedbank           bool
	done                  bool
	oldValue              func(context.Context) (*StatementEndingBalanc, error)
	predicates            []predicate.StatementEndingBalanc
}

var _ ent.Mutation = (*StatementEndingBalancMutation)(nil)

// statementendingbalancOption allows management of the mutation configuration using functional options.
type statementendingbalancOption func(*StatementEndingBalancMutation)

// newStatementEndingBalancMutation creates new mutation for the StatementEndingBalanc entity.
func newStatementEndingBalancMutation(c config, op Op, opts ...statementendingbalancOption) *StatementEndingBalancMutation {
	m := &StatementEndingBalancMutation{
		config:        c,
		op:            op,
		typ:           TypeStatementEndingBalanc,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatementEndingBalancID sets the ID field of the mutation.
func withStatementEndingBalancID(id int) statementendingbalancOption {
	return func(m *StatementEndingBalancMutation) {
		var (
			err   error
			once  sync.Once
			value *StatementEndingBalanc
		)
		m.oldValue = func(ctx context.Context) (*StatementEndingBalanc, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StatementEndingBalanc.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatementEndingBalanc sets the old StatementEndingBalanc of the mutation.
func withStatementEndingBalanc(node *StatementEndingBalanc) statementendingbalancOption {
	return func(m *StatementEndingBalancMutation) {
		m.oldValue = func(context.Context) (*StatementEndingBalanc, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatementEndingBalancMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatementEndingBalancMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StatementEndingBalanc entities.
func (m *StatementEndingBalancMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *StatementEndingBalancMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatementBalance sets the "Statement_Balance" field.
func (m *StatementEndingBalancMutation) SetStatementBalance(f float64) {
	m._Statement_Balance = &f
	m.add_Statement_Balance = nil
}

// StatementBalance returns the value of the "Statement_Balance" field in the mutation.
func (m *StatementEndingBalancMutation) StatementBalance() (r float64, exists bool) {
	v := m._Statement_Balance
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementBalance returns the old "Statement_Balance" field's value of the StatementEndingBalanc entity.
// If the StatementEndingBalanc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementEndingBalancMutation) OldStatementBalance(ctx context.Context) (v *float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatementBalance is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatementBalance requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementBalance: %w", err)
	}
	return oldValue.StatementBalance, nil
}

// AddStatementBalance adds f to the "Statement_Balance" field.
func (m *StatementEndingBalancMutation) AddStatementBalance(f float64) {
	if m.add_Statement_Balance != nil {
		*m.add_Statement_Balance += f
	} else {
		m.add_Statement_Balance = &f
	}
}

// AddedStatementBalance returns the value that was added to the "Statement_Balance" field in this mutation.
func (m *StatementEndingBalancMutation) AddedStatementBalance() (r float64, exists bool) {
	v := m.add_Statement_Balance
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatementBalance clears the value of the "Statement_Balance" field.
func (m *StatementEndingBalancMutation) ClearStatementBalance() {
	m._Statement_Balance = nil
	m.add_Statement_Balance = nil
	m.clearedFields[statementendingbalanc.FieldStatementBalance] = struct{}{}
}

// StatementBalanceCleared returns if the "Statement_Balance" field was cleared in this mutation.
func (m *StatementEndingBalancMutation) StatementBalanceCleared() bool {
	_, ok := m.clearedFields[statementendingbalanc.FieldStatementBalance]
	return ok
}

// ResetStatementBalance resets all changes to the "Statement_Balance" field.
func (m *StatementEndingBalancMutation) ResetStatementBalance() {
	m._Statement_Balance = nil
	m.add_Statement_Balance = nil
	delete(m.clearedFields, statementendingbalanc.FieldStatementBalance)
}

// SetStatementDate sets the "Statement_Date" field.
func (m *StatementEndingBalancMutation) SetStatementDate(t time.Time) {
	m._Statement_Date = &t
}

// StatementDate returns the value of the "Statement_Date" field in the mutation.
func (m *StatementEndingBalancMutation) StatementDate() (r time.Time, exists bool) {
	v := m._Statement_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldStatementDate returns the old "Statement_Date" field's value of the StatementEndingBalanc entity.
// If the StatementEndingBalanc object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StatementEndingBalancMutation) OldStatementDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatementDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatementDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatementDate: %w", err)
	}
	return oldValue.StatementDate, nil
}

// ClearStatementDate clears the value of the "Statement_Date" field.
func (m *StatementEndingBalancMutation) ClearStatementDate() {
	m._Statement_Date = nil
	m.clearedFields[statementendingbalanc.FieldStatementDate] = struct{}{}
}

// StatementDateCleared returns if the "Statement_Date" field was cleared in this mutation.
func (m *StatementEndingBalancMutation) StatementDateCleared() bool {
	_, ok := m.clearedFields[statementendingbalanc.FieldStatementDate]
	return ok
}

// ResetStatementDate resets all changes to the "Statement_Date" field.
func (m *StatementEndingBalancMutation) ResetStatementDate() {
	m._Statement_Date = nil
	delete(m.clearedFields, statementendingbalanc.FieldStatementDate)
}

// SetBankID sets the "bank" edge to the Bankdetail entity by id.
func (m *StatementEndingBalancMutation) SetBankID(id int) {
	m.bank = &id
}

// ClearBank clears the "bank" edge to the Bankdetail entity.
func (m *StatementEndingBalancMutation) ClearBank() {
	m.clearedbank = true
}

// BankCleared returns if the "bank" edge to the Bankdetail entity was cleared.
func (m *StatementEndingBalancMutation) BankCleared() bool {
	return m.clearedbank
}

// BankID returns the "bank" edge ID in the mutation.
func (m *StatementEndingBalancMutation) BankID() (id int, exists bool) {
	if m.bank != nil {
		return *m.bank, true
	}
	return
}

// BankIDs returns the "bank" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BankID instead. It exists only for internal usage by the builders.
func (m *StatementEndingBalancMutation) BankIDs() (ids []int) {
	if id := m.bank; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBank resets all changes to the "bank" edge.
func (m *StatementEndingBalancMutation) ResetBank() {
	m.bank = nil
	m.clearedbank = false
}

// Op returns the operation name.
func (m *StatementEndingBalancMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StatementEndingBalanc).
func (m *StatementEndingBalancMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StatementEndingBalancMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Statement_Balance != nil {
		fields = append(fields, statementendingbalanc.FieldStatementBalance)
	}
	if m._Statement_Date != nil {
		fields = append(fields, statementendingbalanc.FieldStatementDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StatementEndingBalancMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		return m.StatementBalance()
	case statementendingbalanc.FieldStatementDate:
		return m.StatementDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StatementEndingBalancMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		return m.OldStatementBalance(ctx)
	case statementendingbalanc.FieldStatementDate:
		return m.OldStatementDate(ctx)
	}
	return nil, fmt.Errorf("unknown StatementEndingBalanc field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementEndingBalancMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementBalance(v)
		return nil
	case statementendingbalanc.FieldStatementDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatementDate(v)
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StatementEndingBalancMutation) AddedFields() []string {
	var fields []string
	if m.add_Statement_Balance != nil {
		fields = append(fields, statementendingbalanc.FieldStatementBalance)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StatementEndingBalancMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		return m.AddedStatementBalance()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StatementEndingBalancMutation) AddField(name string, value ent.Value) error {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatementBalance(v)
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StatementEndingBalancMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(statementendingbalanc.FieldStatementBalance) {
		fields = append(fields, statementendingbalanc.FieldStatementBalance)
	}
	if m.FieldCleared(statementendingbalanc.FieldStatementDate) {
		fields = append(fields, statementendingbalanc.FieldStatementDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StatementEndingBalancMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatementEndingBalancMutation) ClearField(name string) error {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		m.ClearStatementBalance()
		return nil
	case statementendingbalanc.FieldStatementDate:
		m.ClearStatementDate()
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StatementEndingBalancMutation) ResetField(name string) error {
	switch name {
	case statementendingbalanc.FieldStatementBalance:
		m.ResetStatementBalance()
		return nil
	case statementendingbalanc.FieldStatementDate:
		m.ResetStatementDate()
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StatementEndingBalancMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.bank != nil {
		edges = append(edges, statementendingbalanc.EdgeBank)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StatementEndingBalancMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statementendingbalanc.EdgeBank:
		if id := m.bank; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StatementEndingBalancMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StatementEndingBalancMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StatementEndingBalancMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedbank {
		edges = append(edges, statementendingbalanc.EdgeBank)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StatementEndingBalancMutation) EdgeCleared(name string) bool {
	switch name {
	case statementendingbalanc.EdgeBank:
		return m.clearedbank
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StatementEndingBalancMutation) ClearEdge(name string) error {
	switch name {
	case statementendingbalanc.EdgeBank:
		m.ClearBank()
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StatementEndingBalancMutation) ResetEdge(name string) error {
	switch name {
	case statementendingbalanc.EdgeBank:
		m.ResetBank()
		return nil
	}
	return fmt.Errorf("unknown StatementEndingBalanc edge %s", name)
}

// TransactionfactorMutation represents an operation that mutates the Transactionfactor nodes in the graph.
type TransactionfactorMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_TransactionFactorName    *string
	_TransactionType          *string
	_PaymentChannel           *string
	_PaymentType              *string
	_NumDay                   *int
	add_NumDay                *int
	_Date                     *string
	_UpdateDate               *time.Time
	_StatusApprove            *string
	clearedFields             map[string]struct{}
	transactionhistory        map[int]struct{}
	removedtransactionhistory map[int]struct{}
	clearedtransactionhistory bool
	done                      bool
	oldValue                  func(context.Context) (*Transactionfactor, error)
	predicates                []predicate.Transactionfactor
}

var _ ent.Mutation = (*TransactionfactorMutation)(nil)

// transactionfactorOption allows management of the mutation configuration using functional options.
type transactionfactorOption func(*TransactionfactorMutation)

// newTransactionfactorMutation creates new mutation for the Transactionfactor entity.
func newTransactionfactorMutation(c config, op Op, opts ...transactionfactorOption) *TransactionfactorMutation {
	m := &TransactionfactorMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionfactor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionfactorID sets the ID field of the mutation.
func withTransactionfactorID(id int) transactionfactorOption {
	return func(m *TransactionfactorMutation) {
		var (
			err   error
			once  sync.Once
			value *Transactionfactor
		)
		m.oldValue = func(ctx context.Context) (*Transactionfactor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transactionfactor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionfactor sets the old Transactionfactor of the mutation.
func withTransactionfactor(node *Transactionfactor) transactionfactorOption {
	return func(m *TransactionfactorMutation) {
		m.oldValue = func(context.Context) (*Transactionfactor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionfactorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionfactorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transactionfactor entities.
func (m *TransactionfactorMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TransactionfactorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTransactionFactorName sets the "TransactionFactorName" field.
func (m *TransactionfactorMutation) SetTransactionFactorName(s string) {
	m._TransactionFactorName = &s
}

// TransactionFactorName returns the value of the "TransactionFactorName" field in the mutation.
func (m *TransactionfactorMutation) TransactionFactorName() (r string, exists bool) {
	v := m._TransactionFactorName
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionFactorName returns the old "TransactionFactorName" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldTransactionFactorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionFactorName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionFactorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionFactorName: %w", err)
	}
	return oldValue.TransactionFactorName, nil
}

// ClearTransactionFactorName clears the value of the "TransactionFactorName" field.
func (m *TransactionfactorMutation) ClearTransactionFactorName() {
	m._TransactionFactorName = nil
	m.clearedFields[transactionfactor.FieldTransactionFactorName] = struct{}{}
}

// TransactionFactorNameCleared returns if the "TransactionFactorName" field was cleared in this mutation.
func (m *TransactionfactorMutation) TransactionFactorNameCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldTransactionFactorName]
	return ok
}

// ResetTransactionFactorName resets all changes to the "TransactionFactorName" field.
func (m *TransactionfactorMutation) ResetTransactionFactorName() {
	m._TransactionFactorName = nil
	delete(m.clearedFields, transactionfactor.FieldTransactionFactorName)
}

// SetTransactionType sets the "TransactionType" field.
func (m *TransactionfactorMutation) SetTransactionType(s string) {
	m._TransactionType = &s
}

// TransactionType returns the value of the "TransactionType" field in the mutation.
func (m *TransactionfactorMutation) TransactionType() (r string, exists bool) {
	v := m._TransactionType
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionType returns the old "TransactionType" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldTransactionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionType: %w", err)
	}
	return oldValue.TransactionType, nil
}

// ClearTransactionType clears the value of the "TransactionType" field.
func (m *TransactionfactorMutation) ClearTransactionType() {
	m._TransactionType = nil
	m.clearedFields[transactionfactor.FieldTransactionType] = struct{}{}
}

// TransactionTypeCleared returns if the "TransactionType" field was cleared in this mutation.
func (m *TransactionfactorMutation) TransactionTypeCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldTransactionType]
	return ok
}

// ResetTransactionType resets all changes to the "TransactionType" field.
func (m *TransactionfactorMutation) ResetTransactionType() {
	m._TransactionType = nil
	delete(m.clearedFields, transactionfactor.FieldTransactionType)
}

// SetPaymentChannel sets the "PaymentChannel" field.
func (m *TransactionfactorMutation) SetPaymentChannel(s string) {
	m._PaymentChannel = &s
}

// PaymentChannel returns the value of the "PaymentChannel" field in the mutation.
func (m *TransactionfactorMutation) PaymentChannel() (r string, exists bool) {
	v := m._PaymentChannel
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentChannel returns the old "PaymentChannel" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldPaymentChannel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentChannel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentChannel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentChannel: %w", err)
	}
	return oldValue.PaymentChannel, nil
}

// ClearPaymentChannel clears the value of the "PaymentChannel" field.
func (m *TransactionfactorMutation) ClearPaymentChannel() {
	m._PaymentChannel = nil
	m.clearedFields[transactionfactor.FieldPaymentChannel] = struct{}{}
}

// PaymentChannelCleared returns if the "PaymentChannel" field was cleared in this mutation.
func (m *TransactionfactorMutation) PaymentChannelCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldPaymentChannel]
	return ok
}

// ResetPaymentChannel resets all changes to the "PaymentChannel" field.
func (m *TransactionfactorMutation) ResetPaymentChannel() {
	m._PaymentChannel = nil
	delete(m.clearedFields, transactionfactor.FieldPaymentChannel)
}

// SetPaymentType sets the "PaymentType" field.
func (m *TransactionfactorMutation) SetPaymentType(s string) {
	m._PaymentType = &s
}

// PaymentType returns the value of the "PaymentType" field in the mutation.
func (m *TransactionfactorMutation) PaymentType() (r string, exists bool) {
	v := m._PaymentType
	if v == nil {
		return
	}
	return *v, true
}

// OldPaymentType returns the old "PaymentType" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldPaymentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPaymentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPaymentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaymentType: %w", err)
	}
	return oldValue.PaymentType, nil
}

// ClearPaymentType clears the value of the "PaymentType" field.
func (m *TransactionfactorMutation) ClearPaymentType() {
	m._PaymentType = nil
	m.clearedFields[transactionfactor.FieldPaymentType] = struct{}{}
}

// PaymentTypeCleared returns if the "PaymentType" field was cleared in this mutation.
func (m *TransactionfactorMutation) PaymentTypeCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldPaymentType]
	return ok
}

// ResetPaymentType resets all changes to the "PaymentType" field.
func (m *TransactionfactorMutation) ResetPaymentType() {
	m._PaymentType = nil
	delete(m.clearedFields, transactionfactor.FieldPaymentType)
}

// SetNumDay sets the "NumDay" field.
func (m *TransactionfactorMutation) SetNumDay(i int) {
	m._NumDay = &i
	m.add_NumDay = nil
}

// NumDay returns the value of the "NumDay" field in the mutation.
func (m *TransactionfactorMutation) NumDay() (r int, exists bool) {
	v := m._NumDay
	if v == nil {
		return
	}
	return *v, true
}

// OldNumDay returns the old "NumDay" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldNumDay(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNumDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNumDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumDay: %w", err)
	}
	return oldValue.NumDay, nil
}

// AddNumDay adds i to the "NumDay" field.
func (m *TransactionfactorMutation) AddNumDay(i int) {
	if m.add_NumDay != nil {
		*m.add_NumDay += i
	} else {
		m.add_NumDay = &i
	}
}

// AddedNumDay returns the value that was added to the "NumDay" field in this mutation.
func (m *TransactionfactorMutation) AddedNumDay() (r int, exists bool) {
	v := m.add_NumDay
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumDay clears the value of the "NumDay" field.
func (m *TransactionfactorMutation) ClearNumDay() {
	m._NumDay = nil
	m.add_NumDay = nil
	m.clearedFields[transactionfactor.FieldNumDay] = struct{}{}
}

// NumDayCleared returns if the "NumDay" field was cleared in this mutation.
func (m *TransactionfactorMutation) NumDayCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldNumDay]
	return ok
}

// ResetNumDay resets all changes to the "NumDay" field.
func (m *TransactionfactorMutation) ResetNumDay() {
	m._NumDay = nil
	m.add_NumDay = nil
	delete(m.clearedFields, transactionfactor.FieldNumDay)
}

// SetDate sets the "Date" field.
func (m *TransactionfactorMutation) SetDate(s string) {
	m._Date = &s
}

// Date returns the value of the "Date" field in the mutation.
func (m *TransactionfactorMutation) Date() (r string, exists bool) {
	v := m._Date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "Date" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ClearDate clears the value of the "Date" field.
func (m *TransactionfactorMutation) ClearDate() {
	m._Date = nil
	m.clearedFields[transactionfactor.FieldDate] = struct{}{}
}

// DateCleared returns if the "Date" field was cleared in this mutation.
func (m *TransactionfactorMutation) DateCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldDate]
	return ok
}

// ResetDate resets all changes to the "Date" field.
func (m *TransactionfactorMutation) ResetDate() {
	m._Date = nil
	delete(m.clearedFields, transactionfactor.FieldDate)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *TransactionfactorMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *TransactionfactorMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldUpdateDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *TransactionfactorMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[transactionfactor.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *TransactionfactorMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *TransactionfactorMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, transactionfactor.FieldUpdateDate)
}

// SetStatusApprove sets the "StatusApprove" field.
func (m *TransactionfactorMutation) SetStatusApprove(s string) {
	m._StatusApprove = &s
}

// StatusApprove returns the value of the "StatusApprove" field in the mutation.
func (m *TransactionfactorMutation) StatusApprove() (r string, exists bool) {
	v := m._StatusApprove
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusApprove returns the old "StatusApprove" field's value of the Transactionfactor entity.
// If the Transactionfactor object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorMutation) OldStatusApprove(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusApprove is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusApprove requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusApprove: %w", err)
	}
	return oldValue.StatusApprove, nil
}

// ClearStatusApprove clears the value of the "StatusApprove" field.
func (m *TransactionfactorMutation) ClearStatusApprove() {
	m._StatusApprove = nil
	m.clearedFields[transactionfactor.FieldStatusApprove] = struct{}{}
}

// StatusApproveCleared returns if the "StatusApprove" field was cleared in this mutation.
func (m *TransactionfactorMutation) StatusApproveCleared() bool {
	_, ok := m.clearedFields[transactionfactor.FieldStatusApprove]
	return ok
}

// ResetStatusApprove resets all changes to the "StatusApprove" field.
func (m *TransactionfactorMutation) ResetStatusApprove() {
	m._StatusApprove = nil
	delete(m.clearedFields, transactionfactor.FieldStatusApprove)
}

// AddTransactionhistoryIDs adds the "transactionhistory" edge to the Transactionfactorhistory entity by ids.
func (m *TransactionfactorMutation) AddTransactionhistoryIDs(ids ...int) {
	if m.transactionhistory == nil {
		m.transactionhistory = make(map[int]struct{})
	}
	for i := range ids {
		m.transactionhistory[ids[i]] = struct{}{}
	}
}

// ClearTransactionhistory clears the "transactionhistory" edge to the Transactionfactorhistory entity.
func (m *TransactionfactorMutation) ClearTransactionhistory() {
	m.clearedtransactionhistory = true
}

// TransactionhistoryCleared returns if the "transactionhistory" edge to the Transactionfactorhistory entity was cleared.
func (m *TransactionfactorMutation) TransactionhistoryCleared() bool {
	return m.clearedtransactionhistory
}

// RemoveTransactionhistoryIDs removes the "transactionhistory" edge to the Transactionfactorhistory entity by IDs.
func (m *TransactionfactorMutation) RemoveTransactionhistoryIDs(ids ...int) {
	if m.removedtransactionhistory == nil {
		m.removedtransactionhistory = make(map[int]struct{})
	}
	for i := range ids {
		m.removedtransactionhistory[ids[i]] = struct{}{}
	}
}

// RemovedTransactionhistory returns the removed IDs of the "transactionhistory" edge to the Transactionfactorhistory entity.
func (m *TransactionfactorMutation) RemovedTransactionhistoryIDs() (ids []int) {
	for id := range m.removedtransactionhistory {
		ids = append(ids, id)
	}
	return
}

// TransactionhistoryIDs returns the "transactionhistory" edge IDs in the mutation.
func (m *TransactionfactorMutation) TransactionhistoryIDs() (ids []int) {
	for id := range m.transactionhistory {
		ids = append(ids, id)
	}
	return
}

// ResetTransactionhistory resets all changes to the "transactionhistory" edge.
func (m *TransactionfactorMutation) ResetTransactionhistory() {
	m.transactionhistory = nil
	m.clearedtransactionhistory = false
	m.removedtransactionhistory = nil
}

// Op returns the operation name.
func (m *TransactionfactorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transactionfactor).
func (m *TransactionfactorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionfactorMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m._TransactionFactorName != nil {
		fields = append(fields, transactionfactor.FieldTransactionFactorName)
	}
	if m._TransactionType != nil {
		fields = append(fields, transactionfactor.FieldTransactionType)
	}
	if m._PaymentChannel != nil {
		fields = append(fields, transactionfactor.FieldPaymentChannel)
	}
	if m._PaymentType != nil {
		fields = append(fields, transactionfactor.FieldPaymentType)
	}
	if m._NumDay != nil {
		fields = append(fields, transactionfactor.FieldNumDay)
	}
	if m._Date != nil {
		fields = append(fields, transactionfactor.FieldDate)
	}
	if m._UpdateDate != nil {
		fields = append(fields, transactionfactor.FieldUpdateDate)
	}
	if m._StatusApprove != nil {
		fields = append(fields, transactionfactor.FieldStatusApprove)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionfactorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionfactor.FieldTransactionFactorName:
		return m.TransactionFactorName()
	case transactionfactor.FieldTransactionType:
		return m.TransactionType()
	case transactionfactor.FieldPaymentChannel:
		return m.PaymentChannel()
	case transactionfactor.FieldPaymentType:
		return m.PaymentType()
	case transactionfactor.FieldNumDay:
		return m.NumDay()
	case transactionfactor.FieldDate:
		return m.Date()
	case transactionfactor.FieldUpdateDate:
		return m.UpdateDate()
	case transactionfactor.FieldStatusApprove:
		return m.StatusApprove()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionfactorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionfactor.FieldTransactionFactorName:
		return m.OldTransactionFactorName(ctx)
	case transactionfactor.FieldTransactionType:
		return m.OldTransactionType(ctx)
	case transactionfactor.FieldPaymentChannel:
		return m.OldPaymentChannel(ctx)
	case transactionfactor.FieldPaymentType:
		return m.OldPaymentType(ctx)
	case transactionfactor.FieldNumDay:
		return m.OldNumDay(ctx)
	case transactionfactor.FieldDate:
		return m.OldDate(ctx)
	case transactionfactor.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	case transactionfactor.FieldStatusApprove:
		return m.OldStatusApprove(ctx)
	}
	return nil, fmt.Errorf("unknown Transactionfactor field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionfactor.FieldTransactionFactorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionFactorName(v)
		return nil
	case transactionfactor.FieldTransactionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionType(v)
		return nil
	case transactionfactor.FieldPaymentChannel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentChannel(v)
		return nil
	case transactionfactor.FieldPaymentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentType(v)
		return nil
	case transactionfactor.FieldNumDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumDay(v)
		return nil
	case transactionfactor.FieldDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case transactionfactor.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	case transactionfactor.FieldStatusApprove:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusApprove(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactor field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionfactorMutation) AddedFields() []string {
	var fields []string
	if m.add_NumDay != nil {
		fields = append(fields, transactionfactor.FieldNumDay)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionfactorMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionfactor.FieldNumDay:
		return m.AddedNumDay()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactorMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionfactor.FieldNumDay:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumDay(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionfactorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionfactor.FieldTransactionFactorName) {
		fields = append(fields, transactionfactor.FieldTransactionFactorName)
	}
	if m.FieldCleared(transactionfactor.FieldTransactionType) {
		fields = append(fields, transactionfactor.FieldTransactionType)
	}
	if m.FieldCleared(transactionfactor.FieldPaymentChannel) {
		fields = append(fields, transactionfactor.FieldPaymentChannel)
	}
	if m.FieldCleared(transactionfactor.FieldPaymentType) {
		fields = append(fields, transactionfactor.FieldPaymentType)
	}
	if m.FieldCleared(transactionfactor.FieldNumDay) {
		fields = append(fields, transactionfactor.FieldNumDay)
	}
	if m.FieldCleared(transactionfactor.FieldDate) {
		fields = append(fields, transactionfactor.FieldDate)
	}
	if m.FieldCleared(transactionfactor.FieldUpdateDate) {
		fields = append(fields, transactionfactor.FieldUpdateDate)
	}
	if m.FieldCleared(transactionfactor.FieldStatusApprove) {
		fields = append(fields, transactionfactor.FieldStatusApprove)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionfactorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionfactorMutation) ClearField(name string) error {
	switch name {
	case transactionfactor.FieldTransactionFactorName:
		m.ClearTransactionFactorName()
		return nil
	case transactionfactor.FieldTransactionType:
		m.ClearTransactionType()
		return nil
	case transactionfactor.FieldPaymentChannel:
		m.ClearPaymentChannel()
		return nil
	case transactionfactor.FieldPaymentType:
		m.ClearPaymentType()
		return nil
	case transactionfactor.FieldNumDay:
		m.ClearNumDay()
		return nil
	case transactionfactor.FieldDate:
		m.ClearDate()
		return nil
	case transactionfactor.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	case transactionfactor.FieldStatusApprove:
		m.ClearStatusApprove()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactor nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionfactorMutation) ResetField(name string) error {
	switch name {
	case transactionfactor.FieldTransactionFactorName:
		m.ResetTransactionFactorName()
		return nil
	case transactionfactor.FieldTransactionType:
		m.ResetTransactionType()
		return nil
	case transactionfactor.FieldPaymentChannel:
		m.ResetPaymentChannel()
		return nil
	case transactionfactor.FieldPaymentType:
		m.ResetPaymentType()
		return nil
	case transactionfactor.FieldNumDay:
		m.ResetNumDay()
		return nil
	case transactionfactor.FieldDate:
		m.ResetDate()
		return nil
	case transactionfactor.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	case transactionfactor.FieldStatusApprove:
		m.ResetStatusApprove()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionfactorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.transactionhistory != nil {
		edges = append(edges, transactionfactor.EdgeTransactionhistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionfactorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionfactor.EdgeTransactionhistory:
		ids := make([]ent.Value, 0, len(m.transactionhistory))
		for id := range m.transactionhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionfactorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtransactionhistory != nil {
		edges = append(edges, transactionfactor.EdgeTransactionhistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionfactorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case transactionfactor.EdgeTransactionhistory:
		ids := make([]ent.Value, 0, len(m.removedtransactionhistory))
		for id := range m.removedtransactionhistory {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionfactorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtransactionhistory {
		edges = append(edges, transactionfactor.EdgeTransactionhistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionfactorMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionfactor.EdgeTransactionhistory:
		return m.clearedtransactionhistory
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionfactorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Transactionfactor unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionfactorMutation) ResetEdge(name string) error {
	switch name {
	case transactionfactor.EdgeTransactionhistory:
		m.ResetTransactionhistory()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactor edge %s", name)
}

// TransactionfactorhistoryMutation represents an operation that mutates the Transactionfactorhistory nodes in the graph.
type TransactionfactorhistoryMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	_WalletID                 *string
	_RankTransactionFactor    *int
	add_RankTransactionFactor *int
	_DateCalRank              *time.Time
	clearedFields             map[string]struct{}
	_Transactionfactor        *int
	cleared_Transactionfactor bool
	done                      bool
	oldValue                  func(context.Context) (*Transactionfactorhistory, error)
	predicates                []predicate.Transactionfactorhistory
}

var _ ent.Mutation = (*TransactionfactorhistoryMutation)(nil)

// transactionfactorhistoryOption allows management of the mutation configuration using functional options.
type transactionfactorhistoryOption func(*TransactionfactorhistoryMutation)

// newTransactionfactorhistoryMutation creates new mutation for the Transactionfactorhistory entity.
func newTransactionfactorhistoryMutation(c config, op Op, opts ...transactionfactorhistoryOption) *TransactionfactorhistoryMutation {
	m := &TransactionfactorhistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionfactorhistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionfactorhistoryID sets the ID field of the mutation.
func withTransactionfactorhistoryID(id int) transactionfactorhistoryOption {
	return func(m *TransactionfactorhistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Transactionfactorhistory
		)
		m.oldValue = func(ctx context.Context) (*Transactionfactorhistory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transactionfactorhistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionfactorhistory sets the old Transactionfactorhistory of the mutation.
func withTransactionfactorhistory(node *Transactionfactorhistory) transactionfactorhistoryOption {
	return func(m *TransactionfactorhistoryMutation) {
		m.oldValue = func(context.Context) (*Transactionfactorhistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionfactorhistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionfactorhistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transactionfactorhistory entities.
func (m *TransactionfactorhistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TransactionfactorhistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletID sets the "WalletID" field.
func (m *TransactionfactorhistoryMutation) SetWalletID(s string) {
	m._WalletID = &s
}

// WalletID returns the value of the "WalletID" field in the mutation.
func (m *TransactionfactorhistoryMutation) WalletID() (r string, exists bool) {
	v := m._WalletID
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletID returns the old "WalletID" field's value of the Transactionfactorhistory entity.
// If the Transactionfactorhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorhistoryMutation) OldWalletID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletID: %w", err)
	}
	return oldValue.WalletID, nil
}

// ResetWalletID resets all changes to the "WalletID" field.
func (m *TransactionfactorhistoryMutation) ResetWalletID() {
	m._WalletID = nil
}

// SetRankTransactionFactor sets the "RankTransactionFactor" field.
func (m *TransactionfactorhistoryMutation) SetRankTransactionFactor(i int) {
	m._RankTransactionFactor = &i
	m.add_RankTransactionFactor = nil
}

// RankTransactionFactor returns the value of the "RankTransactionFactor" field in the mutation.
func (m *TransactionfactorhistoryMutation) RankTransactionFactor() (r int, exists bool) {
	v := m._RankTransactionFactor
	if v == nil {
		return
	}
	return *v, true
}

// OldRankTransactionFactor returns the old "RankTransactionFactor" field's value of the Transactionfactorhistory entity.
// If the Transactionfactorhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorhistoryMutation) OldRankTransactionFactor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankTransactionFactor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankTransactionFactor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankTransactionFactor: %w", err)
	}
	return oldValue.RankTransactionFactor, nil
}

// AddRankTransactionFactor adds i to the "RankTransactionFactor" field.
func (m *TransactionfactorhistoryMutation) AddRankTransactionFactor(i int) {
	if m.add_RankTransactionFactor != nil {
		*m.add_RankTransactionFactor += i
	} else {
		m.add_RankTransactionFactor = &i
	}
}

// AddedRankTransactionFactor returns the value that was added to the "RankTransactionFactor" field in this mutation.
func (m *TransactionfactorhistoryMutation) AddedRankTransactionFactor() (r int, exists bool) {
	v := m.add_RankTransactionFactor
	if v == nil {
		return
	}
	return *v, true
}

// ClearRankTransactionFactor clears the value of the "RankTransactionFactor" field.
func (m *TransactionfactorhistoryMutation) ClearRankTransactionFactor() {
	m._RankTransactionFactor = nil
	m.add_RankTransactionFactor = nil
	m.clearedFields[transactionfactorhistory.FieldRankTransactionFactor] = struct{}{}
}

// RankTransactionFactorCleared returns if the "RankTransactionFactor" field was cleared in this mutation.
func (m *TransactionfactorhistoryMutation) RankTransactionFactorCleared() bool {
	_, ok := m.clearedFields[transactionfactorhistory.FieldRankTransactionFactor]
	return ok
}

// ResetRankTransactionFactor resets all changes to the "RankTransactionFactor" field.
func (m *TransactionfactorhistoryMutation) ResetRankTransactionFactor() {
	m._RankTransactionFactor = nil
	m.add_RankTransactionFactor = nil
	delete(m.clearedFields, transactionfactorhistory.FieldRankTransactionFactor)
}

// SetDateCalRank sets the "DateCalRank" field.
func (m *TransactionfactorhistoryMutation) SetDateCalRank(t time.Time) {
	m._DateCalRank = &t
}

// DateCalRank returns the value of the "DateCalRank" field in the mutation.
func (m *TransactionfactorhistoryMutation) DateCalRank() (r time.Time, exists bool) {
	v := m._DateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldDateCalRank returns the old "DateCalRank" field's value of the Transactionfactorhistory entity.
// If the Transactionfactorhistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactorhistoryMutation) OldDateCalRank(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateCalRank: %w", err)
	}
	return oldValue.DateCalRank, nil
}

// ClearDateCalRank clears the value of the "DateCalRank" field.
func (m *TransactionfactorhistoryMutation) ClearDateCalRank() {
	m._DateCalRank = nil
	m.clearedFields[transactionfactorhistory.FieldDateCalRank] = struct{}{}
}

// DateCalRankCleared returns if the "DateCalRank" field was cleared in this mutation.
func (m *TransactionfactorhistoryMutation) DateCalRankCleared() bool {
	_, ok := m.clearedFields[transactionfactorhistory.FieldDateCalRank]
	return ok
}

// ResetDateCalRank resets all changes to the "DateCalRank" field.
func (m *TransactionfactorhistoryMutation) ResetDateCalRank() {
	m._DateCalRank = nil
	delete(m.clearedFields, transactionfactorhistory.FieldDateCalRank)
}

// SetTransactionfactorID sets the "Transactionfactor" edge to the Transactionfactor entity by id.
func (m *TransactionfactorhistoryMutation) SetTransactionfactorID(id int) {
	m._Transactionfactor = &id
}

// ClearTransactionfactor clears the "Transactionfactor" edge to the Transactionfactor entity.
func (m *TransactionfactorhistoryMutation) ClearTransactionfactor() {
	m.cleared_Transactionfactor = true
}

// TransactionfactorCleared returns if the "Transactionfactor" edge to the Transactionfactor entity was cleared.
func (m *TransactionfactorhistoryMutation) TransactionfactorCleared() bool {
	return m.cleared_Transactionfactor
}

// TransactionfactorID returns the "Transactionfactor" edge ID in the mutation.
func (m *TransactionfactorhistoryMutation) TransactionfactorID() (id int, exists bool) {
	if m._Transactionfactor != nil {
		return *m._Transactionfactor, true
	}
	return
}

// TransactionfactorIDs returns the "Transactionfactor" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TransactionfactorID instead. It exists only for internal usage by the builders.
func (m *TransactionfactorhistoryMutation) TransactionfactorIDs() (ids []int) {
	if id := m._Transactionfactor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTransactionfactor resets all changes to the "Transactionfactor" edge.
func (m *TransactionfactorhistoryMutation) ResetTransactionfactor() {
	m._Transactionfactor = nil
	m.cleared_Transactionfactor = false
}

// Op returns the operation name.
func (m *TransactionfactorhistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transactionfactorhistory).
func (m *TransactionfactorhistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionfactorhistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._WalletID != nil {
		fields = append(fields, transactionfactorhistory.FieldWalletID)
	}
	if m._RankTransactionFactor != nil {
		fields = append(fields, transactionfactorhistory.FieldRankTransactionFactor)
	}
	if m._DateCalRank != nil {
		fields = append(fields, transactionfactorhistory.FieldDateCalRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionfactorhistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionfactorhistory.FieldWalletID:
		return m.WalletID()
	case transactionfactorhistory.FieldRankTransactionFactor:
		return m.RankTransactionFactor()
	case transactionfactorhistory.FieldDateCalRank:
		return m.DateCalRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionfactorhistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionfactorhistory.FieldWalletID:
		return m.OldWalletID(ctx)
	case transactionfactorhistory.FieldRankTransactionFactor:
		return m.OldRankTransactionFactor(ctx)
	case transactionfactorhistory.FieldDateCalRank:
		return m.OldDateCalRank(ctx)
	}
	return nil, fmt.Errorf("unknown Transactionfactorhistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactorhistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionfactorhistory.FieldWalletID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletID(v)
		return nil
	case transactionfactorhistory.FieldRankTransactionFactor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankTransactionFactor(v)
		return nil
	case transactionfactorhistory.FieldDateCalRank:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateCalRank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionfactorhistoryMutation) AddedFields() []string {
	var fields []string
	if m.add_RankTransactionFactor != nil {
		fields = append(fields, transactionfactorhistory.FieldRankTransactionFactor)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionfactorhistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionfactorhistory.FieldRankTransactionFactor:
		return m.AddedRankTransactionFactor()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactorhistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionfactorhistory.FieldRankTransactionFactor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRankTransactionFactor(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionfactorhistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionfactorhistory.FieldRankTransactionFactor) {
		fields = append(fields, transactionfactorhistory.FieldRankTransactionFactor)
	}
	if m.FieldCleared(transactionfactorhistory.FieldDateCalRank) {
		fields = append(fields, transactionfactorhistory.FieldDateCalRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionfactorhistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionfactorhistoryMutation) ClearField(name string) error {
	switch name {
	case transactionfactorhistory.FieldRankTransactionFactor:
		m.ClearRankTransactionFactor()
		return nil
	case transactionfactorhistory.FieldDateCalRank:
		m.ClearDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionfactorhistoryMutation) ResetField(name string) error {
	switch name {
	case transactionfactorhistory.FieldWalletID:
		m.ResetWalletID()
		return nil
	case transactionfactorhistory.FieldRankTransactionFactor:
		m.ResetRankTransactionFactor()
		return nil
	case transactionfactorhistory.FieldDateCalRank:
		m.ResetDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionfactorhistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Transactionfactor != nil {
		edges = append(edges, transactionfactorhistory.EdgeTransactionfactor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionfactorhistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case transactionfactorhistory.EdgeTransactionfactor:
		if id := m._Transactionfactor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionfactorhistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionfactorhistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionfactorhistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleared_Transactionfactor {
		edges = append(edges, transactionfactorhistory.EdgeTransactionfactor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionfactorhistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case transactionfactorhistory.EdgeTransactionfactor:
		return m.cleared_Transactionfactor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionfactorhistoryMutation) ClearEdge(name string) error {
	switch name {
	case transactionfactorhistory.EdgeTransactionfactor:
		m.ClearTransactionfactor()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionfactorhistoryMutation) ResetEdge(name string) error {
	switch name {
	case transactionfactorhistory.EdgeTransactionfactor:
		m.ResetTransactionfactor()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactorhistory edge %s", name)
}

// TransactionfactoritemMutation represents an operation that mutates the Transactionfactoritem nodes in the graph.
type TransactionfactoritemMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_TransactionFactorID    *int
	add_TransactionFactorID *int
	_Min                    *float64
	add_Min                 *float64
	_Max                    *float64
	add_Max                 *float64
	_Rank                   *int
	add_Rank                *int
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*Transactionfactoritem, error)
	predicates              []predicate.Transactionfactoritem
}

var _ ent.Mutation = (*TransactionfactoritemMutation)(nil)

// transactionfactoritemOption allows management of the mutation configuration using functional options.
type transactionfactoritemOption func(*TransactionfactoritemMutation)

// newTransactionfactoritemMutation creates new mutation for the Transactionfactoritem entity.
func newTransactionfactoritemMutation(c config, op Op, opts ...transactionfactoritemOption) *TransactionfactoritemMutation {
	m := &TransactionfactoritemMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionfactoritem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionfactoritemID sets the ID field of the mutation.
func withTransactionfactoritemID(id int) transactionfactoritemOption {
	return func(m *TransactionfactoritemMutation) {
		var (
			err   error
			once  sync.Once
			value *Transactionfactoritem
		)
		m.oldValue = func(ctx context.Context) (*Transactionfactoritem, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transactionfactoritem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionfactoritem sets the old Transactionfactoritem of the mutation.
func withTransactionfactoritem(node *Transactionfactoritem) transactionfactoritemOption {
	return func(m *TransactionfactoritemMutation) {
		m.oldValue = func(context.Context) (*Transactionfactoritem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionfactoritemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionfactoritemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transactionfactoritem entities.
func (m *TransactionfactoritemMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TransactionfactoritemMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTransactionFactorID sets the "TransactionFactorID" field.
func (m *TransactionfactoritemMutation) SetTransactionFactorID(i int) {
	m._TransactionFactorID = &i
	m.add_TransactionFactorID = nil
}

// TransactionFactorID returns the value of the "TransactionFactorID" field in the mutation.
func (m *TransactionfactoritemMutation) TransactionFactorID() (r int, exists bool) {
	v := m._TransactionFactorID
	if v == nil {
		return
	}
	return *v, true
}

// OldTransactionFactorID returns the old "TransactionFactorID" field's value of the Transactionfactoritem entity.
// If the Transactionfactoritem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemMutation) OldTransactionFactorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTransactionFactorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTransactionFactorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTransactionFactorID: %w", err)
	}
	return oldValue.TransactionFactorID, nil
}

// AddTransactionFactorID adds i to the "TransactionFactorID" field.
func (m *TransactionfactoritemMutation) AddTransactionFactorID(i int) {
	if m.add_TransactionFactorID != nil {
		*m.add_TransactionFactorID += i
	} else {
		m.add_TransactionFactorID = &i
	}
}

// AddedTransactionFactorID returns the value that was added to the "TransactionFactorID" field in this mutation.
func (m *TransactionfactoritemMutation) AddedTransactionFactorID() (r int, exists bool) {
	v := m.add_TransactionFactorID
	if v == nil {
		return
	}
	return *v, true
}

// ClearTransactionFactorID clears the value of the "TransactionFactorID" field.
func (m *TransactionfactoritemMutation) ClearTransactionFactorID() {
	m._TransactionFactorID = nil
	m.add_TransactionFactorID = nil
	m.clearedFields[transactionfactoritem.FieldTransactionFactorID] = struct{}{}
}

// TransactionFactorIDCleared returns if the "TransactionFactorID" field was cleared in this mutation.
func (m *TransactionfactoritemMutation) TransactionFactorIDCleared() bool {
	_, ok := m.clearedFields[transactionfactoritem.FieldTransactionFactorID]
	return ok
}

// ResetTransactionFactorID resets all changes to the "TransactionFactorID" field.
func (m *TransactionfactoritemMutation) ResetTransactionFactorID() {
	m._TransactionFactorID = nil
	m.add_TransactionFactorID = nil
	delete(m.clearedFields, transactionfactoritem.FieldTransactionFactorID)
}

// SetMin sets the "Min" field.
func (m *TransactionfactoritemMutation) SetMin(f float64) {
	m._Min = &f
	m.add_Min = nil
}

// Min returns the value of the "Min" field in the mutation.
func (m *TransactionfactoritemMutation) Min() (r float64, exists bool) {
	v := m._Min
	if v == nil {
		return
	}
	return *v, true
}

// OldMin returns the old "Min" field's value of the Transactionfactoritem entity.
// If the Transactionfactoritem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemMutation) OldMin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMin: %w", err)
	}
	return oldValue.Min, nil
}

// AddMin adds f to the "Min" field.
func (m *TransactionfactoritemMutation) AddMin(f float64) {
	if m.add_Min != nil {
		*m.add_Min += f
	} else {
		m.add_Min = &f
	}
}

// AddedMin returns the value that was added to the "Min" field in this mutation.
func (m *TransactionfactoritemMutation) AddedMin() (r float64, exists bool) {
	v := m.add_Min
	if v == nil {
		return
	}
	return *v, true
}

// ClearMin clears the value of the "Min" field.
func (m *TransactionfactoritemMutation) ClearMin() {
	m._Min = nil
	m.add_Min = nil
	m.clearedFields[transactionfactoritem.FieldMin] = struct{}{}
}

// MinCleared returns if the "Min" field was cleared in this mutation.
func (m *TransactionfactoritemMutation) MinCleared() bool {
	_, ok := m.clearedFields[transactionfactoritem.FieldMin]
	return ok
}

// ResetMin resets all changes to the "Min" field.
func (m *TransactionfactoritemMutation) ResetMin() {
	m._Min = nil
	m.add_Min = nil
	delete(m.clearedFields, transactionfactoritem.FieldMin)
}

// SetMax sets the "Max" field.
func (m *TransactionfactoritemMutation) SetMax(f float64) {
	m._Max = &f
	m.add_Max = nil
}

// Max returns the value of the "Max" field in the mutation.
func (m *TransactionfactoritemMutation) Max() (r float64, exists bool) {
	v := m._Max
	if v == nil {
		return
	}
	return *v, true
}

// OldMax returns the old "Max" field's value of the Transactionfactoritem entity.
// If the Transactionfactoritem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemMutation) OldMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMax: %w", err)
	}
	return oldValue.Max, nil
}

// AddMax adds f to the "Max" field.
func (m *TransactionfactoritemMutation) AddMax(f float64) {
	if m.add_Max != nil {
		*m.add_Max += f
	} else {
		m.add_Max = &f
	}
}

// AddedMax returns the value that was added to the "Max" field in this mutation.
func (m *TransactionfactoritemMutation) AddedMax() (r float64, exists bool) {
	v := m.add_Max
	if v == nil {
		return
	}
	return *v, true
}

// ClearMax clears the value of the "Max" field.
func (m *TransactionfactoritemMutation) ClearMax() {
	m._Max = nil
	m.add_Max = nil
	m.clearedFields[transactionfactoritem.FieldMax] = struct{}{}
}

// MaxCleared returns if the "Max" field was cleared in this mutation.
func (m *TransactionfactoritemMutation) MaxCleared() bool {
	_, ok := m.clearedFields[transactionfactoritem.FieldMax]
	return ok
}

// ResetMax resets all changes to the "Max" field.
func (m *TransactionfactoritemMutation) ResetMax() {
	m._Max = nil
	m.add_Max = nil
	delete(m.clearedFields, transactionfactoritem.FieldMax)
}

// SetRank sets the "Rank" field.
func (m *TransactionfactoritemMutation) SetRank(i int) {
	m._Rank = &i
	m.add_Rank = nil
}

// Rank returns the value of the "Rank" field in the mutation.
func (m *TransactionfactoritemMutation) Rank() (r int, exists bool) {
	v := m._Rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "Rank" field's value of the Transactionfactoritem entity.
// If the Transactionfactoritem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "Rank" field.
func (m *TransactionfactoritemMutation) AddRank(i int) {
	if m.add_Rank != nil {
		*m.add_Rank += i
	} else {
		m.add_Rank = &i
	}
}

// AddedRank returns the value that was added to the "Rank" field in this mutation.
func (m *TransactionfactoritemMutation) AddedRank() (r int, exists bool) {
	v := m.add_Rank
	if v == nil {
		return
	}
	return *v, true
}

// ClearRank clears the value of the "Rank" field.
func (m *TransactionfactoritemMutation) ClearRank() {
	m._Rank = nil
	m.add_Rank = nil
	m.clearedFields[transactionfactoritem.FieldRank] = struct{}{}
}

// RankCleared returns if the "Rank" field was cleared in this mutation.
func (m *TransactionfactoritemMutation) RankCleared() bool {
	_, ok := m.clearedFields[transactionfactoritem.FieldRank]
	return ok
}

// ResetRank resets all changes to the "Rank" field.
func (m *TransactionfactoritemMutation) ResetRank() {
	m._Rank = nil
	m.add_Rank = nil
	delete(m.clearedFields, transactionfactoritem.FieldRank)
}

// Op returns the operation name.
func (m *TransactionfactoritemMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transactionfactoritem).
func (m *TransactionfactoritemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionfactoritemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._TransactionFactorID != nil {
		fields = append(fields, transactionfactoritem.FieldTransactionFactorID)
	}
	if m._Min != nil {
		fields = append(fields, transactionfactoritem.FieldMin)
	}
	if m._Max != nil {
		fields = append(fields, transactionfactoritem.FieldMax)
	}
	if m._Rank != nil {
		fields = append(fields, transactionfactoritem.FieldRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionfactoritemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		return m.TransactionFactorID()
	case transactionfactoritem.FieldMin:
		return m.Min()
	case transactionfactoritem.FieldMax:
		return m.Max()
	case transactionfactoritem.FieldRank:
		return m.Rank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionfactoritemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		return m.OldTransactionFactorID(ctx)
	case transactionfactoritem.FieldMin:
		return m.OldMin(ctx)
	case transactionfactoritem.FieldMax:
		return m.OldMax(ctx)
	case transactionfactoritem.FieldRank:
		return m.OldRank(ctx)
	}
	return nil, fmt.Errorf("unknown Transactionfactoritem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactoritemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTransactionFactorID(v)
		return nil
	case transactionfactoritem.FieldMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMin(v)
		return nil
	case transactionfactoritem.FieldMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMax(v)
		return nil
	case transactionfactoritem.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionfactoritemMutation) AddedFields() []string {
	var fields []string
	if m.add_TransactionFactorID != nil {
		fields = append(fields, transactionfactoritem.FieldTransactionFactorID)
	}
	if m.add_Min != nil {
		fields = append(fields, transactionfactoritem.FieldMin)
	}
	if m.add_Max != nil {
		fields = append(fields, transactionfactoritem.FieldMax)
	}
	if m.add_Rank != nil {
		fields = append(fields, transactionfactoritem.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionfactoritemMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		return m.AddedTransactionFactorID()
	case transactionfactoritem.FieldMin:
		return m.AddedMin()
	case transactionfactoritem.FieldMax:
		return m.AddedMax()
	case transactionfactoritem.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactoritemMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTransactionFactorID(v)
		return nil
	case transactionfactoritem.FieldMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMin(v)
		return nil
	case transactionfactoritem.FieldMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMax(v)
		return nil
	case transactionfactoritem.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionfactoritemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionfactoritem.FieldTransactionFactorID) {
		fields = append(fields, transactionfactoritem.FieldTransactionFactorID)
	}
	if m.FieldCleared(transactionfactoritem.FieldMin) {
		fields = append(fields, transactionfactoritem.FieldMin)
	}
	if m.FieldCleared(transactionfactoritem.FieldMax) {
		fields = append(fields, transactionfactoritem.FieldMax)
	}
	if m.FieldCleared(transactionfactoritem.FieldRank) {
		fields = append(fields, transactionfactoritem.FieldRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionfactoritemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionfactoritemMutation) ClearField(name string) error {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		m.ClearTransactionFactorID()
		return nil
	case transactionfactoritem.FieldMin:
		m.ClearMin()
		return nil
	case transactionfactoritem.FieldMax:
		m.ClearMax()
		return nil
	case transactionfactoritem.FieldRank:
		m.ClearRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionfactoritemMutation) ResetField(name string) error {
	switch name {
	case transactionfactoritem.FieldTransactionFactorID:
		m.ResetTransactionFactorID()
		return nil
	case transactionfactoritem.FieldMin:
		m.ResetMin()
		return nil
	case transactionfactoritem.FieldMax:
		m.ResetMax()
		return nil
	case transactionfactoritem.FieldRank:
		m.ResetRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionfactoritemMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionfactoritemMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionfactoritemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionfactoritemMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionfactoritemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionfactoritemMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionfactoritemMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transactionfactoritem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionfactoritemMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transactionfactoritem edge %s", name)
}

// TransactionfactoritemtmpMutation represents an operation that mutates the Transactionfactoritemtmp nodes in the graph.
type TransactionfactoritemtmpMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_Min          *float64
	add_Min       *float64
	_Max          *float64
	add_Max       *float64
	_Rank         *int
	add_Rank      *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Transactionfactoritemtmp, error)
	predicates    []predicate.Transactionfactoritemtmp
}

var _ ent.Mutation = (*TransactionfactoritemtmpMutation)(nil)

// transactionfactoritemtmpOption allows management of the mutation configuration using functional options.
type transactionfactoritemtmpOption func(*TransactionfactoritemtmpMutation)

// newTransactionfactoritemtmpMutation creates new mutation for the Transactionfactoritemtmp entity.
func newTransactionfactoritemtmpMutation(c config, op Op, opts ...transactionfactoritemtmpOption) *TransactionfactoritemtmpMutation {
	m := &TransactionfactoritemtmpMutation{
		config:        c,
		op:            op,
		typ:           TypeTransactionfactoritemtmp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTransactionfactoritemtmpID sets the ID field of the mutation.
func withTransactionfactoritemtmpID(id int) transactionfactoritemtmpOption {
	return func(m *TransactionfactoritemtmpMutation) {
		var (
			err   error
			once  sync.Once
			value *Transactionfactoritemtmp
		)
		m.oldValue = func(ctx context.Context) (*Transactionfactoritemtmp, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Transactionfactoritemtmp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTransactionfactoritemtmp sets the old Transactionfactoritemtmp of the mutation.
func withTransactionfactoritemtmp(node *Transactionfactoritemtmp) transactionfactoritemtmpOption {
	return func(m *TransactionfactoritemtmpMutation) {
		m.oldValue = func(context.Context) (*Transactionfactoritemtmp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TransactionfactoritemtmpMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TransactionfactoritemtmpMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Transactionfactoritemtmp entities.
func (m *TransactionfactoritemtmpMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *TransactionfactoritemtmpMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMin sets the "Min" field.
func (m *TransactionfactoritemtmpMutation) SetMin(f float64) {
	m._Min = &f
	m.add_Min = nil
}

// Min returns the value of the "Min" field in the mutation.
func (m *TransactionfactoritemtmpMutation) Min() (r float64, exists bool) {
	v := m._Min
	if v == nil {
		return
	}
	return *v, true
}

// OldMin returns the old "Min" field's value of the Transactionfactoritemtmp entity.
// If the Transactionfactoritemtmp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemtmpMutation) OldMin(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMin: %w", err)
	}
	return oldValue.Min, nil
}

// AddMin adds f to the "Min" field.
func (m *TransactionfactoritemtmpMutation) AddMin(f float64) {
	if m.add_Min != nil {
		*m.add_Min += f
	} else {
		m.add_Min = &f
	}
}

// AddedMin returns the value that was added to the "Min" field in this mutation.
func (m *TransactionfactoritemtmpMutation) AddedMin() (r float64, exists bool) {
	v := m.add_Min
	if v == nil {
		return
	}
	return *v, true
}

// ClearMin clears the value of the "Min" field.
func (m *TransactionfactoritemtmpMutation) ClearMin() {
	m._Min = nil
	m.add_Min = nil
	m.clearedFields[transactionfactoritemtmp.FieldMin] = struct{}{}
}

// MinCleared returns if the "Min" field was cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) MinCleared() bool {
	_, ok := m.clearedFields[transactionfactoritemtmp.FieldMin]
	return ok
}

// ResetMin resets all changes to the "Min" field.
func (m *TransactionfactoritemtmpMutation) ResetMin() {
	m._Min = nil
	m.add_Min = nil
	delete(m.clearedFields, transactionfactoritemtmp.FieldMin)
}

// SetMax sets the "Max" field.
func (m *TransactionfactoritemtmpMutation) SetMax(f float64) {
	m._Max = &f
	m.add_Max = nil
}

// Max returns the value of the "Max" field in the mutation.
func (m *TransactionfactoritemtmpMutation) Max() (r float64, exists bool) {
	v := m._Max
	if v == nil {
		return
	}
	return *v, true
}

// OldMax returns the old "Max" field's value of the Transactionfactoritemtmp entity.
// If the Transactionfactoritemtmp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemtmpMutation) OldMax(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMax is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMax requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMax: %w", err)
	}
	return oldValue.Max, nil
}

// AddMax adds f to the "Max" field.
func (m *TransactionfactoritemtmpMutation) AddMax(f float64) {
	if m.add_Max != nil {
		*m.add_Max += f
	} else {
		m.add_Max = &f
	}
}

// AddedMax returns the value that was added to the "Max" field in this mutation.
func (m *TransactionfactoritemtmpMutation) AddedMax() (r float64, exists bool) {
	v := m.add_Max
	if v == nil {
		return
	}
	return *v, true
}

// ClearMax clears the value of the "Max" field.
func (m *TransactionfactoritemtmpMutation) ClearMax() {
	m._Max = nil
	m.add_Max = nil
	m.clearedFields[transactionfactoritemtmp.FieldMax] = struct{}{}
}

// MaxCleared returns if the "Max" field was cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) MaxCleared() bool {
	_, ok := m.clearedFields[transactionfactoritemtmp.FieldMax]
	return ok
}

// ResetMax resets all changes to the "Max" field.
func (m *TransactionfactoritemtmpMutation) ResetMax() {
	m._Max = nil
	m.add_Max = nil
	delete(m.clearedFields, transactionfactoritemtmp.FieldMax)
}

// SetRank sets the "Rank" field.
func (m *TransactionfactoritemtmpMutation) SetRank(i int) {
	m._Rank = &i
	m.add_Rank = nil
}

// Rank returns the value of the "Rank" field in the mutation.
func (m *TransactionfactoritemtmpMutation) Rank() (r int, exists bool) {
	v := m._Rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "Rank" field's value of the Transactionfactoritemtmp entity.
// If the Transactionfactoritemtmp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TransactionfactoritemtmpMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "Rank" field.
func (m *TransactionfactoritemtmpMutation) AddRank(i int) {
	if m.add_Rank != nil {
		*m.add_Rank += i
	} else {
		m.add_Rank = &i
	}
}

// AddedRank returns the value that was added to the "Rank" field in this mutation.
func (m *TransactionfactoritemtmpMutation) AddedRank() (r int, exists bool) {
	v := m.add_Rank
	if v == nil {
		return
	}
	return *v, true
}

// ClearRank clears the value of the "Rank" field.
func (m *TransactionfactoritemtmpMutation) ClearRank() {
	m._Rank = nil
	m.add_Rank = nil
	m.clearedFields[transactionfactoritemtmp.FieldRank] = struct{}{}
}

// RankCleared returns if the "Rank" field was cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) RankCleared() bool {
	_, ok := m.clearedFields[transactionfactoritemtmp.FieldRank]
	return ok
}

// ResetRank resets all changes to the "Rank" field.
func (m *TransactionfactoritemtmpMutation) ResetRank() {
	m._Rank = nil
	m.add_Rank = nil
	delete(m.clearedFields, transactionfactoritemtmp.FieldRank)
}

// Op returns the operation name.
func (m *TransactionfactoritemtmpMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Transactionfactoritemtmp).
func (m *TransactionfactoritemtmpMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TransactionfactoritemtmpMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._Min != nil {
		fields = append(fields, transactionfactoritemtmp.FieldMin)
	}
	if m._Max != nil {
		fields = append(fields, transactionfactoritemtmp.FieldMax)
	}
	if m._Rank != nil {
		fields = append(fields, transactionfactoritemtmp.FieldRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TransactionfactoritemtmpMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		return m.Min()
	case transactionfactoritemtmp.FieldMax:
		return m.Max()
	case transactionfactoritemtmp.FieldRank:
		return m.Rank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TransactionfactoritemtmpMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		return m.OldMin(ctx)
	case transactionfactoritemtmp.FieldMax:
		return m.OldMax(ctx)
	case transactionfactoritemtmp.FieldRank:
		return m.OldRank(ctx)
	}
	return nil, fmt.Errorf("unknown Transactionfactoritemtmp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactoritemtmpMutation) SetField(name string, value ent.Value) error {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMin(v)
		return nil
	case transactionfactoritemtmp.FieldMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMax(v)
		return nil
	case transactionfactoritemtmp.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritemtmp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TransactionfactoritemtmpMutation) AddedFields() []string {
	var fields []string
	if m.add_Min != nil {
		fields = append(fields, transactionfactoritemtmp.FieldMin)
	}
	if m.add_Max != nil {
		fields = append(fields, transactionfactoritemtmp.FieldMax)
	}
	if m.add_Rank != nil {
		fields = append(fields, transactionfactoritemtmp.FieldRank)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TransactionfactoritemtmpMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		return m.AddedMin()
	case transactionfactoritemtmp.FieldMax:
		return m.AddedMax()
	case transactionfactoritemtmp.FieldRank:
		return m.AddedRank()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TransactionfactoritemtmpMutation) AddField(name string, value ent.Value) error {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMin(v)
		return nil
	case transactionfactoritemtmp.FieldMax:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMax(v)
		return nil
	case transactionfactoritemtmp.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritemtmp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TransactionfactoritemtmpMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(transactionfactoritemtmp.FieldMin) {
		fields = append(fields, transactionfactoritemtmp.FieldMin)
	}
	if m.FieldCleared(transactionfactoritemtmp.FieldMax) {
		fields = append(fields, transactionfactoritemtmp.FieldMax)
	}
	if m.FieldCleared(transactionfactoritemtmp.FieldRank) {
		fields = append(fields, transactionfactoritemtmp.FieldRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TransactionfactoritemtmpMutation) ClearField(name string) error {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		m.ClearMin()
		return nil
	case transactionfactoritemtmp.FieldMax:
		m.ClearMax()
		return nil
	case transactionfactoritemtmp.FieldRank:
		m.ClearRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritemtmp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TransactionfactoritemtmpMutation) ResetField(name string) error {
	switch name {
	case transactionfactoritemtmp.FieldMin:
		m.ResetMin()
		return nil
	case transactionfactoritemtmp.FieldMax:
		m.ResetMax()
		return nil
	case transactionfactoritemtmp.FieldRank:
		m.ResetRank()
		return nil
	}
	return fmt.Errorf("unknown Transactionfactoritemtmp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TransactionfactoritemtmpMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TransactionfactoritemtmpMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TransactionfactoritemtmpMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TransactionfactoritemtmpMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TransactionfactoritemtmpMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TransactionfactoritemtmpMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Transactionfactoritemtmp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TransactionfactoritemtmpMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Transactionfactoritemtmp edge %s", name)
}

// UserprofileMutation represents an operation that mutates the Userprofile nodes in the graph.
type UserprofileMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_UserId          *string
	_Firstname       *string
	_Lastname        *string
	_PhoneNo         *string
	_Email           *string
	_CitizenId       *string
	_BirthDate       *string
	_Gender          *string
	_BusinessAddress *string
	_OccupationId    *int
	add_OccupationId *int
	_FileimportID    *int
	add_FileimportID *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Userprofile, error)
	predicates       []predicate.Userprofile
}

var _ ent.Mutation = (*UserprofileMutation)(nil)

// userprofileOption allows management of the mutation configuration using functional options.
type userprofileOption func(*UserprofileMutation)

// newUserprofileMutation creates new mutation for the Userprofile entity.
func newUserprofileMutation(c config, op Op, opts ...userprofileOption) *UserprofileMutation {
	m := &UserprofileMutation{
		config:        c,
		op:            op,
		typ:           TypeUserprofile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserprofileID sets the ID field of the mutation.
func withUserprofileID(id int) userprofileOption {
	return func(m *UserprofileMutation) {
		var (
			err   error
			once  sync.Once
			value *Userprofile
		)
		m.oldValue = func(ctx context.Context) (*Userprofile, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Userprofile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserprofile sets the old Userprofile of the mutation.
func withUserprofile(node *Userprofile) userprofileOption {
	return func(m *UserprofileMutation) {
		m.oldValue = func(context.Context) (*Userprofile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserprofileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserprofileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Userprofile entities.
func (m *UserprofileMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserprofileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserId sets the "UserId" field.
func (m *UserprofileMutation) SetUserId(s string) {
	m._UserId = &s
}

// UserId returns the value of the "UserId" field in the mutation.
func (m *UserprofileMutation) UserId() (r string, exists bool) {
	v := m._UserId
	if v == nil {
		return
	}
	return *v, true
}

// OldUserId returns the old "UserId" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldUserId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserId: %w", err)
	}
	return oldValue.UserId, nil
}

// ClearUserId clears the value of the "UserId" field.
func (m *UserprofileMutation) ClearUserId() {
	m._UserId = nil
	m.clearedFields[userprofile.FieldUserId] = struct{}{}
}

// UserIdCleared returns if the "UserId" field was cleared in this mutation.
func (m *UserprofileMutation) UserIdCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldUserId]
	return ok
}

// ResetUserId resets all changes to the "UserId" field.
func (m *UserprofileMutation) ResetUserId() {
	m._UserId = nil
	delete(m.clearedFields, userprofile.FieldUserId)
}

// SetFirstname sets the "Firstname" field.
func (m *UserprofileMutation) SetFirstname(s string) {
	m._Firstname = &s
}

// Firstname returns the value of the "Firstname" field in the mutation.
func (m *UserprofileMutation) Firstname() (r string, exists bool) {
	v := m._Firstname
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstname returns the old "Firstname" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldFirstname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFirstname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFirstname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstname: %w", err)
	}
	return oldValue.Firstname, nil
}

// ClearFirstname clears the value of the "Firstname" field.
func (m *UserprofileMutation) ClearFirstname() {
	m._Firstname = nil
	m.clearedFields[userprofile.FieldFirstname] = struct{}{}
}

// FirstnameCleared returns if the "Firstname" field was cleared in this mutation.
func (m *UserprofileMutation) FirstnameCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldFirstname]
	return ok
}

// ResetFirstname resets all changes to the "Firstname" field.
func (m *UserprofileMutation) ResetFirstname() {
	m._Firstname = nil
	delete(m.clearedFields, userprofile.FieldFirstname)
}

// SetLastname sets the "Lastname" field.
func (m *UserprofileMutation) SetLastname(s string) {
	m._Lastname = &s
}

// Lastname returns the value of the "Lastname" field in the mutation.
func (m *UserprofileMutation) Lastname() (r string, exists bool) {
	v := m._Lastname
	if v == nil {
		return
	}
	return *v, true
}

// OldLastname returns the old "Lastname" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldLastname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLastname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLastname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastname: %w", err)
	}
	return oldValue.Lastname, nil
}

// ClearLastname clears the value of the "Lastname" field.
func (m *UserprofileMutation) ClearLastname() {
	m._Lastname = nil
	m.clearedFields[userprofile.FieldLastname] = struct{}{}
}

// LastnameCleared returns if the "Lastname" field was cleared in this mutation.
func (m *UserprofileMutation) LastnameCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldLastname]
	return ok
}

// ResetLastname resets all changes to the "Lastname" field.
func (m *UserprofileMutation) ResetLastname() {
	m._Lastname = nil
	delete(m.clearedFields, userprofile.FieldLastname)
}

// SetPhoneNo sets the "PhoneNo" field.
func (m *UserprofileMutation) SetPhoneNo(s string) {
	m._PhoneNo = &s
}

// PhoneNo returns the value of the "PhoneNo" field in the mutation.
func (m *UserprofileMutation) PhoneNo() (r string, exists bool) {
	v := m._PhoneNo
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNo returns the old "PhoneNo" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldPhoneNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPhoneNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPhoneNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNo: %w", err)
	}
	return oldValue.PhoneNo, nil
}

// ClearPhoneNo clears the value of the "PhoneNo" field.
func (m *UserprofileMutation) ClearPhoneNo() {
	m._PhoneNo = nil
	m.clearedFields[userprofile.FieldPhoneNo] = struct{}{}
}

// PhoneNoCleared returns if the "PhoneNo" field was cleared in this mutation.
func (m *UserprofileMutation) PhoneNoCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldPhoneNo]
	return ok
}

// ResetPhoneNo resets all changes to the "PhoneNo" field.
func (m *UserprofileMutation) ResetPhoneNo() {
	m._PhoneNo = nil
	delete(m.clearedFields, userprofile.FieldPhoneNo)
}

// SetEmail sets the "Email" field.
func (m *UserprofileMutation) SetEmail(s string) {
	m._Email = &s
}

// Email returns the value of the "Email" field in the mutation.
func (m *UserprofileMutation) Email() (r string, exists bool) {
	v := m._Email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "Email" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "Email" field.
func (m *UserprofileMutation) ClearEmail() {
	m._Email = nil
	m.clearedFields[userprofile.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "Email" field was cleared in this mutation.
func (m *UserprofileMutation) EmailCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "Email" field.
func (m *UserprofileMutation) ResetEmail() {
	m._Email = nil
	delete(m.clearedFields, userprofile.FieldEmail)
}

// SetCitizenId sets the "CitizenId" field.
func (m *UserprofileMutation) SetCitizenId(s string) {
	m._CitizenId = &s
}

// CitizenId returns the value of the "CitizenId" field in the mutation.
func (m *UserprofileMutation) CitizenId() (r string, exists bool) {
	v := m._CitizenId
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenId returns the old "CitizenId" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldCitizenId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCitizenId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCitizenId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenId: %w", err)
	}
	return oldValue.CitizenId, nil
}

// ClearCitizenId clears the value of the "CitizenId" field.
func (m *UserprofileMutation) ClearCitizenId() {
	m._CitizenId = nil
	m.clearedFields[userprofile.FieldCitizenId] = struct{}{}
}

// CitizenIdCleared returns if the "CitizenId" field was cleared in this mutation.
func (m *UserprofileMutation) CitizenIdCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldCitizenId]
	return ok
}

// ResetCitizenId resets all changes to the "CitizenId" field.
func (m *UserprofileMutation) ResetCitizenId() {
	m._CitizenId = nil
	delete(m.clearedFields, userprofile.FieldCitizenId)
}

// SetBirthDate sets the "BirthDate" field.
func (m *UserprofileMutation) SetBirthDate(s string) {
	m._BirthDate = &s
}

// BirthDate returns the value of the "BirthDate" field in the mutation.
func (m *UserprofileMutation) BirthDate() (r string, exists bool) {
	v := m._BirthDate
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "BirthDate" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldBirthDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ClearBirthDate clears the value of the "BirthDate" field.
func (m *UserprofileMutation) ClearBirthDate() {
	m._BirthDate = nil
	m.clearedFields[userprofile.FieldBirthDate] = struct{}{}
}

// BirthDateCleared returns if the "BirthDate" field was cleared in this mutation.
func (m *UserprofileMutation) BirthDateCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBirthDate]
	return ok
}

// ResetBirthDate resets all changes to the "BirthDate" field.
func (m *UserprofileMutation) ResetBirthDate() {
	m._BirthDate = nil
	delete(m.clearedFields, userprofile.FieldBirthDate)
}

// SetGender sets the "Gender" field.
func (m *UserprofileMutation) SetGender(s string) {
	m._Gender = &s
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *UserprofileMutation) Gender() (r string, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ClearGender clears the value of the "Gender" field.
func (m *UserprofileMutation) ClearGender() {
	m._Gender = nil
	m.clearedFields[userprofile.FieldGender] = struct{}{}
}

// GenderCleared returns if the "Gender" field was cleared in this mutation.
func (m *UserprofileMutation) GenderCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldGender]
	return ok
}

// ResetGender resets all changes to the "Gender" field.
func (m *UserprofileMutation) ResetGender() {
	m._Gender = nil
	delete(m.clearedFields, userprofile.FieldGender)
}

// SetBusinessAddress sets the "BusinessAddress" field.
func (m *UserprofileMutation) SetBusinessAddress(s string) {
	m._BusinessAddress = &s
}

// BusinessAddress returns the value of the "BusinessAddress" field in the mutation.
func (m *UserprofileMutation) BusinessAddress() (r string, exists bool) {
	v := m._BusinessAddress
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessAddress returns the old "BusinessAddress" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldBusinessAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBusinessAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBusinessAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessAddress: %w", err)
	}
	return oldValue.BusinessAddress, nil
}

// ClearBusinessAddress clears the value of the "BusinessAddress" field.
func (m *UserprofileMutation) ClearBusinessAddress() {
	m._BusinessAddress = nil
	m.clearedFields[userprofile.FieldBusinessAddress] = struct{}{}
}

// BusinessAddressCleared returns if the "BusinessAddress" field was cleared in this mutation.
func (m *UserprofileMutation) BusinessAddressCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldBusinessAddress]
	return ok
}

// ResetBusinessAddress resets all changes to the "BusinessAddress" field.
func (m *UserprofileMutation) ResetBusinessAddress() {
	m._BusinessAddress = nil
	delete(m.clearedFields, userprofile.FieldBusinessAddress)
}

// SetOccupationId sets the "OccupationId" field.
func (m *UserprofileMutation) SetOccupationId(i int) {
	m._OccupationId = &i
	m.add_OccupationId = nil
}

// OccupationId returns the value of the "OccupationId" field in the mutation.
func (m *UserprofileMutation) OccupationId() (r int, exists bool) {
	v := m._OccupationId
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationId returns the old "OccupationId" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldOccupationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupationId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationId: %w", err)
	}
	return oldValue.OccupationId, nil
}

// AddOccupationId adds i to the "OccupationId" field.
func (m *UserprofileMutation) AddOccupationId(i int) {
	if m.add_OccupationId != nil {
		*m.add_OccupationId += i
	} else {
		m.add_OccupationId = &i
	}
}

// AddedOccupationId returns the value that was added to the "OccupationId" field in this mutation.
func (m *UserprofileMutation) AddedOccupationId() (r int, exists bool) {
	v := m.add_OccupationId
	if v == nil {
		return
	}
	return *v, true
}

// ClearOccupationId clears the value of the "OccupationId" field.
func (m *UserprofileMutation) ClearOccupationId() {
	m._OccupationId = nil
	m.add_OccupationId = nil
	m.clearedFields[userprofile.FieldOccupationId] = struct{}{}
}

// OccupationIdCleared returns if the "OccupationId" field was cleared in this mutation.
func (m *UserprofileMutation) OccupationIdCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldOccupationId]
	return ok
}

// ResetOccupationId resets all changes to the "OccupationId" field.
func (m *UserprofileMutation) ResetOccupationId() {
	m._OccupationId = nil
	m.add_OccupationId = nil
	delete(m.clearedFields, userprofile.FieldOccupationId)
}

// SetFileimportID sets the "FileimportID" field.
func (m *UserprofileMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *UserprofileMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Userprofile entity.
// If the Userprofile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserprofileMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *UserprofileMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *UserprofileMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *UserprofileMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[userprofile.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *UserprofileMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[userprofile.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *UserprofileMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, userprofile.FieldFileimportID)
}

// Op returns the operation name.
func (m *UserprofileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Userprofile).
func (m *UserprofileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserprofileMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m._UserId != nil {
		fields = append(fields, userprofile.FieldUserId)
	}
	if m._Firstname != nil {
		fields = append(fields, userprofile.FieldFirstname)
	}
	if m._Lastname != nil {
		fields = append(fields, userprofile.FieldLastname)
	}
	if m._PhoneNo != nil {
		fields = append(fields, userprofile.FieldPhoneNo)
	}
	if m._Email != nil {
		fields = append(fields, userprofile.FieldEmail)
	}
	if m._CitizenId != nil {
		fields = append(fields, userprofile.FieldCitizenId)
	}
	if m._BirthDate != nil {
		fields = append(fields, userprofile.FieldBirthDate)
	}
	if m._Gender != nil {
		fields = append(fields, userprofile.FieldGender)
	}
	if m._BusinessAddress != nil {
		fields = append(fields, userprofile.FieldBusinessAddress)
	}
	if m._OccupationId != nil {
		fields = append(fields, userprofile.FieldOccupationId)
	}
	if m._FileimportID != nil {
		fields = append(fields, userprofile.FieldFileimportID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserprofileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldUserId:
		return m.UserId()
	case userprofile.FieldFirstname:
		return m.Firstname()
	case userprofile.FieldLastname:
		return m.Lastname()
	case userprofile.FieldPhoneNo:
		return m.PhoneNo()
	case userprofile.FieldEmail:
		return m.Email()
	case userprofile.FieldCitizenId:
		return m.CitizenId()
	case userprofile.FieldBirthDate:
		return m.BirthDate()
	case userprofile.FieldGender:
		return m.Gender()
	case userprofile.FieldBusinessAddress:
		return m.BusinessAddress()
	case userprofile.FieldOccupationId:
		return m.OccupationId()
	case userprofile.FieldFileimportID:
		return m.FileimportID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserprofileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userprofile.FieldUserId:
		return m.OldUserId(ctx)
	case userprofile.FieldFirstname:
		return m.OldFirstname(ctx)
	case userprofile.FieldLastname:
		return m.OldLastname(ctx)
	case userprofile.FieldPhoneNo:
		return m.OldPhoneNo(ctx)
	case userprofile.FieldEmail:
		return m.OldEmail(ctx)
	case userprofile.FieldCitizenId:
		return m.OldCitizenId(ctx)
	case userprofile.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case userprofile.FieldGender:
		return m.OldGender(ctx)
	case userprofile.FieldBusinessAddress:
		return m.OldBusinessAddress(ctx)
	case userprofile.FieldOccupationId:
		return m.OldOccupationId(ctx)
	case userprofile.FieldFileimportID:
		return m.OldFileimportID(ctx)
	}
	return nil, fmt.Errorf("unknown Userprofile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserprofileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldUserId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserId(v)
		return nil
	case userprofile.FieldFirstname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstname(v)
		return nil
	case userprofile.FieldLastname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastname(v)
		return nil
	case userprofile.FieldPhoneNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNo(v)
		return nil
	case userprofile.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userprofile.FieldCitizenId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenId(v)
		return nil
	case userprofile.FieldBirthDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case userprofile.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case userprofile.FieldBusinessAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessAddress(v)
		return nil
	case userprofile.FieldOccupationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationId(v)
		return nil
	case userprofile.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Userprofile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserprofileMutation) AddedFields() []string {
	var fields []string
	if m.add_OccupationId != nil {
		fields = append(fields, userprofile.FieldOccupationId)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, userprofile.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserprofileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userprofile.FieldOccupationId:
		return m.AddedOccupationId()
	case userprofile.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserprofileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userprofile.FieldOccupationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOccupationId(v)
		return nil
	case userprofile.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Userprofile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserprofileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userprofile.FieldUserId) {
		fields = append(fields, userprofile.FieldUserId)
	}
	if m.FieldCleared(userprofile.FieldFirstname) {
		fields = append(fields, userprofile.FieldFirstname)
	}
	if m.FieldCleared(userprofile.FieldLastname) {
		fields = append(fields, userprofile.FieldLastname)
	}
	if m.FieldCleared(userprofile.FieldPhoneNo) {
		fields = append(fields, userprofile.FieldPhoneNo)
	}
	if m.FieldCleared(userprofile.FieldEmail) {
		fields = append(fields, userprofile.FieldEmail)
	}
	if m.FieldCleared(userprofile.FieldCitizenId) {
		fields = append(fields, userprofile.FieldCitizenId)
	}
	if m.FieldCleared(userprofile.FieldBirthDate) {
		fields = append(fields, userprofile.FieldBirthDate)
	}
	if m.FieldCleared(userprofile.FieldGender) {
		fields = append(fields, userprofile.FieldGender)
	}
	if m.FieldCleared(userprofile.FieldBusinessAddress) {
		fields = append(fields, userprofile.FieldBusinessAddress)
	}
	if m.FieldCleared(userprofile.FieldOccupationId) {
		fields = append(fields, userprofile.FieldOccupationId)
	}
	if m.FieldCleared(userprofile.FieldFileimportID) {
		fields = append(fields, userprofile.FieldFileimportID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserprofileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserprofileMutation) ClearField(name string) error {
	switch name {
	case userprofile.FieldUserId:
		m.ClearUserId()
		return nil
	case userprofile.FieldFirstname:
		m.ClearFirstname()
		return nil
	case userprofile.FieldLastname:
		m.ClearLastname()
		return nil
	case userprofile.FieldPhoneNo:
		m.ClearPhoneNo()
		return nil
	case userprofile.FieldEmail:
		m.ClearEmail()
		return nil
	case userprofile.FieldCitizenId:
		m.ClearCitizenId()
		return nil
	case userprofile.FieldBirthDate:
		m.ClearBirthDate()
		return nil
	case userprofile.FieldGender:
		m.ClearGender()
		return nil
	case userprofile.FieldBusinessAddress:
		m.ClearBusinessAddress()
		return nil
	case userprofile.FieldOccupationId:
		m.ClearOccupationId()
		return nil
	case userprofile.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Userprofile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserprofileMutation) ResetField(name string) error {
	switch name {
	case userprofile.FieldUserId:
		m.ResetUserId()
		return nil
	case userprofile.FieldFirstname:
		m.ResetFirstname()
		return nil
	case userprofile.FieldLastname:
		m.ResetLastname()
		return nil
	case userprofile.FieldPhoneNo:
		m.ResetPhoneNo()
		return nil
	case userprofile.FieldEmail:
		m.ResetEmail()
		return nil
	case userprofile.FieldCitizenId:
		m.ResetCitizenId()
		return nil
	case userprofile.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case userprofile.FieldGender:
		m.ResetGender()
		return nil
	case userprofile.FieldBusinessAddress:
		m.ResetBusinessAddress()
		return nil
	case userprofile.FieldOccupationId:
		m.ResetOccupationId()
		return nil
	case userprofile.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	}
	return fmt.Errorf("unknown Userprofile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserprofileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserprofileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserprofileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserprofileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserprofileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserprofileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserprofileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Userprofile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserprofileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Userprofile edge %s", name)
}

// UserwalletMutation represents an operation that mutates the Userwallet nodes in the graph.
type UserwalletMutation struct {
	config
	op               Op
	typ              string
	id               *int
	walletid         *string
	_WalletTypeName  *string
	_WalletPhoneno   *string
	_WalletName      *string
	_CitizenId       *string
	_Status          *string
	_RegisterDate    *time.Time
	_GroupUser       *int
	add_GroupUser    *int
	_UserAgent       *string
	_KYC_Date        *time.Time
	_ATMCard         *string
	_AccountNo       *string
	_AddressDetail   *string
	_Street          *string
	_District        *string
	_SubDistrict     *string
	_Province        *string
	_PostalCode      *string
	isKYC            *string
	_UpdateDate      *time.Time
	_OccupationId    *int
	add_OccupationId *int
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*Userwallet, error)
	predicates       []predicate.Userwallet
}

var _ ent.Mutation = (*UserwalletMutation)(nil)

// userwalletOption allows management of the mutation configuration using functional options.
type userwalletOption func(*UserwalletMutation)

// newUserwalletMutation creates new mutation for the Userwallet entity.
func newUserwalletMutation(c config, op Op, opts ...userwalletOption) *UserwalletMutation {
	m := &UserwalletMutation{
		config:        c,
		op:            op,
		typ:           TypeUserwallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserwalletID sets the ID field of the mutation.
func withUserwalletID(id int) userwalletOption {
	return func(m *UserwalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Userwallet
		)
		m.oldValue = func(ctx context.Context) (*Userwallet, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Userwallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserwallet sets the old Userwallet of the mutation.
func withUserwallet(node *Userwallet) userwalletOption {
	return func(m *UserwalletMutation) {
		m.oldValue = func(context.Context) (*Userwallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserwalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserwalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Userwallet entities.
func (m *UserwalletMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserwalletMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetWalletid sets the "walletid" field.
func (m *UserwalletMutation) SetWalletid(s string) {
	m.walletid = &s
}

// Walletid returns the value of the "walletid" field in the mutation.
func (m *UserwalletMutation) Walletid() (r string, exists bool) {
	v := m.walletid
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletid returns the old "walletid" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldWalletid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletid: %w", err)
	}
	return oldValue.Walletid, nil
}

// ResetWalletid resets all changes to the "walletid" field.
func (m *UserwalletMutation) ResetWalletid() {
	m.walletid = nil
}

// SetWalletTypeName sets the "WalletTypeName" field.
func (m *UserwalletMutation) SetWalletTypeName(s string) {
	m._WalletTypeName = &s
}

// WalletTypeName returns the value of the "WalletTypeName" field in the mutation.
func (m *UserwalletMutation) WalletTypeName() (r string, exists bool) {
	v := m._WalletTypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletTypeName returns the old "WalletTypeName" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldWalletTypeName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletTypeName: %w", err)
	}
	return oldValue.WalletTypeName, nil
}

// ClearWalletTypeName clears the value of the "WalletTypeName" field.
func (m *UserwalletMutation) ClearWalletTypeName() {
	m._WalletTypeName = nil
	m.clearedFields[userwallet.FieldWalletTypeName] = struct{}{}
}

// WalletTypeNameCleared returns if the "WalletTypeName" field was cleared in this mutation.
func (m *UserwalletMutation) WalletTypeNameCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldWalletTypeName]
	return ok
}

// ResetWalletTypeName resets all changes to the "WalletTypeName" field.
func (m *UserwalletMutation) ResetWalletTypeName() {
	m._WalletTypeName = nil
	delete(m.clearedFields, userwallet.FieldWalletTypeName)
}

// SetWalletPhoneno sets the "WalletPhoneno" field.
func (m *UserwalletMutation) SetWalletPhoneno(s string) {
	m._WalletPhoneno = &s
}

// WalletPhoneno returns the value of the "WalletPhoneno" field in the mutation.
func (m *UserwalletMutation) WalletPhoneno() (r string, exists bool) {
	v := m._WalletPhoneno
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletPhoneno returns the old "WalletPhoneno" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldWalletPhoneno(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletPhoneno is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletPhoneno requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletPhoneno: %w", err)
	}
	return oldValue.WalletPhoneno, nil
}

// ClearWalletPhoneno clears the value of the "WalletPhoneno" field.
func (m *UserwalletMutation) ClearWalletPhoneno() {
	m._WalletPhoneno = nil
	m.clearedFields[userwallet.FieldWalletPhoneno] = struct{}{}
}

// WalletPhonenoCleared returns if the "WalletPhoneno" field was cleared in this mutation.
func (m *UserwalletMutation) WalletPhonenoCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldWalletPhoneno]
	return ok
}

// ResetWalletPhoneno resets all changes to the "WalletPhoneno" field.
func (m *UserwalletMutation) ResetWalletPhoneno() {
	m._WalletPhoneno = nil
	delete(m.clearedFields, userwallet.FieldWalletPhoneno)
}

// SetWalletName sets the "WalletName" field.
func (m *UserwalletMutation) SetWalletName(s string) {
	m._WalletName = &s
}

// WalletName returns the value of the "WalletName" field in the mutation.
func (m *UserwalletMutation) WalletName() (r string, exists bool) {
	v := m._WalletName
	if v == nil {
		return
	}
	return *v, true
}

// OldWalletName returns the old "WalletName" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldWalletName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWalletName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWalletName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWalletName: %w", err)
	}
	return oldValue.WalletName, nil
}

// ClearWalletName clears the value of the "WalletName" field.
func (m *UserwalletMutation) ClearWalletName() {
	m._WalletName = nil
	m.clearedFields[userwallet.FieldWalletName] = struct{}{}
}

// WalletNameCleared returns if the "WalletName" field was cleared in this mutation.
func (m *UserwalletMutation) WalletNameCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldWalletName]
	return ok
}

// ResetWalletName resets all changes to the "WalletName" field.
func (m *UserwalletMutation) ResetWalletName() {
	m._WalletName = nil
	delete(m.clearedFields, userwallet.FieldWalletName)
}

// SetCitizenId sets the "CitizenId" field.
func (m *UserwalletMutation) SetCitizenId(s string) {
	m._CitizenId = &s
}

// CitizenId returns the value of the "CitizenId" field in the mutation.
func (m *UserwalletMutation) CitizenId() (r string, exists bool) {
	v := m._CitizenId
	if v == nil {
		return
	}
	return *v, true
}

// OldCitizenId returns the old "CitizenId" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldCitizenId(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCitizenId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCitizenId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCitizenId: %w", err)
	}
	return oldValue.CitizenId, nil
}

// ClearCitizenId clears the value of the "CitizenId" field.
func (m *UserwalletMutation) ClearCitizenId() {
	m._CitizenId = nil
	m.clearedFields[userwallet.FieldCitizenId] = struct{}{}
}

// CitizenIdCleared returns if the "CitizenId" field was cleared in this mutation.
func (m *UserwalletMutation) CitizenIdCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldCitizenId]
	return ok
}

// ResetCitizenId resets all changes to the "CitizenId" field.
func (m *UserwalletMutation) ResetCitizenId() {
	m._CitizenId = nil
	delete(m.clearedFields, userwallet.FieldCitizenId)
}

// SetStatus sets the "Status" field.
func (m *UserwalletMutation) SetStatus(s string) {
	m._Status = &s
}

// Status returns the value of the "Status" field in the mutation.
func (m *UserwalletMutation) Status() (r string, exists bool) {
	v := m._Status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "Status" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldStatus(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "Status" field.
func (m *UserwalletMutation) ClearStatus() {
	m._Status = nil
	m.clearedFields[userwallet.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "Status" field was cleared in this mutation.
func (m *UserwalletMutation) StatusCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "Status" field.
func (m *UserwalletMutation) ResetStatus() {
	m._Status = nil
	delete(m.clearedFields, userwallet.FieldStatus)
}

// SetRegisterDate sets the "RegisterDate" field.
func (m *UserwalletMutation) SetRegisterDate(t time.Time) {
	m._RegisterDate = &t
}

// RegisterDate returns the value of the "RegisterDate" field in the mutation.
func (m *UserwalletMutation) RegisterDate() (r time.Time, exists bool) {
	v := m._RegisterDate
	if v == nil {
		return
	}
	return *v, true
}

// OldRegisterDate returns the old "RegisterDate" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldRegisterDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRegisterDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRegisterDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegisterDate: %w", err)
	}
	return oldValue.RegisterDate, nil
}

// ClearRegisterDate clears the value of the "RegisterDate" field.
func (m *UserwalletMutation) ClearRegisterDate() {
	m._RegisterDate = nil
	m.clearedFields[userwallet.FieldRegisterDate] = struct{}{}
}

// RegisterDateCleared returns if the "RegisterDate" field was cleared in this mutation.
func (m *UserwalletMutation) RegisterDateCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldRegisterDate]
	return ok
}

// ResetRegisterDate resets all changes to the "RegisterDate" field.
func (m *UserwalletMutation) ResetRegisterDate() {
	m._RegisterDate = nil
	delete(m.clearedFields, userwallet.FieldRegisterDate)
}

// SetGroupUser sets the "GroupUser" field.
func (m *UserwalletMutation) SetGroupUser(i int) {
	m._GroupUser = &i
	m.add_GroupUser = nil
}

// GroupUser returns the value of the "GroupUser" field in the mutation.
func (m *UserwalletMutation) GroupUser() (r int, exists bool) {
	v := m._GroupUser
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupUser returns the old "GroupUser" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldGroupUser(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGroupUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGroupUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupUser: %w", err)
	}
	return oldValue.GroupUser, nil
}

// AddGroupUser adds i to the "GroupUser" field.
func (m *UserwalletMutation) AddGroupUser(i int) {
	if m.add_GroupUser != nil {
		*m.add_GroupUser += i
	} else {
		m.add_GroupUser = &i
	}
}

// AddedGroupUser returns the value that was added to the "GroupUser" field in this mutation.
func (m *UserwalletMutation) AddedGroupUser() (r int, exists bool) {
	v := m.add_GroupUser
	if v == nil {
		return
	}
	return *v, true
}

// ClearGroupUser clears the value of the "GroupUser" field.
func (m *UserwalletMutation) ClearGroupUser() {
	m._GroupUser = nil
	m.add_GroupUser = nil
	m.clearedFields[userwallet.FieldGroupUser] = struct{}{}
}

// GroupUserCleared returns if the "GroupUser" field was cleared in this mutation.
func (m *UserwalletMutation) GroupUserCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldGroupUser]
	return ok
}

// ResetGroupUser resets all changes to the "GroupUser" field.
func (m *UserwalletMutation) ResetGroupUser() {
	m._GroupUser = nil
	m.add_GroupUser = nil
	delete(m.clearedFields, userwallet.FieldGroupUser)
}

// SetUserAgent sets the "UserAgent" field.
func (m *UserwalletMutation) SetUserAgent(s string) {
	m._UserAgent = &s
}

// UserAgent returns the value of the "UserAgent" field in the mutation.
func (m *UserwalletMutation) UserAgent() (r string, exists bool) {
	v := m._UserAgent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "UserAgent" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldUserAgent(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "UserAgent" field.
func (m *UserwalletMutation) ClearUserAgent() {
	m._UserAgent = nil
	m.clearedFields[userwallet.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "UserAgent" field was cleared in this mutation.
func (m *UserwalletMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "UserAgent" field.
func (m *UserwalletMutation) ResetUserAgent() {
	m._UserAgent = nil
	delete(m.clearedFields, userwallet.FieldUserAgent)
}

// SetKYCDate sets the "KYC_Date" field.
func (m *UserwalletMutation) SetKYCDate(t time.Time) {
	m._KYC_Date = &t
}

// KYCDate returns the value of the "KYC_Date" field in the mutation.
func (m *UserwalletMutation) KYCDate() (r time.Time, exists bool) {
	v := m._KYC_Date
	if v == nil {
		return
	}
	return *v, true
}

// OldKYCDate returns the old "KYC_Date" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldKYCDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKYCDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKYCDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKYCDate: %w", err)
	}
	return oldValue.KYCDate, nil
}

// ClearKYCDate clears the value of the "KYC_Date" field.
func (m *UserwalletMutation) ClearKYCDate() {
	m._KYC_Date = nil
	m.clearedFields[userwallet.FieldKYCDate] = struct{}{}
}

// KYCDateCleared returns if the "KYC_Date" field was cleared in this mutation.
func (m *UserwalletMutation) KYCDateCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldKYCDate]
	return ok
}

// ResetKYCDate resets all changes to the "KYC_Date" field.
func (m *UserwalletMutation) ResetKYCDate() {
	m._KYC_Date = nil
	delete(m.clearedFields, userwallet.FieldKYCDate)
}

// SetATMCard sets the "ATMCard" field.
func (m *UserwalletMutation) SetATMCard(s string) {
	m._ATMCard = &s
}

// ATMCard returns the value of the "ATMCard" field in the mutation.
func (m *UserwalletMutation) ATMCard() (r string, exists bool) {
	v := m._ATMCard
	if v == nil {
		return
	}
	return *v, true
}

// OldATMCard returns the old "ATMCard" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldATMCard(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldATMCard is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldATMCard requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldATMCard: %w", err)
	}
	return oldValue.ATMCard, nil
}

// ClearATMCard clears the value of the "ATMCard" field.
func (m *UserwalletMutation) ClearATMCard() {
	m._ATMCard = nil
	m.clearedFields[userwallet.FieldATMCard] = struct{}{}
}

// ATMCardCleared returns if the "ATMCard" field was cleared in this mutation.
func (m *UserwalletMutation) ATMCardCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldATMCard]
	return ok
}

// ResetATMCard resets all changes to the "ATMCard" field.
func (m *UserwalletMutation) ResetATMCard() {
	m._ATMCard = nil
	delete(m.clearedFields, userwallet.FieldATMCard)
}

// SetAccountNo sets the "AccountNo" field.
func (m *UserwalletMutation) SetAccountNo(s string) {
	m._AccountNo = &s
}

// AccountNo returns the value of the "AccountNo" field in the mutation.
func (m *UserwalletMutation) AccountNo() (r string, exists bool) {
	v := m._AccountNo
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountNo returns the old "AccountNo" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldAccountNo(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAccountNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAccountNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountNo: %w", err)
	}
	return oldValue.AccountNo, nil
}

// ClearAccountNo clears the value of the "AccountNo" field.
func (m *UserwalletMutation) ClearAccountNo() {
	m._AccountNo = nil
	m.clearedFields[userwallet.FieldAccountNo] = struct{}{}
}

// AccountNoCleared returns if the "AccountNo" field was cleared in this mutation.
func (m *UserwalletMutation) AccountNoCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldAccountNo]
	return ok
}

// ResetAccountNo resets all changes to the "AccountNo" field.
func (m *UserwalletMutation) ResetAccountNo() {
	m._AccountNo = nil
	delete(m.clearedFields, userwallet.FieldAccountNo)
}

// SetAddressDetail sets the "AddressDetail" field.
func (m *UserwalletMutation) SetAddressDetail(s string) {
	m._AddressDetail = &s
}

// AddressDetail returns the value of the "AddressDetail" field in the mutation.
func (m *UserwalletMutation) AddressDetail() (r string, exists bool) {
	v := m._AddressDetail
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressDetail returns the old "AddressDetail" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldAddressDetail(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddressDetail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddressDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressDetail: %w", err)
	}
	return oldValue.AddressDetail, nil
}

// ClearAddressDetail clears the value of the "AddressDetail" field.
func (m *UserwalletMutation) ClearAddressDetail() {
	m._AddressDetail = nil
	m.clearedFields[userwallet.FieldAddressDetail] = struct{}{}
}

// AddressDetailCleared returns if the "AddressDetail" field was cleared in this mutation.
func (m *UserwalletMutation) AddressDetailCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldAddressDetail]
	return ok
}

// ResetAddressDetail resets all changes to the "AddressDetail" field.
func (m *UserwalletMutation) ResetAddressDetail() {
	m._AddressDetail = nil
	delete(m.clearedFields, userwallet.FieldAddressDetail)
}

// SetStreet sets the "Street" field.
func (m *UserwalletMutation) SetStreet(s string) {
	m._Street = &s
}

// Street returns the value of the "Street" field in the mutation.
func (m *UserwalletMutation) Street() (r string, exists bool) {
	v := m._Street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "Street" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldStreet(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ClearStreet clears the value of the "Street" field.
func (m *UserwalletMutation) ClearStreet() {
	m._Street = nil
	m.clearedFields[userwallet.FieldStreet] = struct{}{}
}

// StreetCleared returns if the "Street" field was cleared in this mutation.
func (m *UserwalletMutation) StreetCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldStreet]
	return ok
}

// ResetStreet resets all changes to the "Street" field.
func (m *UserwalletMutation) ResetStreet() {
	m._Street = nil
	delete(m.clearedFields, userwallet.FieldStreet)
}

// SetDistrict sets the "District" field.
func (m *UserwalletMutation) SetDistrict(s string) {
	m._District = &s
}

// District returns the value of the "District" field in the mutation.
func (m *UserwalletMutation) District() (r string, exists bool) {
	v := m._District
	if v == nil {
		return
	}
	return *v, true
}

// OldDistrict returns the old "District" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDistrict: %w", err)
	}
	return oldValue.District, nil
}

// ClearDistrict clears the value of the "District" field.
func (m *UserwalletMutation) ClearDistrict() {
	m._District = nil
	m.clearedFields[userwallet.FieldDistrict] = struct{}{}
}

// DistrictCleared returns if the "District" field was cleared in this mutation.
func (m *UserwalletMutation) DistrictCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldDistrict]
	return ok
}

// ResetDistrict resets all changes to the "District" field.
func (m *UserwalletMutation) ResetDistrict() {
	m._District = nil
	delete(m.clearedFields, userwallet.FieldDistrict)
}

// SetSubDistrict sets the "SubDistrict" field.
func (m *UserwalletMutation) SetSubDistrict(s string) {
	m._SubDistrict = &s
}

// SubDistrict returns the value of the "SubDistrict" field in the mutation.
func (m *UserwalletMutation) SubDistrict() (r string, exists bool) {
	v := m._SubDistrict
	if v == nil {
		return
	}
	return *v, true
}

// OldSubDistrict returns the old "SubDistrict" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldSubDistrict(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSubDistrict is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSubDistrict requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubDistrict: %w", err)
	}
	return oldValue.SubDistrict, nil
}

// ClearSubDistrict clears the value of the "SubDistrict" field.
func (m *UserwalletMutation) ClearSubDistrict() {
	m._SubDistrict = nil
	m.clearedFields[userwallet.FieldSubDistrict] = struct{}{}
}

// SubDistrictCleared returns if the "SubDistrict" field was cleared in this mutation.
func (m *UserwalletMutation) SubDistrictCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldSubDistrict]
	return ok
}

// ResetSubDistrict resets all changes to the "SubDistrict" field.
func (m *UserwalletMutation) ResetSubDistrict() {
	m._SubDistrict = nil
	delete(m.clearedFields, userwallet.FieldSubDistrict)
}

// SetProvince sets the "Province" field.
func (m *UserwalletMutation) SetProvince(s string) {
	m._Province = &s
}

// Province returns the value of the "Province" field in the mutation.
func (m *UserwalletMutation) Province() (r string, exists bool) {
	v := m._Province
	if v == nil {
		return
	}
	return *v, true
}

// OldProvince returns the old "Province" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldProvince(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProvince is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProvince requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvince: %w", err)
	}
	return oldValue.Province, nil
}

// ClearProvince clears the value of the "Province" field.
func (m *UserwalletMutation) ClearProvince() {
	m._Province = nil
	m.clearedFields[userwallet.FieldProvince] = struct{}{}
}

// ProvinceCleared returns if the "Province" field was cleared in this mutation.
func (m *UserwalletMutation) ProvinceCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldProvince]
	return ok
}

// ResetProvince resets all changes to the "Province" field.
func (m *UserwalletMutation) ResetProvince() {
	m._Province = nil
	delete(m.clearedFields, userwallet.FieldProvince)
}

// SetPostalCode sets the "PostalCode" field.
func (m *UserwalletMutation) SetPostalCode(s string) {
	m._PostalCode = &s
}

// PostalCode returns the value of the "PostalCode" field in the mutation.
func (m *UserwalletMutation) PostalCode() (r string, exists bool) {
	v := m._PostalCode
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "PostalCode" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldPostalCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ClearPostalCode clears the value of the "PostalCode" field.
func (m *UserwalletMutation) ClearPostalCode() {
	m._PostalCode = nil
	m.clearedFields[userwallet.FieldPostalCode] = struct{}{}
}

// PostalCodeCleared returns if the "PostalCode" field was cleared in this mutation.
func (m *UserwalletMutation) PostalCodeCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldPostalCode]
	return ok
}

// ResetPostalCode resets all changes to the "PostalCode" field.
func (m *UserwalletMutation) ResetPostalCode() {
	m._PostalCode = nil
	delete(m.clearedFields, userwallet.FieldPostalCode)
}

// SetIsKYC sets the "isKYC" field.
func (m *UserwalletMutation) SetIsKYC(s string) {
	m.isKYC = &s
}

// IsKYC returns the value of the "isKYC" field in the mutation.
func (m *UserwalletMutation) IsKYC() (r string, exists bool) {
	v := m.isKYC
	if v == nil {
		return
	}
	return *v, true
}

// OldIsKYC returns the old "isKYC" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldIsKYC(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsKYC is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsKYC requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsKYC: %w", err)
	}
	return oldValue.IsKYC, nil
}

// ClearIsKYC clears the value of the "isKYC" field.
func (m *UserwalletMutation) ClearIsKYC() {
	m.isKYC = nil
	m.clearedFields[userwallet.FieldIsKYC] = struct{}{}
}

// IsKYCCleared returns if the "isKYC" field was cleared in this mutation.
func (m *UserwalletMutation) IsKYCCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldIsKYC]
	return ok
}

// ResetIsKYC resets all changes to the "isKYC" field.
func (m *UserwalletMutation) ResetIsKYC() {
	m.isKYC = nil
	delete(m.clearedFields, userwallet.FieldIsKYC)
}

// SetUpdateDate sets the "UpdateDate" field.
func (m *UserwalletMutation) SetUpdateDate(t time.Time) {
	m._UpdateDate = &t
}

// UpdateDate returns the value of the "UpdateDate" field in the mutation.
func (m *UserwalletMutation) UpdateDate() (r time.Time, exists bool) {
	v := m._UpdateDate
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateDate returns the old "UpdateDate" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldUpdateDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateDate: %w", err)
	}
	return oldValue.UpdateDate, nil
}

// ClearUpdateDate clears the value of the "UpdateDate" field.
func (m *UserwalletMutation) ClearUpdateDate() {
	m._UpdateDate = nil
	m.clearedFields[userwallet.FieldUpdateDate] = struct{}{}
}

// UpdateDateCleared returns if the "UpdateDate" field was cleared in this mutation.
func (m *UserwalletMutation) UpdateDateCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldUpdateDate]
	return ok
}

// ResetUpdateDate resets all changes to the "UpdateDate" field.
func (m *UserwalletMutation) ResetUpdateDate() {
	m._UpdateDate = nil
	delete(m.clearedFields, userwallet.FieldUpdateDate)
}

// SetOccupationId sets the "OccupationId" field.
func (m *UserwalletMutation) SetOccupationId(i int) {
	m._OccupationId = &i
	m.add_OccupationId = nil
}

// OccupationId returns the value of the "OccupationId" field in the mutation.
func (m *UserwalletMutation) OccupationId() (r int, exists bool) {
	v := m._OccupationId
	if v == nil {
		return
	}
	return *v, true
}

// OldOccupationId returns the old "OccupationId" field's value of the Userwallet entity.
// If the Userwallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserwalletMutation) OldOccupationId(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOccupationId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOccupationId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOccupationId: %w", err)
	}
	return oldValue.OccupationId, nil
}

// AddOccupationId adds i to the "OccupationId" field.
func (m *UserwalletMutation) AddOccupationId(i int) {
	if m.add_OccupationId != nil {
		*m.add_OccupationId += i
	} else {
		m.add_OccupationId = &i
	}
}

// AddedOccupationId returns the value that was added to the "OccupationId" field in this mutation.
func (m *UserwalletMutation) AddedOccupationId() (r int, exists bool) {
	v := m.add_OccupationId
	if v == nil {
		return
	}
	return *v, true
}

// ClearOccupationId clears the value of the "OccupationId" field.
func (m *UserwalletMutation) ClearOccupationId() {
	m._OccupationId = nil
	m.add_OccupationId = nil
	m.clearedFields[userwallet.FieldOccupationId] = struct{}{}
}

// OccupationIdCleared returns if the "OccupationId" field was cleared in this mutation.
func (m *UserwalletMutation) OccupationIdCleared() bool {
	_, ok := m.clearedFields[userwallet.FieldOccupationId]
	return ok
}

// ResetOccupationId resets all changes to the "OccupationId" field.
func (m *UserwalletMutation) ResetOccupationId() {
	m._OccupationId = nil
	m.add_OccupationId = nil
	delete(m.clearedFields, userwallet.FieldOccupationId)
}

// Op returns the operation name.
func (m *UserwalletMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Userwallet).
func (m *UserwalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserwalletMutation) Fields() []string {
	fields := make([]string, 0, 21)
	if m.walletid != nil {
		fields = append(fields, userwallet.FieldWalletid)
	}
	if m._WalletTypeName != nil {
		fields = append(fields, userwallet.FieldWalletTypeName)
	}
	if m._WalletPhoneno != nil {
		fields = append(fields, userwallet.FieldWalletPhoneno)
	}
	if m._WalletName != nil {
		fields = append(fields, userwallet.FieldWalletName)
	}
	if m._CitizenId != nil {
		fields = append(fields, userwallet.FieldCitizenId)
	}
	if m._Status != nil {
		fields = append(fields, userwallet.FieldStatus)
	}
	if m._RegisterDate != nil {
		fields = append(fields, userwallet.FieldRegisterDate)
	}
	if m._GroupUser != nil {
		fields = append(fields, userwallet.FieldGroupUser)
	}
	if m._UserAgent != nil {
		fields = append(fields, userwallet.FieldUserAgent)
	}
	if m._KYC_Date != nil {
		fields = append(fields, userwallet.FieldKYCDate)
	}
	if m._ATMCard != nil {
		fields = append(fields, userwallet.FieldATMCard)
	}
	if m._AccountNo != nil {
		fields = append(fields, userwallet.FieldAccountNo)
	}
	if m._AddressDetail != nil {
		fields = append(fields, userwallet.FieldAddressDetail)
	}
	if m._Street != nil {
		fields = append(fields, userwallet.FieldStreet)
	}
	if m._District != nil {
		fields = append(fields, userwallet.FieldDistrict)
	}
	if m._SubDistrict != nil {
		fields = append(fields, userwallet.FieldSubDistrict)
	}
	if m._Province != nil {
		fields = append(fields, userwallet.FieldProvince)
	}
	if m._PostalCode != nil {
		fields = append(fields, userwallet.FieldPostalCode)
	}
	if m.isKYC != nil {
		fields = append(fields, userwallet.FieldIsKYC)
	}
	if m._UpdateDate != nil {
		fields = append(fields, userwallet.FieldUpdateDate)
	}
	if m._OccupationId != nil {
		fields = append(fields, userwallet.FieldOccupationId)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserwalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userwallet.FieldWalletid:
		return m.Walletid()
	case userwallet.FieldWalletTypeName:
		return m.WalletTypeName()
	case userwallet.FieldWalletPhoneno:
		return m.WalletPhoneno()
	case userwallet.FieldWalletName:
		return m.WalletName()
	case userwallet.FieldCitizenId:
		return m.CitizenId()
	case userwallet.FieldStatus:
		return m.Status()
	case userwallet.FieldRegisterDate:
		return m.RegisterDate()
	case userwallet.FieldGroupUser:
		return m.GroupUser()
	case userwallet.FieldUserAgent:
		return m.UserAgent()
	case userwallet.FieldKYCDate:
		return m.KYCDate()
	case userwallet.FieldATMCard:
		return m.ATMCard()
	case userwallet.FieldAccountNo:
		return m.AccountNo()
	case userwallet.FieldAddressDetail:
		return m.AddressDetail()
	case userwallet.FieldStreet:
		return m.Street()
	case userwallet.FieldDistrict:
		return m.District()
	case userwallet.FieldSubDistrict:
		return m.SubDistrict()
	case userwallet.FieldProvince:
		return m.Province()
	case userwallet.FieldPostalCode:
		return m.PostalCode()
	case userwallet.FieldIsKYC:
		return m.IsKYC()
	case userwallet.FieldUpdateDate:
		return m.UpdateDate()
	case userwallet.FieldOccupationId:
		return m.OccupationId()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserwalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userwallet.FieldWalletid:
		return m.OldWalletid(ctx)
	case userwallet.FieldWalletTypeName:
		return m.OldWalletTypeName(ctx)
	case userwallet.FieldWalletPhoneno:
		return m.OldWalletPhoneno(ctx)
	case userwallet.FieldWalletName:
		return m.OldWalletName(ctx)
	case userwallet.FieldCitizenId:
		return m.OldCitizenId(ctx)
	case userwallet.FieldStatus:
		return m.OldStatus(ctx)
	case userwallet.FieldRegisterDate:
		return m.OldRegisterDate(ctx)
	case userwallet.FieldGroupUser:
		return m.OldGroupUser(ctx)
	case userwallet.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case userwallet.FieldKYCDate:
		return m.OldKYCDate(ctx)
	case userwallet.FieldATMCard:
		return m.OldATMCard(ctx)
	case userwallet.FieldAccountNo:
		return m.OldAccountNo(ctx)
	case userwallet.FieldAddressDetail:
		return m.OldAddressDetail(ctx)
	case userwallet.FieldStreet:
		return m.OldStreet(ctx)
	case userwallet.FieldDistrict:
		return m.OldDistrict(ctx)
	case userwallet.FieldSubDistrict:
		return m.OldSubDistrict(ctx)
	case userwallet.FieldProvince:
		return m.OldProvince(ctx)
	case userwallet.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case userwallet.FieldIsKYC:
		return m.OldIsKYC(ctx)
	case userwallet.FieldUpdateDate:
		return m.OldUpdateDate(ctx)
	case userwallet.FieldOccupationId:
		return m.OldOccupationId(ctx)
	}
	return nil, fmt.Errorf("unknown Userwallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserwalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userwallet.FieldWalletid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletid(v)
		return nil
	case userwallet.FieldWalletTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletTypeName(v)
		return nil
	case userwallet.FieldWalletPhoneno:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletPhoneno(v)
		return nil
	case userwallet.FieldWalletName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWalletName(v)
		return nil
	case userwallet.FieldCitizenId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCitizenId(v)
		return nil
	case userwallet.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case userwallet.FieldRegisterDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegisterDate(v)
		return nil
	case userwallet.FieldGroupUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupUser(v)
		return nil
	case userwallet.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case userwallet.FieldKYCDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKYCDate(v)
		return nil
	case userwallet.FieldATMCard:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetATMCard(v)
		return nil
	case userwallet.FieldAccountNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountNo(v)
		return nil
	case userwallet.FieldAddressDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressDetail(v)
		return nil
	case userwallet.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case userwallet.FieldDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDistrict(v)
		return nil
	case userwallet.FieldSubDistrict:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubDistrict(v)
		return nil
	case userwallet.FieldProvince:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvince(v)
		return nil
	case userwallet.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case userwallet.FieldIsKYC:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsKYC(v)
		return nil
	case userwallet.FieldUpdateDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateDate(v)
		return nil
	case userwallet.FieldOccupationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOccupationId(v)
		return nil
	}
	return fmt.Errorf("unknown Userwallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserwalletMutation) AddedFields() []string {
	var fields []string
	if m.add_GroupUser != nil {
		fields = append(fields, userwallet.FieldGroupUser)
	}
	if m.add_OccupationId != nil {
		fields = append(fields, userwallet.FieldOccupationId)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserwalletMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case userwallet.FieldGroupUser:
		return m.AddedGroupUser()
	case userwallet.FieldOccupationId:
		return m.AddedOccupationId()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserwalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	case userwallet.FieldGroupUser:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupUser(v)
		return nil
	case userwallet.FieldOccupationId:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOccupationId(v)
		return nil
	}
	return fmt.Errorf("unknown Userwallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserwalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userwallet.FieldWalletTypeName) {
		fields = append(fields, userwallet.FieldWalletTypeName)
	}
	if m.FieldCleared(userwallet.FieldWalletPhoneno) {
		fields = append(fields, userwallet.FieldWalletPhoneno)
	}
	if m.FieldCleared(userwallet.FieldWalletName) {
		fields = append(fields, userwallet.FieldWalletName)
	}
	if m.FieldCleared(userwallet.FieldCitizenId) {
		fields = append(fields, userwallet.FieldCitizenId)
	}
	if m.FieldCleared(userwallet.FieldStatus) {
		fields = append(fields, userwallet.FieldStatus)
	}
	if m.FieldCleared(userwallet.FieldRegisterDate) {
		fields = append(fields, userwallet.FieldRegisterDate)
	}
	if m.FieldCleared(userwallet.FieldGroupUser) {
		fields = append(fields, userwallet.FieldGroupUser)
	}
	if m.FieldCleared(userwallet.FieldUserAgent) {
		fields = append(fields, userwallet.FieldUserAgent)
	}
	if m.FieldCleared(userwallet.FieldKYCDate) {
		fields = append(fields, userwallet.FieldKYCDate)
	}
	if m.FieldCleared(userwallet.FieldATMCard) {
		fields = append(fields, userwallet.FieldATMCard)
	}
	if m.FieldCleared(userwallet.FieldAccountNo) {
		fields = append(fields, userwallet.FieldAccountNo)
	}
	if m.FieldCleared(userwallet.FieldAddressDetail) {
		fields = append(fields, userwallet.FieldAddressDetail)
	}
	if m.FieldCleared(userwallet.FieldStreet) {
		fields = append(fields, userwallet.FieldStreet)
	}
	if m.FieldCleared(userwallet.FieldDistrict) {
		fields = append(fields, userwallet.FieldDistrict)
	}
	if m.FieldCleared(userwallet.FieldSubDistrict) {
		fields = append(fields, userwallet.FieldSubDistrict)
	}
	if m.FieldCleared(userwallet.FieldProvince) {
		fields = append(fields, userwallet.FieldProvince)
	}
	if m.FieldCleared(userwallet.FieldPostalCode) {
		fields = append(fields, userwallet.FieldPostalCode)
	}
	if m.FieldCleared(userwallet.FieldIsKYC) {
		fields = append(fields, userwallet.FieldIsKYC)
	}
	if m.FieldCleared(userwallet.FieldUpdateDate) {
		fields = append(fields, userwallet.FieldUpdateDate)
	}
	if m.FieldCleared(userwallet.FieldOccupationId) {
		fields = append(fields, userwallet.FieldOccupationId)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserwalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserwalletMutation) ClearField(name string) error {
	switch name {
	case userwallet.FieldWalletTypeName:
		m.ClearWalletTypeName()
		return nil
	case userwallet.FieldWalletPhoneno:
		m.ClearWalletPhoneno()
		return nil
	case userwallet.FieldWalletName:
		m.ClearWalletName()
		return nil
	case userwallet.FieldCitizenId:
		m.ClearCitizenId()
		return nil
	case userwallet.FieldStatus:
		m.ClearStatus()
		return nil
	case userwallet.FieldRegisterDate:
		m.ClearRegisterDate()
		return nil
	case userwallet.FieldGroupUser:
		m.ClearGroupUser()
		return nil
	case userwallet.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case userwallet.FieldKYCDate:
		m.ClearKYCDate()
		return nil
	case userwallet.FieldATMCard:
		m.ClearATMCard()
		return nil
	case userwallet.FieldAccountNo:
		m.ClearAccountNo()
		return nil
	case userwallet.FieldAddressDetail:
		m.ClearAddressDetail()
		return nil
	case userwallet.FieldStreet:
		m.ClearStreet()
		return nil
	case userwallet.FieldDistrict:
		m.ClearDistrict()
		return nil
	case userwallet.FieldSubDistrict:
		m.ClearSubDistrict()
		return nil
	case userwallet.FieldProvince:
		m.ClearProvince()
		return nil
	case userwallet.FieldPostalCode:
		m.ClearPostalCode()
		return nil
	case userwallet.FieldIsKYC:
		m.ClearIsKYC()
		return nil
	case userwallet.FieldUpdateDate:
		m.ClearUpdateDate()
		return nil
	case userwallet.FieldOccupationId:
		m.ClearOccupationId()
		return nil
	}
	return fmt.Errorf("unknown Userwallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserwalletMutation) ResetField(name string) error {
	switch name {
	case userwallet.FieldWalletid:
		m.ResetWalletid()
		return nil
	case userwallet.FieldWalletTypeName:
		m.ResetWalletTypeName()
		return nil
	case userwallet.FieldWalletPhoneno:
		m.ResetWalletPhoneno()
		return nil
	case userwallet.FieldWalletName:
		m.ResetWalletName()
		return nil
	case userwallet.FieldCitizenId:
		m.ResetCitizenId()
		return nil
	case userwallet.FieldStatus:
		m.ResetStatus()
		return nil
	case userwallet.FieldRegisterDate:
		m.ResetRegisterDate()
		return nil
	case userwallet.FieldGroupUser:
		m.ResetGroupUser()
		return nil
	case userwallet.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case userwallet.FieldKYCDate:
		m.ResetKYCDate()
		return nil
	case userwallet.FieldATMCard:
		m.ResetATMCard()
		return nil
	case userwallet.FieldAccountNo:
		m.ResetAccountNo()
		return nil
	case userwallet.FieldAddressDetail:
		m.ResetAddressDetail()
		return nil
	case userwallet.FieldStreet:
		m.ResetStreet()
		return nil
	case userwallet.FieldDistrict:
		m.ResetDistrict()
		return nil
	case userwallet.FieldSubDistrict:
		m.ResetSubDistrict()
		return nil
	case userwallet.FieldProvince:
		m.ResetProvince()
		return nil
	case userwallet.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case userwallet.FieldIsKYC:
		m.ResetIsKYC()
		return nil
	case userwallet.FieldUpdateDate:
		m.ResetUpdateDate()
		return nil
	case userwallet.FieldOccupationId:
		m.ResetOccupationId()
		return nil
	}
	return fmt.Errorf("unknown Userwallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserwalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserwalletMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserwalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserwalletMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserwalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserwalletMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserwalletMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Userwallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserwalletMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Userwallet edge %s", name)
}

// WatchlistMutation represents an operation that mutates the Watchlist nodes in the graph.
type WatchlistMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Name             *string
	_TaxID            *string
	_RankWatchlist    *int
	add_RankWatchlist *int
	_FileimportID     *int
	add_FileimportID  *int
	_IsDeleted        *bool
	_ImportDate       *time.Time
	_UserUpload       *string
	clearedFields     map[string]struct{}
	related           *int
	clearedrelated    bool
	done              bool
	oldValue          func(context.Context) (*Watchlist, error)
	predicates        []predicate.Watchlist
}

var _ ent.Mutation = (*WatchlistMutation)(nil)

// watchlistOption allows management of the mutation configuration using functional options.
type watchlistOption func(*WatchlistMutation)

// newWatchlistMutation creates new mutation for the Watchlist entity.
func newWatchlistMutation(c config, op Op, opts ...watchlistOption) *WatchlistMutation {
	m := &WatchlistMutation{
		config:        c,
		op:            op,
		typ:           TypeWatchlist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWatchlistID sets the ID field of the mutation.
func withWatchlistID(id int) watchlistOption {
	return func(m *WatchlistMutation) {
		var (
			err   error
			once  sync.Once
			value *Watchlist
		)
		m.oldValue = func(ctx context.Context) (*Watchlist, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Watchlist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWatchlist sets the old Watchlist of the mutation.
func withWatchlist(node *Watchlist) watchlistOption {
	return func(m *WatchlistMutation) {
		m.oldValue = func(context.Context) (*Watchlist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WatchlistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WatchlistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Watchlist entities.
func (m *WatchlistMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WatchlistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "Name" field.
func (m *WatchlistMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *WatchlistMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *WatchlistMutation) ResetName() {
	m._Name = nil
}

// SetTaxID sets the "TaxID" field.
func (m *WatchlistMutation) SetTaxID(s string) {
	m._TaxID = &s
}

// TaxID returns the value of the "TaxID" field in the mutation.
func (m *WatchlistMutation) TaxID() (r string, exists bool) {
	v := m._TaxID
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "TaxID" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ResetTaxID resets all changes to the "TaxID" field.
func (m *WatchlistMutation) ResetTaxID() {
	m._TaxID = nil
}

// SetRankWatchlist sets the "RankWatchlist" field.
func (m *WatchlistMutation) SetRankWatchlist(i int) {
	m._RankWatchlist = &i
	m.add_RankWatchlist = nil
}

// RankWatchlist returns the value of the "RankWatchlist" field in the mutation.
func (m *WatchlistMutation) RankWatchlist() (r int, exists bool) {
	v := m._RankWatchlist
	if v == nil {
		return
	}
	return *v, true
}

// OldRankWatchlist returns the old "RankWatchlist" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldRankWatchlist(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankWatchlist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankWatchlist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankWatchlist: %w", err)
	}
	return oldValue.RankWatchlist, nil
}

// AddRankWatchlist adds i to the "RankWatchlist" field.
func (m *WatchlistMutation) AddRankWatchlist(i int) {
	if m.add_RankWatchlist != nil {
		*m.add_RankWatchlist += i
	} else {
		m.add_RankWatchlist = &i
	}
}

// AddedRankWatchlist returns the value that was added to the "RankWatchlist" field in this mutation.
func (m *WatchlistMutation) AddedRankWatchlist() (r int, exists bool) {
	v := m.add_RankWatchlist
	if v == nil {
		return
	}
	return *v, true
}

// ClearRankWatchlist clears the value of the "RankWatchlist" field.
func (m *WatchlistMutation) ClearRankWatchlist() {
	m._RankWatchlist = nil
	m.add_RankWatchlist = nil
	m.clearedFields[watchlist.FieldRankWatchlist] = struct{}{}
}

// RankWatchlistCleared returns if the "RankWatchlist" field was cleared in this mutation.
func (m *WatchlistMutation) RankWatchlistCleared() bool {
	_, ok := m.clearedFields[watchlist.FieldRankWatchlist]
	return ok
}

// ResetRankWatchlist resets all changes to the "RankWatchlist" field.
func (m *WatchlistMutation) ResetRankWatchlist() {
	m._RankWatchlist = nil
	m.add_RankWatchlist = nil
	delete(m.clearedFields, watchlist.FieldRankWatchlist)
}

// SetFileimportID sets the "FileimportID" field.
func (m *WatchlistMutation) SetFileimportID(i int) {
	m._FileimportID = &i
	m.add_FileimportID = nil
}

// FileimportID returns the value of the "FileimportID" field in the mutation.
func (m *WatchlistMutation) FileimportID() (r int, exists bool) {
	v := m._FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// OldFileimportID returns the old "FileimportID" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldFileimportID(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFileimportID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFileimportID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileimportID: %w", err)
	}
	return oldValue.FileimportID, nil
}

// AddFileimportID adds i to the "FileimportID" field.
func (m *WatchlistMutation) AddFileimportID(i int) {
	if m.add_FileimportID != nil {
		*m.add_FileimportID += i
	} else {
		m.add_FileimportID = &i
	}
}

// AddedFileimportID returns the value that was added to the "FileimportID" field in this mutation.
func (m *WatchlistMutation) AddedFileimportID() (r int, exists bool) {
	v := m.add_FileimportID
	if v == nil {
		return
	}
	return *v, true
}

// ClearFileimportID clears the value of the "FileimportID" field.
func (m *WatchlistMutation) ClearFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	m.clearedFields[watchlist.FieldFileimportID] = struct{}{}
}

// FileimportIDCleared returns if the "FileimportID" field was cleared in this mutation.
func (m *WatchlistMutation) FileimportIDCleared() bool {
	_, ok := m.clearedFields[watchlist.FieldFileimportID]
	return ok
}

// ResetFileimportID resets all changes to the "FileimportID" field.
func (m *WatchlistMutation) ResetFileimportID() {
	m._FileimportID = nil
	m.add_FileimportID = nil
	delete(m.clearedFields, watchlist.FieldFileimportID)
}

// SetIsDeleted sets the "IsDeleted" field.
func (m *WatchlistMutation) SetIsDeleted(b bool) {
	m._IsDeleted = &b
}

// IsDeleted returns the value of the "IsDeleted" field in the mutation.
func (m *WatchlistMutation) IsDeleted() (r bool, exists bool) {
	v := m._IsDeleted
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDeleted returns the old "IsDeleted" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldIsDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldIsDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldIsDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDeleted: %w", err)
	}
	return oldValue.IsDeleted, nil
}

// ClearIsDeleted clears the value of the "IsDeleted" field.
func (m *WatchlistMutation) ClearIsDeleted() {
	m._IsDeleted = nil
	m.clearedFields[watchlist.FieldIsDeleted] = struct{}{}
}

// IsDeletedCleared returns if the "IsDeleted" field was cleared in this mutation.
func (m *WatchlistMutation) IsDeletedCleared() bool {
	_, ok := m.clearedFields[watchlist.FieldIsDeleted]
	return ok
}

// ResetIsDeleted resets all changes to the "IsDeleted" field.
func (m *WatchlistMutation) ResetIsDeleted() {
	m._IsDeleted = nil
	delete(m.clearedFields, watchlist.FieldIsDeleted)
}

// SetImportDate sets the "ImportDate" field.
func (m *WatchlistMutation) SetImportDate(t time.Time) {
	m._ImportDate = &t
}

// ImportDate returns the value of the "ImportDate" field in the mutation.
func (m *WatchlistMutation) ImportDate() (r time.Time, exists bool) {
	v := m._ImportDate
	if v == nil {
		return
	}
	return *v, true
}

// OldImportDate returns the old "ImportDate" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldImportDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldImportDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldImportDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImportDate: %w", err)
	}
	return oldValue.ImportDate, nil
}

// ClearImportDate clears the value of the "ImportDate" field.
func (m *WatchlistMutation) ClearImportDate() {
	m._ImportDate = nil
	m.clearedFields[watchlist.FieldImportDate] = struct{}{}
}

// ImportDateCleared returns if the "ImportDate" field was cleared in this mutation.
func (m *WatchlistMutation) ImportDateCleared() bool {
	_, ok := m.clearedFields[watchlist.FieldImportDate]
	return ok
}

// ResetImportDate resets all changes to the "ImportDate" field.
func (m *WatchlistMutation) ResetImportDate() {
	m._ImportDate = nil
	delete(m.clearedFields, watchlist.FieldImportDate)
}

// SetUserUpload sets the "UserUpload" field.
func (m *WatchlistMutation) SetUserUpload(s string) {
	m._UserUpload = &s
}

// UserUpload returns the value of the "UserUpload" field in the mutation.
func (m *WatchlistMutation) UserUpload() (r string, exists bool) {
	v := m._UserUpload
	if v == nil {
		return
	}
	return *v, true
}

// OldUserUpload returns the old "UserUpload" field's value of the Watchlist entity.
// If the Watchlist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlistMutation) OldUserUpload(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserUpload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserUpload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserUpload: %w", err)
	}
	return oldValue.UserUpload, nil
}

// ClearUserUpload clears the value of the "UserUpload" field.
func (m *WatchlistMutation) ClearUserUpload() {
	m._UserUpload = nil
	m.clearedFields[watchlist.FieldUserUpload] = struct{}{}
}

// UserUploadCleared returns if the "UserUpload" field was cleared in this mutation.
func (m *WatchlistMutation) UserUploadCleared() bool {
	_, ok := m.clearedFields[watchlist.FieldUserUpload]
	return ok
}

// ResetUserUpload resets all changes to the "UserUpload" field.
func (m *WatchlistMutation) ResetUserUpload() {
	m._UserUpload = nil
	delete(m.clearedFields, watchlist.FieldUserUpload)
}

// SetRelatedID sets the "related" edge to the Watchlisttype entity by id.
func (m *WatchlistMutation) SetRelatedID(id int) {
	m.related = &id
}

// ClearRelated clears the "related" edge to the Watchlisttype entity.
func (m *WatchlistMutation) ClearRelated() {
	m.clearedrelated = true
}

// RelatedCleared returns if the "related" edge to the Watchlisttype entity was cleared.
func (m *WatchlistMutation) RelatedCleared() bool {
	return m.clearedrelated
}

// RelatedID returns the "related" edge ID in the mutation.
func (m *WatchlistMutation) RelatedID() (id int, exists bool) {
	if m.related != nil {
		return *m.related, true
	}
	return
}

// RelatedIDs returns the "related" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RelatedID instead. It exists only for internal usage by the builders.
func (m *WatchlistMutation) RelatedIDs() (ids []int) {
	if id := m.related; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRelated resets all changes to the "related" edge.
func (m *WatchlistMutation) ResetRelated() {
	m.related = nil
	m.clearedrelated = false
}

// Op returns the operation name.
func (m *WatchlistMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Watchlist).
func (m *WatchlistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WatchlistMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._Name != nil {
		fields = append(fields, watchlist.FieldName)
	}
	if m._TaxID != nil {
		fields = append(fields, watchlist.FieldTaxID)
	}
	if m._RankWatchlist != nil {
		fields = append(fields, watchlist.FieldRankWatchlist)
	}
	if m._FileimportID != nil {
		fields = append(fields, watchlist.FieldFileimportID)
	}
	if m._IsDeleted != nil {
		fields = append(fields, watchlist.FieldIsDeleted)
	}
	if m._ImportDate != nil {
		fields = append(fields, watchlist.FieldImportDate)
	}
	if m._UserUpload != nil {
		fields = append(fields, watchlist.FieldUserUpload)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WatchlistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case watchlist.FieldName:
		return m.Name()
	case watchlist.FieldTaxID:
		return m.TaxID()
	case watchlist.FieldRankWatchlist:
		return m.RankWatchlist()
	case watchlist.FieldFileimportID:
		return m.FileimportID()
	case watchlist.FieldIsDeleted:
		return m.IsDeleted()
	case watchlist.FieldImportDate:
		return m.ImportDate()
	case watchlist.FieldUserUpload:
		return m.UserUpload()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WatchlistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case watchlist.FieldName:
		return m.OldName(ctx)
	case watchlist.FieldTaxID:
		return m.OldTaxID(ctx)
	case watchlist.FieldRankWatchlist:
		return m.OldRankWatchlist(ctx)
	case watchlist.FieldFileimportID:
		return m.OldFileimportID(ctx)
	case watchlist.FieldIsDeleted:
		return m.OldIsDeleted(ctx)
	case watchlist.FieldImportDate:
		return m.OldImportDate(ctx)
	case watchlist.FieldUserUpload:
		return m.OldUserUpload(ctx)
	}
	return nil, fmt.Errorf("unknown Watchlist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case watchlist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case watchlist.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case watchlist.FieldRankWatchlist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankWatchlist(v)
		return nil
	case watchlist.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileimportID(v)
		return nil
	case watchlist.FieldIsDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDeleted(v)
		return nil
	case watchlist.FieldImportDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImportDate(v)
		return nil
	case watchlist.FieldUserUpload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserUpload(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WatchlistMutation) AddedFields() []string {
	var fields []string
	if m.add_RankWatchlist != nil {
		fields = append(fields, watchlist.FieldRankWatchlist)
	}
	if m.add_FileimportID != nil {
		fields = append(fields, watchlist.FieldFileimportID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WatchlistMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case watchlist.FieldRankWatchlist:
		return m.AddedRankWatchlist()
	case watchlist.FieldFileimportID:
		return m.AddedFileimportID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlistMutation) AddField(name string, value ent.Value) error {
	switch name {
	case watchlist.FieldRankWatchlist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRankWatchlist(v)
		return nil
	case watchlist.FieldFileimportID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileimportID(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WatchlistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(watchlist.FieldRankWatchlist) {
		fields = append(fields, watchlist.FieldRankWatchlist)
	}
	if m.FieldCleared(watchlist.FieldFileimportID) {
		fields = append(fields, watchlist.FieldFileimportID)
	}
	if m.FieldCleared(watchlist.FieldIsDeleted) {
		fields = append(fields, watchlist.FieldIsDeleted)
	}
	if m.FieldCleared(watchlist.FieldImportDate) {
		fields = append(fields, watchlist.FieldImportDate)
	}
	if m.FieldCleared(watchlist.FieldUserUpload) {
		fields = append(fields, watchlist.FieldUserUpload)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WatchlistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WatchlistMutation) ClearField(name string) error {
	switch name {
	case watchlist.FieldRankWatchlist:
		m.ClearRankWatchlist()
		return nil
	case watchlist.FieldFileimportID:
		m.ClearFileimportID()
		return nil
	case watchlist.FieldIsDeleted:
		m.ClearIsDeleted()
		return nil
	case watchlist.FieldImportDate:
		m.ClearImportDate()
		return nil
	case watchlist.FieldUserUpload:
		m.ClearUserUpload()
		return nil
	}
	return fmt.Errorf("unknown Watchlist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WatchlistMutation) ResetField(name string) error {
	switch name {
	case watchlist.FieldName:
		m.ResetName()
		return nil
	case watchlist.FieldTaxID:
		m.ResetTaxID()
		return nil
	case watchlist.FieldRankWatchlist:
		m.ResetRankWatchlist()
		return nil
	case watchlist.FieldFileimportID:
		m.ResetFileimportID()
		return nil
	case watchlist.FieldIsDeleted:
		m.ResetIsDeleted()
		return nil
	case watchlist.FieldImportDate:
		m.ResetImportDate()
		return nil
	case watchlist.FieldUserUpload:
		m.ResetUserUpload()
		return nil
	}
	return fmt.Errorf("unknown Watchlist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WatchlistMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.related != nil {
		edges = append(edges, watchlist.EdgeRelated)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WatchlistMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case watchlist.EdgeRelated:
		if id := m.related; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WatchlistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WatchlistMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WatchlistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedrelated {
		edges = append(edges, watchlist.EdgeRelated)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WatchlistMutation) EdgeCleared(name string) bool {
	switch name {
	case watchlist.EdgeRelated:
		return m.clearedrelated
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WatchlistMutation) ClearEdge(name string) error {
	switch name {
	case watchlist.EdgeRelated:
		m.ClearRelated()
		return nil
	}
	return fmt.Errorf("unknown Watchlist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WatchlistMutation) ResetEdge(name string) error {
	switch name {
	case watchlist.EdgeRelated:
		m.ResetRelated()
		return nil
	}
	return fmt.Errorf("unknown Watchlist edge %s", name)
}

// WatchlisthistoryMutation represents an operation that mutates the Watchlisthistory nodes in the graph.
type WatchlisthistoryMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Name             *string
	_TaxID            *string
	_TypeName         *string
	_RankWatchlist    *int
	add_RankWatchlist *int
	_StatusDel        *int
	add_StatusDel     *int
	_DateCalRank      *time.Time
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Watchlisthistory, error)
	predicates        []predicate.Watchlisthistory
}

var _ ent.Mutation = (*WatchlisthistoryMutation)(nil)

// watchlisthistoryOption allows management of the mutation configuration using functional options.
type watchlisthistoryOption func(*WatchlisthistoryMutation)

// newWatchlisthistoryMutation creates new mutation for the Watchlisthistory entity.
func newWatchlisthistoryMutation(c config, op Op, opts ...watchlisthistoryOption) *WatchlisthistoryMutation {
	m := &WatchlisthistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeWatchlisthistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWatchlisthistoryID sets the ID field of the mutation.
func withWatchlisthistoryID(id int) watchlisthistoryOption {
	return func(m *WatchlisthistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *Watchlisthistory
		)
		m.oldValue = func(ctx context.Context) (*Watchlisthistory, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Watchlisthistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWatchlisthistory sets the old Watchlisthistory of the mutation.
func withWatchlisthistory(node *Watchlisthistory) watchlisthistoryOption {
	return func(m *WatchlisthistoryMutation) {
		m.oldValue = func(context.Context) (*Watchlisthistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WatchlisthistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WatchlisthistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Watchlisthistory entities.
func (m *WatchlisthistoryMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WatchlisthistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "Name" field.
func (m *WatchlisthistoryMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the value of the "Name" field in the mutation.
func (m *WatchlisthistoryMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "Name" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "Name" field.
func (m *WatchlisthistoryMutation) ResetName() {
	m._Name = nil
}

// SetTaxID sets the "TaxID" field.
func (m *WatchlisthistoryMutation) SetTaxID(s string) {
	m._TaxID = &s
}

// TaxID returns the value of the "TaxID" field in the mutation.
func (m *WatchlisthistoryMutation) TaxID() (r string, exists bool) {
	v := m._TaxID
	if v == nil {
		return
	}
	return *v, true
}

// OldTaxID returns the old "TaxID" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldTaxID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaxID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaxID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaxID: %w", err)
	}
	return oldValue.TaxID, nil
}

// ResetTaxID resets all changes to the "TaxID" field.
func (m *WatchlisthistoryMutation) ResetTaxID() {
	m._TaxID = nil
}

// SetTypeName sets the "TypeName" field.
func (m *WatchlisthistoryMutation) SetTypeName(s string) {
	m._TypeName = &s
}

// TypeName returns the value of the "TypeName" field in the mutation.
func (m *WatchlisthistoryMutation) TypeName() (r string, exists bool) {
	v := m._TypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "TypeName" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "TypeName" field.
func (m *WatchlisthistoryMutation) ResetTypeName() {
	m._TypeName = nil
}

// SetRankWatchlist sets the "RankWatchlist" field.
func (m *WatchlisthistoryMutation) SetRankWatchlist(i int) {
	m._RankWatchlist = &i
	m.add_RankWatchlist = nil
}

// RankWatchlist returns the value of the "RankWatchlist" field in the mutation.
func (m *WatchlisthistoryMutation) RankWatchlist() (r int, exists bool) {
	v := m._RankWatchlist
	if v == nil {
		return
	}
	return *v, true
}

// OldRankWatchlist returns the old "RankWatchlist" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldRankWatchlist(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRankWatchlist is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRankWatchlist requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRankWatchlist: %w", err)
	}
	return oldValue.RankWatchlist, nil
}

// AddRankWatchlist adds i to the "RankWatchlist" field.
func (m *WatchlisthistoryMutation) AddRankWatchlist(i int) {
	if m.add_RankWatchlist != nil {
		*m.add_RankWatchlist += i
	} else {
		m.add_RankWatchlist = &i
	}
}

// AddedRankWatchlist returns the value that was added to the "RankWatchlist" field in this mutation.
func (m *WatchlisthistoryMutation) AddedRankWatchlist() (r int, exists bool) {
	v := m.add_RankWatchlist
	if v == nil {
		return
	}
	return *v, true
}

// ClearRankWatchlist clears the value of the "RankWatchlist" field.
func (m *WatchlisthistoryMutation) ClearRankWatchlist() {
	m._RankWatchlist = nil
	m.add_RankWatchlist = nil
	m.clearedFields[watchlisthistory.FieldRankWatchlist] = struct{}{}
}

// RankWatchlistCleared returns if the "RankWatchlist" field was cleared in this mutation.
func (m *WatchlisthistoryMutation) RankWatchlistCleared() bool {
	_, ok := m.clearedFields[watchlisthistory.FieldRankWatchlist]
	return ok
}

// ResetRankWatchlist resets all changes to the "RankWatchlist" field.
func (m *WatchlisthistoryMutation) ResetRankWatchlist() {
	m._RankWatchlist = nil
	m.add_RankWatchlist = nil
	delete(m.clearedFields, watchlisthistory.FieldRankWatchlist)
}

// SetStatusDel sets the "StatusDel" field.
func (m *WatchlisthistoryMutation) SetStatusDel(i int) {
	m._StatusDel = &i
	m.add_StatusDel = nil
}

// StatusDel returns the value of the "StatusDel" field in the mutation.
func (m *WatchlisthistoryMutation) StatusDel() (r int, exists bool) {
	v := m._StatusDel
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDel returns the old "StatusDel" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldStatusDel(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDel: %w", err)
	}
	return oldValue.StatusDel, nil
}

// AddStatusDel adds i to the "StatusDel" field.
func (m *WatchlisthistoryMutation) AddStatusDel(i int) {
	if m.add_StatusDel != nil {
		*m.add_StatusDel += i
	} else {
		m.add_StatusDel = &i
	}
}

// AddedStatusDel returns the value that was added to the "StatusDel" field in this mutation.
func (m *WatchlisthistoryMutation) AddedStatusDel() (r int, exists bool) {
	v := m.add_StatusDel
	if v == nil {
		return
	}
	return *v, true
}

// ClearStatusDel clears the value of the "StatusDel" field.
func (m *WatchlisthistoryMutation) ClearStatusDel() {
	m._StatusDel = nil
	m.add_StatusDel = nil
	m.clearedFields[watchlisthistory.FieldStatusDel] = struct{}{}
}

// StatusDelCleared returns if the "StatusDel" field was cleared in this mutation.
func (m *WatchlisthistoryMutation) StatusDelCleared() bool {
	_, ok := m.clearedFields[watchlisthistory.FieldStatusDel]
	return ok
}

// ResetStatusDel resets all changes to the "StatusDel" field.
func (m *WatchlisthistoryMutation) ResetStatusDel() {
	m._StatusDel = nil
	m.add_StatusDel = nil
	delete(m.clearedFields, watchlisthistory.FieldStatusDel)
}

// SetDateCalRank sets the "DateCalRank" field.
func (m *WatchlisthistoryMutation) SetDateCalRank(t time.Time) {
	m._DateCalRank = &t
}

// DateCalRank returns the value of the "DateCalRank" field in the mutation.
func (m *WatchlisthistoryMutation) DateCalRank() (r time.Time, exists bool) {
	v := m._DateCalRank
	if v == nil {
		return
	}
	return *v, true
}

// OldDateCalRank returns the old "DateCalRank" field's value of the Watchlisthistory entity.
// If the Watchlisthistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisthistoryMutation) OldDateCalRank(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDateCalRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDateCalRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateCalRank: %w", err)
	}
	return oldValue.DateCalRank, nil
}

// ClearDateCalRank clears the value of the "DateCalRank" field.
func (m *WatchlisthistoryMutation) ClearDateCalRank() {
	m._DateCalRank = nil
	m.clearedFields[watchlisthistory.FieldDateCalRank] = struct{}{}
}

// DateCalRankCleared returns if the "DateCalRank" field was cleared in this mutation.
func (m *WatchlisthistoryMutation) DateCalRankCleared() bool {
	_, ok := m.clearedFields[watchlisthistory.FieldDateCalRank]
	return ok
}

// ResetDateCalRank resets all changes to the "DateCalRank" field.
func (m *WatchlisthistoryMutation) ResetDateCalRank() {
	m._DateCalRank = nil
	delete(m.clearedFields, watchlisthistory.FieldDateCalRank)
}

// Op returns the operation name.
func (m *WatchlisthistoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Watchlisthistory).
func (m *WatchlisthistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WatchlisthistoryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._Name != nil {
		fields = append(fields, watchlisthistory.FieldName)
	}
	if m._TaxID != nil {
		fields = append(fields, watchlisthistory.FieldTaxID)
	}
	if m._TypeName != nil {
		fields = append(fields, watchlisthistory.FieldTypeName)
	}
	if m._RankWatchlist != nil {
		fields = append(fields, watchlisthistory.FieldRankWatchlist)
	}
	if m._StatusDel != nil {
		fields = append(fields, watchlisthistory.FieldStatusDel)
	}
	if m._DateCalRank != nil {
		fields = append(fields, watchlisthistory.FieldDateCalRank)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WatchlisthistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case watchlisthistory.FieldName:
		return m.Name()
	case watchlisthistory.FieldTaxID:
		return m.TaxID()
	case watchlisthistory.FieldTypeName:
		return m.TypeName()
	case watchlisthistory.FieldRankWatchlist:
		return m.RankWatchlist()
	case watchlisthistory.FieldStatusDel:
		return m.StatusDel()
	case watchlisthistory.FieldDateCalRank:
		return m.DateCalRank()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WatchlisthistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case watchlisthistory.FieldName:
		return m.OldName(ctx)
	case watchlisthistory.FieldTaxID:
		return m.OldTaxID(ctx)
	case watchlisthistory.FieldTypeName:
		return m.OldTypeName(ctx)
	case watchlisthistory.FieldRankWatchlist:
		return m.OldRankWatchlist(ctx)
	case watchlisthistory.FieldStatusDel:
		return m.OldStatusDel(ctx)
	case watchlisthistory.FieldDateCalRank:
		return m.OldDateCalRank(ctx)
	}
	return nil, fmt.Errorf("unknown Watchlisthistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlisthistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case watchlisthistory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case watchlisthistory.FieldTaxID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaxID(v)
		return nil
	case watchlisthistory.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case watchlisthistory.FieldRankWatchlist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRankWatchlist(v)
		return nil
	case watchlisthistory.FieldStatusDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDel(v)
		return nil
	case watchlisthistory.FieldDateCalRank:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateCalRank(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlisthistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WatchlisthistoryMutation) AddedFields() []string {
	var fields []string
	if m.add_RankWatchlist != nil {
		fields = append(fields, watchlisthistory.FieldRankWatchlist)
	}
	if m.add_StatusDel != nil {
		fields = append(fields, watchlisthistory.FieldStatusDel)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WatchlisthistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case watchlisthistory.FieldRankWatchlist:
		return m.AddedRankWatchlist()
	case watchlisthistory.FieldStatusDel:
		return m.AddedStatusDel()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlisthistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case watchlisthistory.FieldRankWatchlist:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRankWatchlist(v)
		return nil
	case watchlisthistory.FieldStatusDel:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatusDel(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlisthistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WatchlisthistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(watchlisthistory.FieldRankWatchlist) {
		fields = append(fields, watchlisthistory.FieldRankWatchlist)
	}
	if m.FieldCleared(watchlisthistory.FieldStatusDel) {
		fields = append(fields, watchlisthistory.FieldStatusDel)
	}
	if m.FieldCleared(watchlisthistory.FieldDateCalRank) {
		fields = append(fields, watchlisthistory.FieldDateCalRank)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WatchlisthistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WatchlisthistoryMutation) ClearField(name string) error {
	switch name {
	case watchlisthistory.FieldRankWatchlist:
		m.ClearRankWatchlist()
		return nil
	case watchlisthistory.FieldStatusDel:
		m.ClearStatusDel()
		return nil
	case watchlisthistory.FieldDateCalRank:
		m.ClearDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Watchlisthistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WatchlisthistoryMutation) ResetField(name string) error {
	switch name {
	case watchlisthistory.FieldName:
		m.ResetName()
		return nil
	case watchlisthistory.FieldTaxID:
		m.ResetTaxID()
		return nil
	case watchlisthistory.FieldTypeName:
		m.ResetTypeName()
		return nil
	case watchlisthistory.FieldRankWatchlist:
		m.ResetRankWatchlist()
		return nil
	case watchlisthistory.FieldStatusDel:
		m.ResetStatusDel()
		return nil
	case watchlisthistory.FieldDateCalRank:
		m.ResetDateCalRank()
		return nil
	}
	return fmt.Errorf("unknown Watchlisthistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WatchlisthistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WatchlisthistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WatchlisthistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WatchlisthistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WatchlisthistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WatchlisthistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WatchlisthistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Watchlisthistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WatchlisthistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Watchlisthistory edge %s", name)
}

// WatchlisttypeMutation represents an operation that mutates the Watchlisttype nodes in the graph.
type WatchlisttypeMutation struct {
	config
	op               Op
	typ              string
	id               *int
	_TypeID          *int
	add_TypeID       *int
	_TypeName        *string
	_TypeDescription *string
	clearedFields    map[string]struct{}
	watchlist        map[int]struct{}
	removedwatchlist map[int]struct{}
	clearedwatchlist bool
	done             bool
	oldValue         func(context.Context) (*Watchlisttype, error)
	predicates       []predicate.Watchlisttype
}

var _ ent.Mutation = (*WatchlisttypeMutation)(nil)

// watchlisttypeOption allows management of the mutation configuration using functional options.
type watchlisttypeOption func(*WatchlisttypeMutation)

// newWatchlisttypeMutation creates new mutation for the Watchlisttype entity.
func newWatchlisttypeMutation(c config, op Op, opts ...watchlisttypeOption) *WatchlisttypeMutation {
	m := &WatchlisttypeMutation{
		config:        c,
		op:            op,
		typ:           TypeWatchlisttype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWatchlisttypeID sets the ID field of the mutation.
func withWatchlisttypeID(id int) watchlisttypeOption {
	return func(m *WatchlisttypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Watchlisttype
		)
		m.oldValue = func(ctx context.Context) (*Watchlisttype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Watchlisttype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWatchlisttype sets the old Watchlisttype of the mutation.
func withWatchlisttype(node *Watchlisttype) watchlisttypeOption {
	return func(m *WatchlisttypeMutation) {
		m.oldValue = func(context.Context) (*Watchlisttype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WatchlisttypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WatchlisttypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Watchlisttype entities.
func (m *WatchlisttypeMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WatchlisttypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTypeID sets the "TypeID" field.
func (m *WatchlisttypeMutation) SetTypeID(i int) {
	m._TypeID = &i
	m.add_TypeID = nil
}

// TypeID returns the value of the "TypeID" field in the mutation.
func (m *WatchlisttypeMutation) TypeID() (r int, exists bool) {
	v := m._TypeID
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "TypeID" field's value of the Watchlisttype entity.
// If the Watchlisttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisttypeMutation) OldTypeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// AddTypeID adds i to the "TypeID" field.
func (m *WatchlisttypeMutation) AddTypeID(i int) {
	if m.add_TypeID != nil {
		*m.add_TypeID += i
	} else {
		m.add_TypeID = &i
	}
}

// AddedTypeID returns the value that was added to the "TypeID" field in this mutation.
func (m *WatchlisttypeMutation) AddedTypeID() (r int, exists bool) {
	v := m.add_TypeID
	if v == nil {
		return
	}
	return *v, true
}

// ClearTypeID clears the value of the "TypeID" field.
func (m *WatchlisttypeMutation) ClearTypeID() {
	m._TypeID = nil
	m.add_TypeID = nil
	m.clearedFields[watchlisttype.FieldTypeID] = struct{}{}
}

// TypeIDCleared returns if the "TypeID" field was cleared in this mutation.
func (m *WatchlisttypeMutation) TypeIDCleared() bool {
	_, ok := m.clearedFields[watchlisttype.FieldTypeID]
	return ok
}

// ResetTypeID resets all changes to the "TypeID" field.
func (m *WatchlisttypeMutation) ResetTypeID() {
	m._TypeID = nil
	m.add_TypeID = nil
	delete(m.clearedFields, watchlisttype.FieldTypeID)
}

// SetTypeName sets the "TypeName" field.
func (m *WatchlisttypeMutation) SetTypeName(s string) {
	m._TypeName = &s
}

// TypeName returns the value of the "TypeName" field in the mutation.
func (m *WatchlisttypeMutation) TypeName() (r string, exists bool) {
	v := m._TypeName
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeName returns the old "TypeName" field's value of the Watchlisttype entity.
// If the Watchlisttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisttypeMutation) OldTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeName: %w", err)
	}
	return oldValue.TypeName, nil
}

// ResetTypeName resets all changes to the "TypeName" field.
func (m *WatchlisttypeMutation) ResetTypeName() {
	m._TypeName = nil
}

// SetTypeDescription sets the "TypeDescription" field.
func (m *WatchlisttypeMutation) SetTypeDescription(s string) {
	m._TypeDescription = &s
}

// TypeDescription returns the value of the "TypeDescription" field in the mutation.
func (m *WatchlisttypeMutation) TypeDescription() (r string, exists bool) {
	v := m._TypeDescription
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeDescription returns the old "TypeDescription" field's value of the Watchlisttype entity.
// If the Watchlisttype object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WatchlisttypeMutation) OldTypeDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTypeDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTypeDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeDescription: %w", err)
	}
	return oldValue.TypeDescription, nil
}

// ResetTypeDescription resets all changes to the "TypeDescription" field.
func (m *WatchlisttypeMutation) ResetTypeDescription() {
	m._TypeDescription = nil
}

// AddWatchlistIDs adds the "watchlist" edge to the Watchlist entity by ids.
func (m *WatchlisttypeMutation) AddWatchlistIDs(ids ...int) {
	if m.watchlist == nil {
		m.watchlist = make(map[int]struct{})
	}
	for i := range ids {
		m.watchlist[ids[i]] = struct{}{}
	}
}

// ClearWatchlist clears the "watchlist" edge to the Watchlist entity.
func (m *WatchlisttypeMutation) ClearWatchlist() {
	m.clearedwatchlist = true
}

// WatchlistCleared returns if the "watchlist" edge to the Watchlist entity was cleared.
func (m *WatchlisttypeMutation) WatchlistCleared() bool {
	return m.clearedwatchlist
}

// RemoveWatchlistIDs removes the "watchlist" edge to the Watchlist entity by IDs.
func (m *WatchlisttypeMutation) RemoveWatchlistIDs(ids ...int) {
	if m.removedwatchlist == nil {
		m.removedwatchlist = make(map[int]struct{})
	}
	for i := range ids {
		m.removedwatchlist[ids[i]] = struct{}{}
	}
}

// RemovedWatchlist returns the removed IDs of the "watchlist" edge to the Watchlist entity.
func (m *WatchlisttypeMutation) RemovedWatchlistIDs() (ids []int) {
	for id := range m.removedwatchlist {
		ids = append(ids, id)
	}
	return
}

// WatchlistIDs returns the "watchlist" edge IDs in the mutation.
func (m *WatchlisttypeMutation) WatchlistIDs() (ids []int) {
	for id := range m.watchlist {
		ids = append(ids, id)
	}
	return
}

// ResetWatchlist resets all changes to the "watchlist" edge.
func (m *WatchlisttypeMutation) ResetWatchlist() {
	m.watchlist = nil
	m.clearedwatchlist = false
	m.removedwatchlist = nil
}

// Op returns the operation name.
func (m *WatchlisttypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Watchlisttype).
func (m *WatchlisttypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WatchlisttypeMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._TypeID != nil {
		fields = append(fields, watchlisttype.FieldTypeID)
	}
	if m._TypeName != nil {
		fields = append(fields, watchlisttype.FieldTypeName)
	}
	if m._TypeDescription != nil {
		fields = append(fields, watchlisttype.FieldTypeDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WatchlisttypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case watchlisttype.FieldTypeID:
		return m.TypeID()
	case watchlisttype.FieldTypeName:
		return m.TypeName()
	case watchlisttype.FieldTypeDescription:
		return m.TypeDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WatchlisttypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case watchlisttype.FieldTypeID:
		return m.OldTypeID(ctx)
	case watchlisttype.FieldTypeName:
		return m.OldTypeName(ctx)
	case watchlisttype.FieldTypeDescription:
		return m.OldTypeDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Watchlisttype field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlisttypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case watchlisttype.FieldTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	case watchlisttype.FieldTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeName(v)
		return nil
	case watchlisttype.FieldTypeDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlisttype field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WatchlisttypeMutation) AddedFields() []string {
	var fields []string
	if m.add_TypeID != nil {
		fields = append(fields, watchlisttype.FieldTypeID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WatchlisttypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case watchlisttype.FieldTypeID:
		return m.AddedTypeID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WatchlisttypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case watchlisttype.FieldTypeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown Watchlisttype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WatchlisttypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(watchlisttype.FieldTypeID) {
		fields = append(fields, watchlisttype.FieldTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WatchlisttypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WatchlisttypeMutation) ClearField(name string) error {
	switch name {
	case watchlisttype.FieldTypeID:
		m.ClearTypeID()
		return nil
	}
	return fmt.Errorf("unknown Watchlisttype nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WatchlisttypeMutation) ResetField(name string) error {
	switch name {
	case watchlisttype.FieldTypeID:
		m.ResetTypeID()
		return nil
	case watchlisttype.FieldTypeName:
		m.ResetTypeName()
		return nil
	case watchlisttype.FieldTypeDescription:
		m.ResetTypeDescription()
		return nil
	}
	return fmt.Errorf("unknown Watchlisttype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WatchlisttypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.watchlist != nil {
		edges = append(edges, watchlisttype.EdgeWatchlist)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WatchlisttypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case watchlisttype.EdgeWatchlist:
		ids := make([]ent.Value, 0, len(m.watchlist))
		for id := range m.watchlist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WatchlisttypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedwatchlist != nil {
		edges = append(edges, watchlisttype.EdgeWatchlist)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WatchlisttypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case watchlisttype.EdgeWatchlist:
		ids := make([]ent.Value, 0, len(m.removedwatchlist))
		for id := range m.removedwatchlist {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WatchlisttypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedwatchlist {
		edges = append(edges, watchlisttype.EdgeWatchlist)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WatchlisttypeMutation) EdgeCleared(name string) bool {
	switch name {
	case watchlisttype.EdgeWatchlist:
		return m.clearedwatchlist
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WatchlisttypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Watchlisttype unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WatchlisttypeMutation) ResetEdge(name string) error {
	switch name {
	case watchlisttype.EdgeWatchlist:
		m.ResetWatchlist()
		return nil
	}
	return fmt.Errorf("unknown Watchlisttype edge %s", name)
}

// WritelogMutation represents an operation that mutates the Writelog nodes in the graph.
type WritelogMutation struct {
	config
	op            Op
	typ           string
	id            *int
	admin_id      *int
	addadmin_id   *int
	resource      *string
	actions       *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Writelog, error)
	predicates    []predicate.Writelog
}

var _ ent.Mutation = (*WritelogMutation)(nil)

// writelogOption allows management of the mutation configuration using functional options.
type writelogOption func(*WritelogMutation)

// newWritelogMutation creates new mutation for the Writelog entity.
func newWritelogMutation(c config, op Op, opts ...writelogOption) *WritelogMutation {
	m := &WritelogMutation{
		config:        c,
		op:            op,
		typ:           TypeWritelog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWritelogID sets the ID field of the mutation.
func withWritelogID(id int) writelogOption {
	return func(m *WritelogMutation) {
		var (
			err   error
			once  sync.Once
			value *Writelog
		)
		m.oldValue = func(ctx context.Context) (*Writelog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Writelog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWritelog sets the old Writelog of the mutation.
func withWritelog(node *Writelog) writelogOption {
	return func(m *WritelogMutation) {
		m.oldValue = func(context.Context) (*Writelog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WritelogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WritelogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Writelog entities.
func (m *WritelogMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *WritelogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAdminID sets the "admin_id" field.
func (m *WritelogMutation) SetAdminID(i int) {
	m.admin_id = &i
	m.addadmin_id = nil
}

// AdminID returns the value of the "admin_id" field in the mutation.
func (m *WritelogMutation) AdminID() (r int, exists bool) {
	v := m.admin_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminID returns the old "admin_id" field's value of the Writelog entity.
// If the Writelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WritelogMutation) OldAdminID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAdminID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAdminID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminID: %w", err)
	}
	return oldValue.AdminID, nil
}

// AddAdminID adds i to the "admin_id" field.
func (m *WritelogMutation) AddAdminID(i int) {
	if m.addadmin_id != nil {
		*m.addadmin_id += i
	} else {
		m.addadmin_id = &i
	}
}

// AddedAdminID returns the value that was added to the "admin_id" field in this mutation.
func (m *WritelogMutation) AddedAdminID() (r int, exists bool) {
	v := m.addadmin_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAdminID resets all changes to the "admin_id" field.
func (m *WritelogMutation) ResetAdminID() {
	m.admin_id = nil
	m.addadmin_id = nil
}

// SetResource sets the "resource" field.
func (m *WritelogMutation) SetResource(s string) {
	m.resource = &s
}

// Resource returns the value of the "resource" field in the mutation.
func (m *WritelogMutation) Resource() (r string, exists bool) {
	v := m.resource
	if v == nil {
		return
	}
	return *v, true
}

// OldResource returns the old "resource" field's value of the Writelog entity.
// If the Writelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WritelogMutation) OldResource(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldResource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldResource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResource: %w", err)
	}
	return oldValue.Resource, nil
}

// ClearResource clears the value of the "resource" field.
func (m *WritelogMutation) ClearResource() {
	m.resource = nil
	m.clearedFields[writelog.FieldResource] = struct{}{}
}

// ResourceCleared returns if the "resource" field was cleared in this mutation.
func (m *WritelogMutation) ResourceCleared() bool {
	_, ok := m.clearedFields[writelog.FieldResource]
	return ok
}

// ResetResource resets all changes to the "resource" field.
func (m *WritelogMutation) ResetResource() {
	m.resource = nil
	delete(m.clearedFields, writelog.FieldResource)
}

// SetActions sets the "actions" field.
func (m *WritelogMutation) SetActions(s string) {
	m.actions = &s
}

// Actions returns the value of the "actions" field in the mutation.
func (m *WritelogMutation) Actions() (r string, exists bool) {
	v := m.actions
	if v == nil {
		return
	}
	return *v, true
}

// OldActions returns the old "actions" field's value of the Writelog entity.
// If the Writelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WritelogMutation) OldActions(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActions: %w", err)
	}
	return oldValue.Actions, nil
}

// ClearActions clears the value of the "actions" field.
func (m *WritelogMutation) ClearActions() {
	m.actions = nil
	m.clearedFields[writelog.FieldActions] = struct{}{}
}

// ActionsCleared returns if the "actions" field was cleared in this mutation.
func (m *WritelogMutation) ActionsCleared() bool {
	_, ok := m.clearedFields[writelog.FieldActions]
	return ok
}

// ResetActions resets all changes to the "actions" field.
func (m *WritelogMutation) ResetActions() {
	m.actions = nil
	delete(m.clearedFields, writelog.FieldActions)
}

// SetCreatedAt sets the "created_at" field.
func (m *WritelogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WritelogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Writelog entity.
// If the Writelog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WritelogMutation) OldCreatedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WritelogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[writelog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WritelogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[writelog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WritelogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, writelog.FieldCreatedAt)
}

// Op returns the operation name.
func (m *WritelogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Writelog).
func (m *WritelogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WritelogMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.admin_id != nil {
		fields = append(fields, writelog.FieldAdminID)
	}
	if m.resource != nil {
		fields = append(fields, writelog.FieldResource)
	}
	if m.actions != nil {
		fields = append(fields, writelog.FieldActions)
	}
	if m.created_at != nil {
		fields = append(fields, writelog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WritelogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case writelog.FieldAdminID:
		return m.AdminID()
	case writelog.FieldResource:
		return m.Resource()
	case writelog.FieldActions:
		return m.Actions()
	case writelog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WritelogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case writelog.FieldAdminID:
		return m.OldAdminID(ctx)
	case writelog.FieldResource:
		return m.OldResource(ctx)
	case writelog.FieldActions:
		return m.OldActions(ctx)
	case writelog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Writelog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WritelogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case writelog.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminID(v)
		return nil
	case writelog.FieldResource:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResource(v)
		return nil
	case writelog.FieldActions:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActions(v)
		return nil
	case writelog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Writelog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WritelogMutation) AddedFields() []string {
	var fields []string
	if m.addadmin_id != nil {
		fields = append(fields, writelog.FieldAdminID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WritelogMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case writelog.FieldAdminID:
		return m.AddedAdminID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WritelogMutation) AddField(name string, value ent.Value) error {
	switch name {
	case writelog.FieldAdminID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAdminID(v)
		return nil
	}
	return fmt.Errorf("unknown Writelog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WritelogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(writelog.FieldResource) {
		fields = append(fields, writelog.FieldResource)
	}
	if m.FieldCleared(writelog.FieldActions) {
		fields = append(fields, writelog.FieldActions)
	}
	if m.FieldCleared(writelog.FieldCreatedAt) {
		fields = append(fields, writelog.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WritelogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WritelogMutation) ClearField(name string) error {
	switch name {
	case writelog.FieldResource:
		m.ClearResource()
		return nil
	case writelog.FieldActions:
		m.ClearActions()
		return nil
	case writelog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Writelog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WritelogMutation) ResetField(name string) error {
	switch name {
	case writelog.FieldAdminID:
		m.ResetAdminID()
		return nil
	case writelog.FieldResource:
		m.ResetResource()
		return nil
	case writelog.FieldActions:
		m.ResetActions()
		return nil
	case writelog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Writelog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WritelogMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WritelogMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WritelogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WritelogMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WritelogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WritelogMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WritelogMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Writelog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WritelogMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Writelog edge %s", name)
}
