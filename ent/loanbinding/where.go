// Code generated by entc, DO NOT EDIT.

package loanbinding

import (
	"go-api-report2/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Status applies equality check predicate on the "Status" field. It's identical to StatusEQ.
func Status(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// DateTime applies equality check predicate on the "dateTime" field. It's identical to DateTimeEQ.
func DateTime(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// WalletId applies equality check predicate on the "WalletId" field. It's identical to WalletIdEQ.
func WalletId(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletId), v))
	})
}

// AccountReference applies equality check predicate on the "AccountReference" field. It's identical to AccountReferenceEQ.
func AccountReference(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAccountReference), v))
	})
}

// LoanAccountNo applies equality check predicate on the "LoanAccountNo" field. It's identical to LoanAccountNoEQ.
func LoanAccountNo(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLoanAccountNo), v))
	})
}

// RequestDateTime applies equality check predicate on the "RequestDateTime" field. It's identical to RequestDateTimeEQ.
func RequestDateTime(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRequestDateTime), v))
	})
}

// FileimportID applies equality check predicate on the "FileimportID" field. It's identical to FileimportIDEQ.
func FileimportID(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// StatusEQ applies the EQ predicate on the "Status" field.
func StatusEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatus), v))
	})
}

// StatusNEQ applies the NEQ predicate on the "Status" field.
func StatusNEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatus), v))
	})
}

// StatusIn applies the In predicate on the "Status" field.
func StatusIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatus), v...))
	})
}

// StatusNotIn applies the NotIn predicate on the "Status" field.
func StatusNotIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatus), v...))
	})
}

// StatusGT applies the GT predicate on the "Status" field.
func StatusGT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatus), v))
	})
}

// StatusGTE applies the GTE predicate on the "Status" field.
func StatusGTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatus), v))
	})
}

// StatusLT applies the LT predicate on the "Status" field.
func StatusLT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatus), v))
	})
}

// StatusLTE applies the LTE predicate on the "Status" field.
func StatusLTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatus), v))
	})
}

// StatusContains applies the Contains predicate on the "Status" field.
func StatusContains(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldStatus), v))
	})
}

// StatusHasPrefix applies the HasPrefix predicate on the "Status" field.
func StatusHasPrefix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldStatus), v))
	})
}

// StatusHasSuffix applies the HasSuffix predicate on the "Status" field.
func StatusHasSuffix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldStatus), v))
	})
}

// StatusIsNil applies the IsNil predicate on the "Status" field.
func StatusIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatus)))
	})
}

// StatusNotNil applies the NotNil predicate on the "Status" field.
func StatusNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatus)))
	})
}

// StatusEqualFold applies the EqualFold predicate on the "Status" field.
func StatusEqualFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldStatus), v))
	})
}

// StatusContainsFold applies the ContainsFold predicate on the "Status" field.
func StatusContainsFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldStatus), v))
	})
}

// DateTimeEQ applies the EQ predicate on the "dateTime" field.
func DateTimeEQ(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// DateTimeNEQ applies the NEQ predicate on the "dateTime" field.
func DateTimeNEQ(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateTime), v))
	})
}

// DateTimeIn applies the In predicate on the "dateTime" field.
func DateTimeIn(vs ...time.Time) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateTime), v...))
	})
}

// DateTimeNotIn applies the NotIn predicate on the "dateTime" field.
func DateTimeNotIn(vs ...time.Time) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateTime), v...))
	})
}

// DateTimeGT applies the GT predicate on the "dateTime" field.
func DateTimeGT(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateTime), v))
	})
}

// DateTimeGTE applies the GTE predicate on the "dateTime" field.
func DateTimeGTE(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateTime), v))
	})
}

// DateTimeLT applies the LT predicate on the "dateTime" field.
func DateTimeLT(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateTime), v))
	})
}

// DateTimeLTE applies the LTE predicate on the "dateTime" field.
func DateTimeLTE(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateTime), v))
	})
}

// DateTimeIsNil applies the IsNil predicate on the "dateTime" field.
func DateTimeIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateTime)))
	})
}

// DateTimeNotNil applies the NotNil predicate on the "dateTime" field.
func DateTimeNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateTime)))
	})
}

// WalletIdEQ applies the EQ predicate on the "WalletId" field.
func WalletIdEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletId), v))
	})
}

// WalletIdNEQ applies the NEQ predicate on the "WalletId" field.
func WalletIdNEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWalletId), v))
	})
}

// WalletIdIn applies the In predicate on the "WalletId" field.
func WalletIdIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWalletId), v...))
	})
}

// WalletIdNotIn applies the NotIn predicate on the "WalletId" field.
func WalletIdNotIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWalletId), v...))
	})
}

// WalletIdGT applies the GT predicate on the "WalletId" field.
func WalletIdGT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWalletId), v))
	})
}

// WalletIdGTE applies the GTE predicate on the "WalletId" field.
func WalletIdGTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWalletId), v))
	})
}

// WalletIdLT applies the LT predicate on the "WalletId" field.
func WalletIdLT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWalletId), v))
	})
}

// WalletIdLTE applies the LTE predicate on the "WalletId" field.
func WalletIdLTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWalletId), v))
	})
}

// WalletIdContains applies the Contains predicate on the "WalletId" field.
func WalletIdContains(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWalletId), v))
	})
}

// WalletIdHasPrefix applies the HasPrefix predicate on the "WalletId" field.
func WalletIdHasPrefix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWalletId), v))
	})
}

// WalletIdHasSuffix applies the HasSuffix predicate on the "WalletId" field.
func WalletIdHasSuffix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWalletId), v))
	})
}

// WalletIdIsNil applies the IsNil predicate on the "WalletId" field.
func WalletIdIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldWalletId)))
	})
}

// WalletIdNotNil applies the NotNil predicate on the "WalletId" field.
func WalletIdNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldWalletId)))
	})
}

// WalletIdEqualFold applies the EqualFold predicate on the "WalletId" field.
func WalletIdEqualFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWalletId), v))
	})
}

// WalletIdContainsFold applies the ContainsFold predicate on the "WalletId" field.
func WalletIdContainsFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWalletId), v))
	})
}

// AccountReferenceEQ applies the EQ predicate on the "AccountReference" field.
func AccountReferenceEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceNEQ applies the NEQ predicate on the "AccountReference" field.
func AccountReferenceNEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceIn applies the In predicate on the "AccountReference" field.
func AccountReferenceIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAccountReference), v...))
	})
}

// AccountReferenceNotIn applies the NotIn predicate on the "AccountReference" field.
func AccountReferenceNotIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAccountReference), v...))
	})
}

// AccountReferenceGT applies the GT predicate on the "AccountReference" field.
func AccountReferenceGT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceGTE applies the GTE predicate on the "AccountReference" field.
func AccountReferenceGTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceLT applies the LT predicate on the "AccountReference" field.
func AccountReferenceLT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceLTE applies the LTE predicate on the "AccountReference" field.
func AccountReferenceLTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceContains applies the Contains predicate on the "AccountReference" field.
func AccountReferenceContains(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceHasPrefix applies the HasPrefix predicate on the "AccountReference" field.
func AccountReferenceHasPrefix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceHasSuffix applies the HasSuffix predicate on the "AccountReference" field.
func AccountReferenceHasSuffix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceIsNil applies the IsNil predicate on the "AccountReference" field.
func AccountReferenceIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAccountReference)))
	})
}

// AccountReferenceNotNil applies the NotNil predicate on the "AccountReference" field.
func AccountReferenceNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAccountReference)))
	})
}

// AccountReferenceEqualFold applies the EqualFold predicate on the "AccountReference" field.
func AccountReferenceEqualFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldAccountReference), v))
	})
}

// AccountReferenceContainsFold applies the ContainsFold predicate on the "AccountReference" field.
func AccountReferenceContainsFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldAccountReference), v))
	})
}

// LoanAccountNoEQ applies the EQ predicate on the "LoanAccountNo" field.
func LoanAccountNoEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoNEQ applies the NEQ predicate on the "LoanAccountNo" field.
func LoanAccountNoNEQ(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoIn applies the In predicate on the "LoanAccountNo" field.
func LoanAccountNoIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLoanAccountNo), v...))
	})
}

// LoanAccountNoNotIn applies the NotIn predicate on the "LoanAccountNo" field.
func LoanAccountNoNotIn(vs ...string) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLoanAccountNo), v...))
	})
}

// LoanAccountNoGT applies the GT predicate on the "LoanAccountNo" field.
func LoanAccountNoGT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoGTE applies the GTE predicate on the "LoanAccountNo" field.
func LoanAccountNoGTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoLT applies the LT predicate on the "LoanAccountNo" field.
func LoanAccountNoLT(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoLTE applies the LTE predicate on the "LoanAccountNo" field.
func LoanAccountNoLTE(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoContains applies the Contains predicate on the "LoanAccountNo" field.
func LoanAccountNoContains(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoHasPrefix applies the HasPrefix predicate on the "LoanAccountNo" field.
func LoanAccountNoHasPrefix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoHasSuffix applies the HasSuffix predicate on the "LoanAccountNo" field.
func LoanAccountNoHasSuffix(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoIsNil applies the IsNil predicate on the "LoanAccountNo" field.
func LoanAccountNoIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLoanAccountNo)))
	})
}

// LoanAccountNoNotNil applies the NotNil predicate on the "LoanAccountNo" field.
func LoanAccountNoNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLoanAccountNo)))
	})
}

// LoanAccountNoEqualFold applies the EqualFold predicate on the "LoanAccountNo" field.
func LoanAccountNoEqualFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLoanAccountNo), v))
	})
}

// LoanAccountNoContainsFold applies the ContainsFold predicate on the "LoanAccountNo" field.
func LoanAccountNoContainsFold(v string) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLoanAccountNo), v))
	})
}

// RequestDateTimeEQ applies the EQ predicate on the "RequestDateTime" field.
func RequestDateTimeEQ(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeNEQ applies the NEQ predicate on the "RequestDateTime" field.
func RequestDateTimeNEQ(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeIn applies the In predicate on the "RequestDateTime" field.
func RequestDateTimeIn(vs ...time.Time) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRequestDateTime), v...))
	})
}

// RequestDateTimeNotIn applies the NotIn predicate on the "RequestDateTime" field.
func RequestDateTimeNotIn(vs ...time.Time) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRequestDateTime), v...))
	})
}

// RequestDateTimeGT applies the GT predicate on the "RequestDateTime" field.
func RequestDateTimeGT(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeGTE applies the GTE predicate on the "RequestDateTime" field.
func RequestDateTimeGTE(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeLT applies the LT predicate on the "RequestDateTime" field.
func RequestDateTimeLT(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeLTE applies the LTE predicate on the "RequestDateTime" field.
func RequestDateTimeLTE(v time.Time) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRequestDateTime), v))
	})
}

// RequestDateTimeIsNil applies the IsNil predicate on the "RequestDateTime" field.
func RequestDateTimeIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldRequestDateTime)))
	})
}

// RequestDateTimeNotNil applies the NotNil predicate on the "RequestDateTime" field.
func RequestDateTimeNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldRequestDateTime)))
	})
}

// FileimportIDEQ applies the EQ predicate on the "FileimportID" field.
func FileimportIDEQ(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDNEQ applies the NEQ predicate on the "FileimportID" field.
func FileimportIDNEQ(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIn applies the In predicate on the "FileimportID" field.
func FileimportIDIn(vs ...int) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDNotIn applies the NotIn predicate on the "FileimportID" field.
func FileimportIDNotIn(vs ...int) predicate.Loanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Loanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDGT applies the GT predicate on the "FileimportID" field.
func FileimportIDGT(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDGTE applies the GTE predicate on the "FileimportID" field.
func FileimportIDGTE(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLT applies the LT predicate on the "FileimportID" field.
func FileimportIDLT(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLTE applies the LTE predicate on the "FileimportID" field.
func FileimportIDLTE(v int) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIsNil applies the IsNil predicate on the "FileimportID" field.
func FileimportIDIsNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFileimportID)))
	})
}

// FileimportIDNotNil applies the NotNil predicate on the "FileimportID" field.
func FileimportIDNotNil() predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFileimportID)))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Loanbinding) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Loanbinding) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Loanbinding) predicate.Loanbinding {
	return predicate.Loanbinding(func(s *sql.Selector) {
		p(s.Not())
	})
}
