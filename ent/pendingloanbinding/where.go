// Code generated by entc, DO NOT EDIT.

package pendingloanbinding

import (
	"go-api-report2/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// WalletID applies equality check predicate on the "WalletID" field. It's identical to WalletIDEQ.
func WalletID(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletID), v))
	})
}

// NameLB applies equality check predicate on the "NameLB" field. It's identical to NameLBEQ.
func NameLB(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNameLB), v))
	})
}

// StatusGenLB applies equality check predicate on the "StatusGenLB" field. It's identical to StatusGenLBEQ.
func StatusGenLB(v bool) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusGenLB), v))
	})
}

// PointLB applies equality check predicate on the "PointLB" field. It's identical to PointLBEQ.
func PointLB(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPointLB), v))
	})
}

// DateTime applies equality check predicate on the "DateTime" field. It's identical to DateTimeEQ.
func DateTime(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// DateGenLB applies equality check predicate on the "DateGenLB" field. It's identical to DateGenLBEQ.
func DateGenLB(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateGenLB), v))
	})
}

// FileimportID applies equality check predicate on the "FileimportID" field. It's identical to FileimportIDEQ.
func FileimportID(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// CAWalletID applies equality check predicate on the "CAWalletID" field. It's identical to CAWalletIDEQ.
func CAWalletID(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCAWalletID), v))
	})
}

// CAPort applies equality check predicate on the "CAPort" field. It's identical to CAPortEQ.
func CAPort(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCAPort), v))
	})
}

// MainBranch applies equality check predicate on the "MainBranch" field. It's identical to MainBranchEQ.
func MainBranch(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMainBranch), v))
	})
}

// WalletIDEQ applies the EQ predicate on the "WalletID" field.
func WalletIDEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletID), v))
	})
}

// WalletIDNEQ applies the NEQ predicate on the "WalletID" field.
func WalletIDNEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWalletID), v))
	})
}

// WalletIDIn applies the In predicate on the "WalletID" field.
func WalletIDIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWalletID), v...))
	})
}

// WalletIDNotIn applies the NotIn predicate on the "WalletID" field.
func WalletIDNotIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWalletID), v...))
	})
}

// WalletIDGT applies the GT predicate on the "WalletID" field.
func WalletIDGT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWalletID), v))
	})
}

// WalletIDGTE applies the GTE predicate on the "WalletID" field.
func WalletIDGTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWalletID), v))
	})
}

// WalletIDLT applies the LT predicate on the "WalletID" field.
func WalletIDLT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWalletID), v))
	})
}

// WalletIDLTE applies the LTE predicate on the "WalletID" field.
func WalletIDLTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWalletID), v))
	})
}

// WalletIDContains applies the Contains predicate on the "WalletID" field.
func WalletIDContains(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWalletID), v))
	})
}

// WalletIDHasPrefix applies the HasPrefix predicate on the "WalletID" field.
func WalletIDHasPrefix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWalletID), v))
	})
}

// WalletIDHasSuffix applies the HasSuffix predicate on the "WalletID" field.
func WalletIDHasSuffix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWalletID), v))
	})
}

// WalletIDIsNil applies the IsNil predicate on the "WalletID" field.
func WalletIDIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldWalletID)))
	})
}

// WalletIDNotNil applies the NotNil predicate on the "WalletID" field.
func WalletIDNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldWalletID)))
	})
}

// WalletIDEqualFold applies the EqualFold predicate on the "WalletID" field.
func WalletIDEqualFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWalletID), v))
	})
}

// WalletIDContainsFold applies the ContainsFold predicate on the "WalletID" field.
func WalletIDContainsFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWalletID), v))
	})
}

// NameLBEQ applies the EQ predicate on the "NameLB" field.
func NameLBEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNameLB), v))
	})
}

// NameLBNEQ applies the NEQ predicate on the "NameLB" field.
func NameLBNEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNameLB), v))
	})
}

// NameLBIn applies the In predicate on the "NameLB" field.
func NameLBIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNameLB), v...))
	})
}

// NameLBNotIn applies the NotIn predicate on the "NameLB" field.
func NameLBNotIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNameLB), v...))
	})
}

// NameLBGT applies the GT predicate on the "NameLB" field.
func NameLBGT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNameLB), v))
	})
}

// NameLBGTE applies the GTE predicate on the "NameLB" field.
func NameLBGTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNameLB), v))
	})
}

// NameLBLT applies the LT predicate on the "NameLB" field.
func NameLBLT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNameLB), v))
	})
}

// NameLBLTE applies the LTE predicate on the "NameLB" field.
func NameLBLTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNameLB), v))
	})
}

// NameLBContains applies the Contains predicate on the "NameLB" field.
func NameLBContains(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldNameLB), v))
	})
}

// NameLBHasPrefix applies the HasPrefix predicate on the "NameLB" field.
func NameLBHasPrefix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldNameLB), v))
	})
}

// NameLBHasSuffix applies the HasSuffix predicate on the "NameLB" field.
func NameLBHasSuffix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldNameLB), v))
	})
}

// NameLBIsNil applies the IsNil predicate on the "NameLB" field.
func NameLBIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldNameLB)))
	})
}

// NameLBNotNil applies the NotNil predicate on the "NameLB" field.
func NameLBNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldNameLB)))
	})
}

// NameLBEqualFold applies the EqualFold predicate on the "NameLB" field.
func NameLBEqualFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldNameLB), v))
	})
}

// NameLBContainsFold applies the ContainsFold predicate on the "NameLB" field.
func NameLBContainsFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldNameLB), v))
	})
}

// StatusGenLBEQ applies the EQ predicate on the "StatusGenLB" field.
func StatusGenLBEQ(v bool) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusGenLB), v))
	})
}

// StatusGenLBNEQ applies the NEQ predicate on the "StatusGenLB" field.
func StatusGenLBNEQ(v bool) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatusGenLB), v))
	})
}

// StatusGenLBIsNil applies the IsNil predicate on the "StatusGenLB" field.
func StatusGenLBIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatusGenLB)))
	})
}

// StatusGenLBNotNil applies the NotNil predicate on the "StatusGenLB" field.
func StatusGenLBNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatusGenLB)))
	})
}

// PointLBEQ applies the EQ predicate on the "PointLB" field.
func PointLBEQ(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPointLB), v))
	})
}

// PointLBNEQ applies the NEQ predicate on the "PointLB" field.
func PointLBNEQ(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPointLB), v))
	})
}

// PointLBIn applies the In predicate on the "PointLB" field.
func PointLBIn(vs ...int) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPointLB), v...))
	})
}

// PointLBNotIn applies the NotIn predicate on the "PointLB" field.
func PointLBNotIn(vs ...int) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPointLB), v...))
	})
}

// PointLBGT applies the GT predicate on the "PointLB" field.
func PointLBGT(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPointLB), v))
	})
}

// PointLBGTE applies the GTE predicate on the "PointLB" field.
func PointLBGTE(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPointLB), v))
	})
}

// PointLBLT applies the LT predicate on the "PointLB" field.
func PointLBLT(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPointLB), v))
	})
}

// PointLBLTE applies the LTE predicate on the "PointLB" field.
func PointLBLTE(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPointLB), v))
	})
}

// PointLBIsNil applies the IsNil predicate on the "PointLB" field.
func PointLBIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPointLB)))
	})
}

// PointLBNotNil applies the NotNil predicate on the "PointLB" field.
func PointLBNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPointLB)))
	})
}

// DateTimeEQ applies the EQ predicate on the "DateTime" field.
func DateTimeEQ(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateTime), v))
	})
}

// DateTimeNEQ applies the NEQ predicate on the "DateTime" field.
func DateTimeNEQ(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateTime), v))
	})
}

// DateTimeIn applies the In predicate on the "DateTime" field.
func DateTimeIn(vs ...time.Time) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateTime), v...))
	})
}

// DateTimeNotIn applies the NotIn predicate on the "DateTime" field.
func DateTimeNotIn(vs ...time.Time) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateTime), v...))
	})
}

// DateTimeGT applies the GT predicate on the "DateTime" field.
func DateTimeGT(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateTime), v))
	})
}

// DateTimeGTE applies the GTE predicate on the "DateTime" field.
func DateTimeGTE(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateTime), v))
	})
}

// DateTimeLT applies the LT predicate on the "DateTime" field.
func DateTimeLT(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateTime), v))
	})
}

// DateTimeLTE applies the LTE predicate on the "DateTime" field.
func DateTimeLTE(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateTime), v))
	})
}

// DateTimeIsNil applies the IsNil predicate on the "DateTime" field.
func DateTimeIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateTime)))
	})
}

// DateTimeNotNil applies the NotNil predicate on the "DateTime" field.
func DateTimeNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateTime)))
	})
}

// DateGenLBEQ applies the EQ predicate on the "DateGenLB" field.
func DateGenLBEQ(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBNEQ applies the NEQ predicate on the "DateGenLB" field.
func DateGenLBNEQ(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBIn applies the In predicate on the "DateGenLB" field.
func DateGenLBIn(vs ...time.Time) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateGenLB), v...))
	})
}

// DateGenLBNotIn applies the NotIn predicate on the "DateGenLB" field.
func DateGenLBNotIn(vs ...time.Time) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateGenLB), v...))
	})
}

// DateGenLBGT applies the GT predicate on the "DateGenLB" field.
func DateGenLBGT(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBGTE applies the GTE predicate on the "DateGenLB" field.
func DateGenLBGTE(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBLT applies the LT predicate on the "DateGenLB" field.
func DateGenLBLT(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBLTE applies the LTE predicate on the "DateGenLB" field.
func DateGenLBLTE(v time.Time) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBIsNil applies the IsNil predicate on the "DateGenLB" field.
func DateGenLBIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateGenLB)))
	})
}

// DateGenLBNotNil applies the NotNil predicate on the "DateGenLB" field.
func DateGenLBNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateGenLB)))
	})
}

// FileimportIDEQ applies the EQ predicate on the "FileimportID" field.
func FileimportIDEQ(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDNEQ applies the NEQ predicate on the "FileimportID" field.
func FileimportIDNEQ(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIn applies the In predicate on the "FileimportID" field.
func FileimportIDIn(vs ...int) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDNotIn applies the NotIn predicate on the "FileimportID" field.
func FileimportIDNotIn(vs ...int) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFileimportID), v...))
	})
}

// FileimportIDGT applies the GT predicate on the "FileimportID" field.
func FileimportIDGT(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDGTE applies the GTE predicate on the "FileimportID" field.
func FileimportIDGTE(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLT applies the LT predicate on the "FileimportID" field.
func FileimportIDLT(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFileimportID), v))
	})
}

// FileimportIDLTE applies the LTE predicate on the "FileimportID" field.
func FileimportIDLTE(v int) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFileimportID), v))
	})
}

// FileimportIDIsNil applies the IsNil predicate on the "FileimportID" field.
func FileimportIDIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldFileimportID)))
	})
}

// FileimportIDNotNil applies the NotNil predicate on the "FileimportID" field.
func FileimportIDNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldFileimportID)))
	})
}

// CAWalletIDEQ applies the EQ predicate on the "CAWalletID" field.
func CAWalletIDEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDNEQ applies the NEQ predicate on the "CAWalletID" field.
func CAWalletIDNEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDIn applies the In predicate on the "CAWalletID" field.
func CAWalletIDIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCAWalletID), v...))
	})
}

// CAWalletIDNotIn applies the NotIn predicate on the "CAWalletID" field.
func CAWalletIDNotIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCAWalletID), v...))
	})
}

// CAWalletIDGT applies the GT predicate on the "CAWalletID" field.
func CAWalletIDGT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDGTE applies the GTE predicate on the "CAWalletID" field.
func CAWalletIDGTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDLT applies the LT predicate on the "CAWalletID" field.
func CAWalletIDLT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDLTE applies the LTE predicate on the "CAWalletID" field.
func CAWalletIDLTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDContains applies the Contains predicate on the "CAWalletID" field.
func CAWalletIDContains(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDHasPrefix applies the HasPrefix predicate on the "CAWalletID" field.
func CAWalletIDHasPrefix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDHasSuffix applies the HasSuffix predicate on the "CAWalletID" field.
func CAWalletIDHasSuffix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDIsNil applies the IsNil predicate on the "CAWalletID" field.
func CAWalletIDIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCAWalletID)))
	})
}

// CAWalletIDNotNil applies the NotNil predicate on the "CAWalletID" field.
func CAWalletIDNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCAWalletID)))
	})
}

// CAWalletIDEqualFold applies the EqualFold predicate on the "CAWalletID" field.
func CAWalletIDEqualFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCAWalletID), v))
	})
}

// CAWalletIDContainsFold applies the ContainsFold predicate on the "CAWalletID" field.
func CAWalletIDContainsFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCAWalletID), v))
	})
}

// CAPortEQ applies the EQ predicate on the "CAPort" field.
func CAPortEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCAPort), v))
	})
}

// CAPortNEQ applies the NEQ predicate on the "CAPort" field.
func CAPortNEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCAPort), v))
	})
}

// CAPortIn applies the In predicate on the "CAPort" field.
func CAPortIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCAPort), v...))
	})
}

// CAPortNotIn applies the NotIn predicate on the "CAPort" field.
func CAPortNotIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCAPort), v...))
	})
}

// CAPortGT applies the GT predicate on the "CAPort" field.
func CAPortGT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCAPort), v))
	})
}

// CAPortGTE applies the GTE predicate on the "CAPort" field.
func CAPortGTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCAPort), v))
	})
}

// CAPortLT applies the LT predicate on the "CAPort" field.
func CAPortLT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCAPort), v))
	})
}

// CAPortLTE applies the LTE predicate on the "CAPort" field.
func CAPortLTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCAPort), v))
	})
}

// CAPortContains applies the Contains predicate on the "CAPort" field.
func CAPortContains(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldCAPort), v))
	})
}

// CAPortHasPrefix applies the HasPrefix predicate on the "CAPort" field.
func CAPortHasPrefix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldCAPort), v))
	})
}

// CAPortHasSuffix applies the HasSuffix predicate on the "CAPort" field.
func CAPortHasSuffix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldCAPort), v))
	})
}

// CAPortIsNil applies the IsNil predicate on the "CAPort" field.
func CAPortIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldCAPort)))
	})
}

// CAPortNotNil applies the NotNil predicate on the "CAPort" field.
func CAPortNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldCAPort)))
	})
}

// CAPortEqualFold applies the EqualFold predicate on the "CAPort" field.
func CAPortEqualFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldCAPort), v))
	})
}

// CAPortContainsFold applies the ContainsFold predicate on the "CAPort" field.
func CAPortContainsFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldCAPort), v))
	})
}

// MainBranchEQ applies the EQ predicate on the "MainBranch" field.
func MainBranchEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMainBranch), v))
	})
}

// MainBranchNEQ applies the NEQ predicate on the "MainBranch" field.
func MainBranchNEQ(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMainBranch), v))
	})
}

// MainBranchIn applies the In predicate on the "MainBranch" field.
func MainBranchIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMainBranch), v...))
	})
}

// MainBranchNotIn applies the NotIn predicate on the "MainBranch" field.
func MainBranchNotIn(vs ...string) predicate.Pendingloanbinding {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMainBranch), v...))
	})
}

// MainBranchGT applies the GT predicate on the "MainBranch" field.
func MainBranchGT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMainBranch), v))
	})
}

// MainBranchGTE applies the GTE predicate on the "MainBranch" field.
func MainBranchGTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMainBranch), v))
	})
}

// MainBranchLT applies the LT predicate on the "MainBranch" field.
func MainBranchLT(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMainBranch), v))
	})
}

// MainBranchLTE applies the LTE predicate on the "MainBranch" field.
func MainBranchLTE(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMainBranch), v))
	})
}

// MainBranchContains applies the Contains predicate on the "MainBranch" field.
func MainBranchContains(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldMainBranch), v))
	})
}

// MainBranchHasPrefix applies the HasPrefix predicate on the "MainBranch" field.
func MainBranchHasPrefix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldMainBranch), v))
	})
}

// MainBranchHasSuffix applies the HasSuffix predicate on the "MainBranch" field.
func MainBranchHasSuffix(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldMainBranch), v))
	})
}

// MainBranchIsNil applies the IsNil predicate on the "MainBranch" field.
func MainBranchIsNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldMainBranch)))
	})
}

// MainBranchNotNil applies the NotNil predicate on the "MainBranch" field.
func MainBranchNotNil() predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldMainBranch)))
	})
}

// MainBranchEqualFold applies the EqualFold predicate on the "MainBranch" field.
func MainBranchEqualFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldMainBranch), v))
	})
}

// MainBranchContainsFold applies the ContainsFold predicate on the "MainBranch" field.
func MainBranchContainsFold(v string) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldMainBranch), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Pendingloanbinding) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Pendingloanbinding) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Pendingloanbinding) predicate.Pendingloanbinding {
	return predicate.Pendingloanbinding(func(s *sql.Selector) {
		p(s.Not())
	})
}
