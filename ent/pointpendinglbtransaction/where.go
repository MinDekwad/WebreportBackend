// Code generated by entc, DO NOT EDIT.

package pointpendinglbtransaction

import (
	"go-api-report2/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// WalletID applies equality check predicate on the "WalletID" field. It's identical to WalletIDEQ.
func WalletID(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletID), v))
	})
}

// PointLB applies equality check predicate on the "PointLB" field. It's identical to PointLBEQ.
func PointLB(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPointLB), v))
	})
}

// DateExportLB applies equality check predicate on the "DateExportLB" field. It's identical to DateExportLBEQ.
func DateExportLB(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateExportLB), v))
	})
}

// DateGenLB applies equality check predicate on the "DateGenLB" field. It's identical to DateGenLBEQ.
func DateGenLB(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateGenLB), v))
	})
}

// NoteLB applies equality check predicate on the "NoteLB" field. It's identical to NoteLBEQ.
func NoteLB(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNoteLB), v))
	})
}

// StatusExportLB applies equality check predicate on the "StatusExportLB" field. It's identical to StatusExportLBEQ.
func StatusExportLB(v bool) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusExportLB), v))
	})
}

// LBDate applies equality check predicate on the "LBDate" field. It's identical to LBDateEQ.
func LBDate(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLBDate), v))
	})
}

// WalletIDEQ applies the EQ predicate on the "WalletID" field.
func WalletIDEQ(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWalletID), v))
	})
}

// WalletIDNEQ applies the NEQ predicate on the "WalletID" field.
func WalletIDNEQ(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWalletID), v))
	})
}

// WalletIDIn applies the In predicate on the "WalletID" field.
func WalletIDIn(vs ...string) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldWalletID), v...))
	})
}

// WalletIDNotIn applies the NotIn predicate on the "WalletID" field.
func WalletIDNotIn(vs ...string) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldWalletID), v...))
	})
}

// WalletIDGT applies the GT predicate on the "WalletID" field.
func WalletIDGT(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldWalletID), v))
	})
}

// WalletIDGTE applies the GTE predicate on the "WalletID" field.
func WalletIDGTE(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldWalletID), v))
	})
}

// WalletIDLT applies the LT predicate on the "WalletID" field.
func WalletIDLT(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldWalletID), v))
	})
}

// WalletIDLTE applies the LTE predicate on the "WalletID" field.
func WalletIDLTE(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldWalletID), v))
	})
}

// WalletIDContains applies the Contains predicate on the "WalletID" field.
func WalletIDContains(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldWalletID), v))
	})
}

// WalletIDHasPrefix applies the HasPrefix predicate on the "WalletID" field.
func WalletIDHasPrefix(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldWalletID), v))
	})
}

// WalletIDHasSuffix applies the HasSuffix predicate on the "WalletID" field.
func WalletIDHasSuffix(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldWalletID), v))
	})
}

// WalletIDIsNil applies the IsNil predicate on the "WalletID" field.
func WalletIDIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldWalletID)))
	})
}

// WalletIDNotNil applies the NotNil predicate on the "WalletID" field.
func WalletIDNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldWalletID)))
	})
}

// WalletIDEqualFold applies the EqualFold predicate on the "WalletID" field.
func WalletIDEqualFold(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldWalletID), v))
	})
}

// WalletIDContainsFold applies the ContainsFold predicate on the "WalletID" field.
func WalletIDContainsFold(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldWalletID), v))
	})
}

// PointLBEQ applies the EQ predicate on the "PointLB" field.
func PointLBEQ(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPointLB), v))
	})
}

// PointLBNEQ applies the NEQ predicate on the "PointLB" field.
func PointLBNEQ(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPointLB), v))
	})
}

// PointLBIn applies the In predicate on the "PointLB" field.
func PointLBIn(vs ...int) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPointLB), v...))
	})
}

// PointLBNotIn applies the NotIn predicate on the "PointLB" field.
func PointLBNotIn(vs ...int) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPointLB), v...))
	})
}

// PointLBGT applies the GT predicate on the "PointLB" field.
func PointLBGT(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPointLB), v))
	})
}

// PointLBGTE applies the GTE predicate on the "PointLB" field.
func PointLBGTE(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPointLB), v))
	})
}

// PointLBLT applies the LT predicate on the "PointLB" field.
func PointLBLT(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPointLB), v))
	})
}

// PointLBLTE applies the LTE predicate on the "PointLB" field.
func PointLBLTE(v int) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPointLB), v))
	})
}

// PointLBIsNil applies the IsNil predicate on the "PointLB" field.
func PointLBIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPointLB)))
	})
}

// PointLBNotNil applies the NotNil predicate on the "PointLB" field.
func PointLBNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPointLB)))
	})
}

// DateExportLBEQ applies the EQ predicate on the "DateExportLB" field.
func DateExportLBEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBNEQ applies the NEQ predicate on the "DateExportLB" field.
func DateExportLBNEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBIn applies the In predicate on the "DateExportLB" field.
func DateExportLBIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateExportLB), v...))
	})
}

// DateExportLBNotIn applies the NotIn predicate on the "DateExportLB" field.
func DateExportLBNotIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateExportLB), v...))
	})
}

// DateExportLBGT applies the GT predicate on the "DateExportLB" field.
func DateExportLBGT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBGTE applies the GTE predicate on the "DateExportLB" field.
func DateExportLBGTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBLT applies the LT predicate on the "DateExportLB" field.
func DateExportLBLT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBLTE applies the LTE predicate on the "DateExportLB" field.
func DateExportLBLTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateExportLB), v))
	})
}

// DateExportLBIsNil applies the IsNil predicate on the "DateExportLB" field.
func DateExportLBIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateExportLB)))
	})
}

// DateExportLBNotNil applies the NotNil predicate on the "DateExportLB" field.
func DateExportLBNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateExportLB)))
	})
}

// DateGenLBEQ applies the EQ predicate on the "DateGenLB" field.
func DateGenLBEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBNEQ applies the NEQ predicate on the "DateGenLB" field.
func DateGenLBNEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBIn applies the In predicate on the "DateGenLB" field.
func DateGenLBIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDateGenLB), v...))
	})
}

// DateGenLBNotIn applies the NotIn predicate on the "DateGenLB" field.
func DateGenLBNotIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDateGenLB), v...))
	})
}

// DateGenLBGT applies the GT predicate on the "DateGenLB" field.
func DateGenLBGT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBGTE applies the GTE predicate on the "DateGenLB" field.
func DateGenLBGTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBLT applies the LT predicate on the "DateGenLB" field.
func DateGenLBLT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBLTE applies the LTE predicate on the "DateGenLB" field.
func DateGenLBLTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDateGenLB), v))
	})
}

// DateGenLBIsNil applies the IsNil predicate on the "DateGenLB" field.
func DateGenLBIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDateGenLB)))
	})
}

// DateGenLBNotNil applies the NotNil predicate on the "DateGenLB" field.
func DateGenLBNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDateGenLB)))
	})
}

// NoteLBEQ applies the EQ predicate on the "NoteLB" field.
func NoteLBEQ(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldNoteLB), v))
	})
}

// NoteLBNEQ applies the NEQ predicate on the "NoteLB" field.
func NoteLBNEQ(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldNoteLB), v))
	})
}

// NoteLBIn applies the In predicate on the "NoteLB" field.
func NoteLBIn(vs ...string) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldNoteLB), v...))
	})
}

// NoteLBNotIn applies the NotIn predicate on the "NoteLB" field.
func NoteLBNotIn(vs ...string) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldNoteLB), v...))
	})
}

// NoteLBGT applies the GT predicate on the "NoteLB" field.
func NoteLBGT(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldNoteLB), v))
	})
}

// NoteLBGTE applies the GTE predicate on the "NoteLB" field.
func NoteLBGTE(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldNoteLB), v))
	})
}

// NoteLBLT applies the LT predicate on the "NoteLB" field.
func NoteLBLT(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldNoteLB), v))
	})
}

// NoteLBLTE applies the LTE predicate on the "NoteLB" field.
func NoteLBLTE(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldNoteLB), v))
	})
}

// NoteLBContains applies the Contains predicate on the "NoteLB" field.
func NoteLBContains(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldNoteLB), v))
	})
}

// NoteLBHasPrefix applies the HasPrefix predicate on the "NoteLB" field.
func NoteLBHasPrefix(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldNoteLB), v))
	})
}

// NoteLBHasSuffix applies the HasSuffix predicate on the "NoteLB" field.
func NoteLBHasSuffix(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldNoteLB), v))
	})
}

// NoteLBIsNil applies the IsNil predicate on the "NoteLB" field.
func NoteLBIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldNoteLB)))
	})
}

// NoteLBNotNil applies the NotNil predicate on the "NoteLB" field.
func NoteLBNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldNoteLB)))
	})
}

// NoteLBEqualFold applies the EqualFold predicate on the "NoteLB" field.
func NoteLBEqualFold(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldNoteLB), v))
	})
}

// NoteLBContainsFold applies the ContainsFold predicate on the "NoteLB" field.
func NoteLBContainsFold(v string) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldNoteLB), v))
	})
}

// StatusExportLBEQ applies the EQ predicate on the "StatusExportLB" field.
func StatusExportLBEQ(v bool) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusExportLB), v))
	})
}

// StatusExportLBNEQ applies the NEQ predicate on the "StatusExportLB" field.
func StatusExportLBNEQ(v bool) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatusExportLB), v))
	})
}

// StatusExportLBIsNil applies the IsNil predicate on the "StatusExportLB" field.
func StatusExportLBIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatusExportLB)))
	})
}

// StatusExportLBNotNil applies the NotNil predicate on the "StatusExportLB" field.
func StatusExportLBNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatusExportLB)))
	})
}

// LBDateEQ applies the EQ predicate on the "LBDate" field.
func LBDateEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLBDate), v))
	})
}

// LBDateNEQ applies the NEQ predicate on the "LBDate" field.
func LBDateNEQ(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLBDate), v))
	})
}

// LBDateIn applies the In predicate on the "LBDate" field.
func LBDateIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLBDate), v...))
	})
}

// LBDateNotIn applies the NotIn predicate on the "LBDate" field.
func LBDateNotIn(vs ...time.Time) predicate.Pointpendinglbtransaction {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLBDate), v...))
	})
}

// LBDateGT applies the GT predicate on the "LBDate" field.
func LBDateGT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLBDate), v))
	})
}

// LBDateGTE applies the GTE predicate on the "LBDate" field.
func LBDateGTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLBDate), v))
	})
}

// LBDateLT applies the LT predicate on the "LBDate" field.
func LBDateLT(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLBDate), v))
	})
}

// LBDateLTE applies the LTE predicate on the "LBDate" field.
func LBDateLTE(v time.Time) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLBDate), v))
	})
}

// LBDateIsNil applies the IsNil predicate on the "LBDate" field.
func LBDateIsNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldLBDate)))
	})
}

// LBDateNotNil applies the NotNil predicate on the "LBDate" field.
func LBDateNotNil() predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldLBDate)))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Pointpendinglbtransaction) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Pointpendinglbtransaction) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Pointpendinglbtransaction) predicate.Pointpendinglbtransaction {
	return predicate.Pointpendinglbtransaction(func(s *sql.Selector) {
		p(s.Not())
	})
}
