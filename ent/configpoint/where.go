// Code generated by entc, DO NOT EDIT.

package configpoint

import (
	"go-api-report2/ent/predicate"
	"time"

	"entgo.io/ent/dialect/sql"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// TransactionName applies equality check predicate on the "TransactionName" field. It's identical to TransactionNameEQ.
func TransactionName(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionName), v))
	})
}

// TransactionType applies equality check predicate on the "TransactionType" field. It's identical to TransactionTypeEQ.
func TransactionType(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionType), v))
	})
}

// PaymentChannel applies equality check predicate on the "PaymentChannel" field. It's identical to PaymentChannelEQ.
func PaymentChannel(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentType applies equality check predicate on the "PaymentType" field. It's identical to PaymentTypeEQ.
func PaymentType(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentType), v))
	})
}

// DummyWallet applies equality check predicate on the "DummyWallet" field. It's identical to DummyWalletEQ.
func DummyWallet(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDummyWallet), v))
	})
}

// Amount applies equality check predicate on the "Amount" field. It's identical to AmountEQ.
func Amount(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// Point applies equality check predicate on the "Point" field. It's identical to PointEQ.
func Point(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoint), v))
	})
}

// Expire applies equality check predicate on the "Expire" field. It's identical to ExpireEQ.
func Expire(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpire), v))
	})
}

// UpdateDate applies equality check predicate on the "UpdateDate" field. It's identical to UpdateDateEQ.
func UpdateDate(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateDate), v))
	})
}

// ExpireDate applies equality check predicate on the "ExpireDate" field. It's identical to ExpireDateEQ.
func ExpireDate(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpireDate), v))
	})
}

// StatusTransaction applies equality check predicate on the "StatusTransaction" field. It's identical to StatusTransactionEQ.
func StatusTransaction(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusTransaction), v))
	})
}

// TransactionNameEQ applies the EQ predicate on the "TransactionName" field.
func TransactionNameEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionName), v))
	})
}

// TransactionNameNEQ applies the NEQ predicate on the "TransactionName" field.
func TransactionNameNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionName), v))
	})
}

// TransactionNameIn applies the In predicate on the "TransactionName" field.
func TransactionNameIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionName), v...))
	})
}

// TransactionNameNotIn applies the NotIn predicate on the "TransactionName" field.
func TransactionNameNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionName), v...))
	})
}

// TransactionNameGT applies the GT predicate on the "TransactionName" field.
func TransactionNameGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionName), v))
	})
}

// TransactionNameGTE applies the GTE predicate on the "TransactionName" field.
func TransactionNameGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionName), v))
	})
}

// TransactionNameLT applies the LT predicate on the "TransactionName" field.
func TransactionNameLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionName), v))
	})
}

// TransactionNameLTE applies the LTE predicate on the "TransactionName" field.
func TransactionNameLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionName), v))
	})
}

// TransactionNameContains applies the Contains predicate on the "TransactionName" field.
func TransactionNameContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionName), v))
	})
}

// TransactionNameHasPrefix applies the HasPrefix predicate on the "TransactionName" field.
func TransactionNameHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionName), v))
	})
}

// TransactionNameHasSuffix applies the HasSuffix predicate on the "TransactionName" field.
func TransactionNameHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionName), v))
	})
}

// TransactionNameIsNil applies the IsNil predicate on the "TransactionName" field.
func TransactionNameIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTransactionName)))
	})
}

// TransactionNameNotNil applies the NotNil predicate on the "TransactionName" field.
func TransactionNameNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTransactionName)))
	})
}

// TransactionNameEqualFold applies the EqualFold predicate on the "TransactionName" field.
func TransactionNameEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionName), v))
	})
}

// TransactionNameContainsFold applies the ContainsFold predicate on the "TransactionName" field.
func TransactionNameContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionName), v))
	})
}

// TransactionTypeEQ applies the EQ predicate on the "TransactionType" field.
func TransactionTypeEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeNEQ applies the NEQ predicate on the "TransactionType" field.
func TransactionTypeNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeIn applies the In predicate on the "TransactionType" field.
func TransactionTypeIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldTransactionType), v...))
	})
}

// TransactionTypeNotIn applies the NotIn predicate on the "TransactionType" field.
func TransactionTypeNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldTransactionType), v...))
	})
}

// TransactionTypeGT applies the GT predicate on the "TransactionType" field.
func TransactionTypeGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeGTE applies the GTE predicate on the "TransactionType" field.
func TransactionTypeGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeLT applies the LT predicate on the "TransactionType" field.
func TransactionTypeLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeLTE applies the LTE predicate on the "TransactionType" field.
func TransactionTypeLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeContains applies the Contains predicate on the "TransactionType" field.
func TransactionTypeContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeHasPrefix applies the HasPrefix predicate on the "TransactionType" field.
func TransactionTypeHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeHasSuffix applies the HasSuffix predicate on the "TransactionType" field.
func TransactionTypeHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeIsNil applies the IsNil predicate on the "TransactionType" field.
func TransactionTypeIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldTransactionType)))
	})
}

// TransactionTypeNotNil applies the NotNil predicate on the "TransactionType" field.
func TransactionTypeNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldTransactionType)))
	})
}

// TransactionTypeEqualFold applies the EqualFold predicate on the "TransactionType" field.
func TransactionTypeEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldTransactionType), v))
	})
}

// TransactionTypeContainsFold applies the ContainsFold predicate on the "TransactionType" field.
func TransactionTypeContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldTransactionType), v))
	})
}

// PaymentChannelEQ applies the EQ predicate on the "PaymentChannel" field.
func PaymentChannelEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelNEQ applies the NEQ predicate on the "PaymentChannel" field.
func PaymentChannelNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelIn applies the In predicate on the "PaymentChannel" field.
func PaymentChannelIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentChannel), v...))
	})
}

// PaymentChannelNotIn applies the NotIn predicate on the "PaymentChannel" field.
func PaymentChannelNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentChannel), v...))
	})
}

// PaymentChannelGT applies the GT predicate on the "PaymentChannel" field.
func PaymentChannelGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelGTE applies the GTE predicate on the "PaymentChannel" field.
func PaymentChannelGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelLT applies the LT predicate on the "PaymentChannel" field.
func PaymentChannelLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelLTE applies the LTE predicate on the "PaymentChannel" field.
func PaymentChannelLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelContains applies the Contains predicate on the "PaymentChannel" field.
func PaymentChannelContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelHasPrefix applies the HasPrefix predicate on the "PaymentChannel" field.
func PaymentChannelHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelHasSuffix applies the HasSuffix predicate on the "PaymentChannel" field.
func PaymentChannelHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelIsNil applies the IsNil predicate on the "PaymentChannel" field.
func PaymentChannelIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentChannel)))
	})
}

// PaymentChannelNotNil applies the NotNil predicate on the "PaymentChannel" field.
func PaymentChannelNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentChannel)))
	})
}

// PaymentChannelEqualFold applies the EqualFold predicate on the "PaymentChannel" field.
func PaymentChannelEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPaymentChannel), v))
	})
}

// PaymentChannelContainsFold applies the ContainsFold predicate on the "PaymentChannel" field.
func PaymentChannelContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPaymentChannel), v))
	})
}

// PaymentTypeEQ applies the EQ predicate on the "PaymentType" field.
func PaymentTypeEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeNEQ applies the NEQ predicate on the "PaymentType" field.
func PaymentTypeNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeIn applies the In predicate on the "PaymentType" field.
func PaymentTypeIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPaymentType), v...))
	})
}

// PaymentTypeNotIn applies the NotIn predicate on the "PaymentType" field.
func PaymentTypeNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPaymentType), v...))
	})
}

// PaymentTypeGT applies the GT predicate on the "PaymentType" field.
func PaymentTypeGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeGTE applies the GTE predicate on the "PaymentType" field.
func PaymentTypeGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeLT applies the LT predicate on the "PaymentType" field.
func PaymentTypeLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeLTE applies the LTE predicate on the "PaymentType" field.
func PaymentTypeLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeContains applies the Contains predicate on the "PaymentType" field.
func PaymentTypeContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeHasPrefix applies the HasPrefix predicate on the "PaymentType" field.
func PaymentTypeHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeHasSuffix applies the HasSuffix predicate on the "PaymentType" field.
func PaymentTypeHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeIsNil applies the IsNil predicate on the "PaymentType" field.
func PaymentTypeIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPaymentType)))
	})
}

// PaymentTypeNotNil applies the NotNil predicate on the "PaymentType" field.
func PaymentTypeNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPaymentType)))
	})
}

// PaymentTypeEqualFold applies the EqualFold predicate on the "PaymentType" field.
func PaymentTypeEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPaymentType), v))
	})
}

// PaymentTypeContainsFold applies the ContainsFold predicate on the "PaymentType" field.
func PaymentTypeContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPaymentType), v))
	})
}

// DummyWalletEQ applies the EQ predicate on the "DummyWallet" field.
func DummyWalletEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletNEQ applies the NEQ predicate on the "DummyWallet" field.
func DummyWalletNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletIn applies the In predicate on the "DummyWallet" field.
func DummyWalletIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldDummyWallet), v...))
	})
}

// DummyWalletNotIn applies the NotIn predicate on the "DummyWallet" field.
func DummyWalletNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldDummyWallet), v...))
	})
}

// DummyWalletGT applies the GT predicate on the "DummyWallet" field.
func DummyWalletGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletGTE applies the GTE predicate on the "DummyWallet" field.
func DummyWalletGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletLT applies the LT predicate on the "DummyWallet" field.
func DummyWalletLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletLTE applies the LTE predicate on the "DummyWallet" field.
func DummyWalletLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletContains applies the Contains predicate on the "DummyWallet" field.
func DummyWalletContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletHasPrefix applies the HasPrefix predicate on the "DummyWallet" field.
func DummyWalletHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletHasSuffix applies the HasSuffix predicate on the "DummyWallet" field.
func DummyWalletHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletIsNil applies the IsNil predicate on the "DummyWallet" field.
func DummyWalletIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldDummyWallet)))
	})
}

// DummyWalletNotNil applies the NotNil predicate on the "DummyWallet" field.
func DummyWalletNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldDummyWallet)))
	})
}

// DummyWalletEqualFold applies the EqualFold predicate on the "DummyWallet" field.
func DummyWalletEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldDummyWallet), v))
	})
}

// DummyWalletContainsFold applies the ContainsFold predicate on the "DummyWallet" field.
func DummyWalletContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldDummyWallet), v))
	})
}

// AmountEQ applies the EQ predicate on the "Amount" field.
func AmountEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmount), v))
	})
}

// AmountNEQ applies the NEQ predicate on the "Amount" field.
func AmountNEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmount), v))
	})
}

// AmountIn applies the In predicate on the "Amount" field.
func AmountIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmount), v...))
	})
}

// AmountNotIn applies the NotIn predicate on the "Amount" field.
func AmountNotIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmount), v...))
	})
}

// AmountGT applies the GT predicate on the "Amount" field.
func AmountGT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmount), v))
	})
}

// AmountGTE applies the GTE predicate on the "Amount" field.
func AmountGTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmount), v))
	})
}

// AmountLT applies the LT predicate on the "Amount" field.
func AmountLT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmount), v))
	})
}

// AmountLTE applies the LTE predicate on the "Amount" field.
func AmountLTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmount), v))
	})
}

// AmountIsNil applies the IsNil predicate on the "Amount" field.
func AmountIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldAmount)))
	})
}

// AmountNotNil applies the NotNil predicate on the "Amount" field.
func AmountNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldAmount)))
	})
}

// PointEQ applies the EQ predicate on the "Point" field.
func PointEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPoint), v))
	})
}

// PointNEQ applies the NEQ predicate on the "Point" field.
func PointNEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPoint), v))
	})
}

// PointIn applies the In predicate on the "Point" field.
func PointIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPoint), v...))
	})
}

// PointNotIn applies the NotIn predicate on the "Point" field.
func PointNotIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPoint), v...))
	})
}

// PointGT applies the GT predicate on the "Point" field.
func PointGT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPoint), v))
	})
}

// PointGTE applies the GTE predicate on the "Point" field.
func PointGTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPoint), v))
	})
}

// PointLT applies the LT predicate on the "Point" field.
func PointLT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPoint), v))
	})
}

// PointLTE applies the LTE predicate on the "Point" field.
func PointLTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPoint), v))
	})
}

// PointIsNil applies the IsNil predicate on the "Point" field.
func PointIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldPoint)))
	})
}

// PointNotNil applies the NotNil predicate on the "Point" field.
func PointNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldPoint)))
	})
}

// ExpireEQ applies the EQ predicate on the "Expire" field.
func ExpireEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpire), v))
	})
}

// ExpireNEQ applies the NEQ predicate on the "Expire" field.
func ExpireNEQ(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExpire), v))
	})
}

// ExpireIn applies the In predicate on the "Expire" field.
func ExpireIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExpire), v...))
	})
}

// ExpireNotIn applies the NotIn predicate on the "Expire" field.
func ExpireNotIn(vs ...int) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExpire), v...))
	})
}

// ExpireGT applies the GT predicate on the "Expire" field.
func ExpireGT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExpire), v))
	})
}

// ExpireGTE applies the GTE predicate on the "Expire" field.
func ExpireGTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExpire), v))
	})
}

// ExpireLT applies the LT predicate on the "Expire" field.
func ExpireLT(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExpire), v))
	})
}

// ExpireLTE applies the LTE predicate on the "Expire" field.
func ExpireLTE(v int) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExpire), v))
	})
}

// ExpireIsNil applies the IsNil predicate on the "Expire" field.
func ExpireIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldExpire)))
	})
}

// ExpireNotNil applies the NotNil predicate on the "Expire" field.
func ExpireNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldExpire)))
	})
}

// UpdateDateEQ applies the EQ predicate on the "UpdateDate" field.
func UpdateDateEQ(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateNEQ applies the NEQ predicate on the "UpdateDate" field.
func UpdateDateNEQ(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateIn applies the In predicate on the "UpdateDate" field.
func UpdateDateIn(vs ...time.Time) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUpdateDate), v...))
	})
}

// UpdateDateNotIn applies the NotIn predicate on the "UpdateDate" field.
func UpdateDateNotIn(vs ...time.Time) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUpdateDate), v...))
	})
}

// UpdateDateGT applies the GT predicate on the "UpdateDate" field.
func UpdateDateGT(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateGTE applies the GTE predicate on the "UpdateDate" field.
func UpdateDateGTE(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateLT applies the LT predicate on the "UpdateDate" field.
func UpdateDateLT(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateLTE applies the LTE predicate on the "UpdateDate" field.
func UpdateDateLTE(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUpdateDate), v))
	})
}

// UpdateDateIsNil applies the IsNil predicate on the "UpdateDate" field.
func UpdateDateIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldUpdateDate)))
	})
}

// UpdateDateNotNil applies the NotNil predicate on the "UpdateDate" field.
func UpdateDateNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldUpdateDate)))
	})
}

// ExpireDateEQ applies the EQ predicate on the "ExpireDate" field.
func ExpireDateEQ(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldExpireDate), v))
	})
}

// ExpireDateNEQ applies the NEQ predicate on the "ExpireDate" field.
func ExpireDateNEQ(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldExpireDate), v))
	})
}

// ExpireDateIn applies the In predicate on the "ExpireDate" field.
func ExpireDateIn(vs ...time.Time) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldExpireDate), v...))
	})
}

// ExpireDateNotIn applies the NotIn predicate on the "ExpireDate" field.
func ExpireDateNotIn(vs ...time.Time) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldExpireDate), v...))
	})
}

// ExpireDateGT applies the GT predicate on the "ExpireDate" field.
func ExpireDateGT(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldExpireDate), v))
	})
}

// ExpireDateGTE applies the GTE predicate on the "ExpireDate" field.
func ExpireDateGTE(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldExpireDate), v))
	})
}

// ExpireDateLT applies the LT predicate on the "ExpireDate" field.
func ExpireDateLT(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldExpireDate), v))
	})
}

// ExpireDateLTE applies the LTE predicate on the "ExpireDate" field.
func ExpireDateLTE(v time.Time) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldExpireDate), v))
	})
}

// ExpireDateIsNil applies the IsNil predicate on the "ExpireDate" field.
func ExpireDateIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldExpireDate)))
	})
}

// ExpireDateNotNil applies the NotNil predicate on the "ExpireDate" field.
func ExpireDateNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldExpireDate)))
	})
}

// StatusTransactionEQ applies the EQ predicate on the "StatusTransaction" field.
func StatusTransactionEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionNEQ applies the NEQ predicate on the "StatusTransaction" field.
func StatusTransactionNEQ(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionIn applies the In predicate on the "StatusTransaction" field.
func StatusTransactionIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldStatusTransaction), v...))
	})
}

// StatusTransactionNotIn applies the NotIn predicate on the "StatusTransaction" field.
func StatusTransactionNotIn(vs ...string) predicate.Configpoint {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Configpoint(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldStatusTransaction), v...))
	})
}

// StatusTransactionGT applies the GT predicate on the "StatusTransaction" field.
func StatusTransactionGT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionGTE applies the GTE predicate on the "StatusTransaction" field.
func StatusTransactionGTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionLT applies the LT predicate on the "StatusTransaction" field.
func StatusTransactionLT(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionLTE applies the LTE predicate on the "StatusTransaction" field.
func StatusTransactionLTE(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionContains applies the Contains predicate on the "StatusTransaction" field.
func StatusTransactionContains(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionHasPrefix applies the HasPrefix predicate on the "StatusTransaction" field.
func StatusTransactionHasPrefix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionHasSuffix applies the HasSuffix predicate on the "StatusTransaction" field.
func StatusTransactionHasSuffix(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionIsNil applies the IsNil predicate on the "StatusTransaction" field.
func StatusTransactionIsNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.IsNull(s.C(FieldStatusTransaction)))
	})
}

// StatusTransactionNotNil applies the NotNil predicate on the "StatusTransaction" field.
func StatusTransactionNotNil() predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.NotNull(s.C(FieldStatusTransaction)))
	})
}

// StatusTransactionEqualFold applies the EqualFold predicate on the "StatusTransaction" field.
func StatusTransactionEqualFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldStatusTransaction), v))
	})
}

// StatusTransactionContainsFold applies the ContainsFold predicate on the "StatusTransaction" field.
func StatusTransactionContainsFold(v string) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldStatusTransaction), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Configpoint) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Configpoint) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Configpoint) predicate.Configpoint {
	return predicate.Configpoint(func(s *sql.Selector) {
		p(s.Not())
	})
}
